/*!
 * starcitizen-webgl-map v0.2.0 by Lianna Eeftinck
 * Copyright 2014 Lianna Eeftinck
 * https://github.com/Leeft/Star-Citizen-WebGL-Map
 * Licensed under http://opensource.org/licenses/MIT
 */
if (typeof jQuery === "undefined") { throw new Error("starcitizen-webgl-map requires jQuery"); }
if (typeof THREE === "undefined") { throw new Error("starcitizen-webgl-map requires THREE.js"); }
/**
* @author LiannaEeftinck / https://github.com/Leeft
*/

var SCMAP = SCMAP || { REVISION: '3' };

self.console = self.console || {
   info: function () {},
   log: function () {},
   debug: function () {},
   warn: function () {},
   error: function () {}
};

SCMAP.data = {
   factions: [],
   crime_levels: [],
   uee_strategic_values: [],
   goods: [],
   map: {},
   systems: [],
   systemsById: []
};

SCMAP.Symbol = {};
SCMAP.Symbols = {};

SCMAP.Symbol.SIZE = 24;
SCMAP.Symbol.SPACING = 9;

SCMAP.Symbol.getTag = function ( icon ) {
   var $icon = $( '<i title="'+icon.description+'" class="fa fa-fw '+icon.faClass+'"></i>' );
   $icon.css( 'color', icon.color );
   return $icon;
};

SCMAP.Symbols.DANGER = {
   code: "\uf071",
   scale: 0.9,
   faClass: 'fa-warning',
   description: 'Danger, hostile faction',
   color: 'rgba(255,50,50,1.0)'
};
SCMAP.Symbols.WARNING = {
   code: "\uf071",
   scale: 0.9,
   faClass: 'fa-warning',
   description: 'Warning, hostile environment',
   color: 'rgba(255,117,25,1.0)'
};
SCMAP.Symbols.HANGAR = {
   code: "\uf015",
   scale: 1.15,
   faClass: 'fa-home',
   description: 'Hangar location',
   color: 'rgba(255,255,255,1.0)',
   offset: new THREE.Vector2( -0.25, 2 )
};
SCMAP.Symbols.INFO = {
   code: "\uf05a",
   scale: 1.0,
   faClass: 'fa-info-circle',
   description: 'Information available',
   color: 'rgba(255, 162, 255, 1.0)'//,
   //offset: new THREE.Vector2( 0, 2 )
};
SCMAP.Symbols.TRADE = {
   code: "\uf0ec",
   scale: 0.90,
   faClass: 'fa-exchange',
   description: 'Major trade hub',
   color: 'rgba(255,255,0,1.0)',
   offset: new THREE.Vector2( 0, -3 )
};
//SCMAP.Symbols.TRADE = {
//   code: "\uf0d1",
//   scale: 1.0,
//   faClass: 'fa-truck',
//   description: 'Major trade hub',
//   color: 'rgba(255,255,0,1.0)',
//   offset: new THREE.Vector2( -2, -2 )
//};
SCMAP.Symbols.BANNED = {
   code: "\uf05e",
   scale: 1.0,
   faClass: 'fa-ban',
   description: 'System off-limits',
   color: 'rgba(255, 117, 25, 1.0)'
};
SCMAP.Symbols.COMMENTS = {
   code: "\uf075",
   scale: 1.0,
   faClass: 'fa-comment',
   description: 'Your comments',
   color: 'rgba(106, 187, 207, 1.0)',
   offset: new THREE.Vector2( 0, -3 )
};
SCMAP.Symbols.BOOKMARK = {
   code: "\uf02e",
   scale: 1.05,
   faClass: 'fa-bookmark',
   description: 'Bookmarked',
   color: 'rgba(102, 193, 0, 1.0)',
   offset: new THREE.Vector2( -2, 1 )
};

SCMAP.travelTimeAU = function ( distanceAU ) {
   return( SCMAP.approximateTraveltimePerAU * distanceAU );
};

SCMAP.usersFaction = function ( ) {
   // TODO: allow users to set their faction, if ever needed
   return SCMAP.data.factionsByName.UEE;
};

// constants here

SCMAP.LYtoAU = 63241.077;
SCMAP.approximateTraveltimePerAU = ( ( 8 * 60 ) + 19 ) * 5; // 8:19 at 1c, but autopilot speed is 0.2c

// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.Settings = function () {
   this.storage = null;
   if ( hasLocalStorage() ) {
      this.storage = window.localStorage;
   }

   this.glow = ( this.storage && this.storage['settings.Glow'] === '0' ) ? false : true;
   this.labels = ( this.storage && this.storage['settings.Labels'] === '0' ) ? false : true;
   this.labelIcons = ( this.storage && this.storage['settings.LabelIcons'] === '0' ) ? false : true;

   this.camera = {
      camera: new THREE.Vector3( 0, 80, 100 ),
      target: new THREE.Vector3( 0, 10, 0 ),
      orientation: {
         theta: 0,
         phi: 0.9616764178488756,
         radius: 122.2
      }
   };
   this.cameraDefaults = JSON.parse( JSON.stringify( this.camera ) );
   this.cameraDefaults.camera = new THREE.Vector3();
   this.cameraDefaults.camera.copy( this.camera.camera );
   this.cameraDefaults.target = new THREE.Vector3();
   this.cameraDefaults.target.copy( this.camera.target );
   this.load( 'camera' );

   this.effect = {
      Antialias: true,
      FXAA: false,
      Bloom: false
   };
   this.load( 'effect' );

   this.control = {
      rotationLocked: ( this.storage && this.storage['control.rotationLocked'] === '1' ) ? true : false
   };

   this.renderer = {
      Stats: ( this.storage && this.storage['renderer.Stats'] === '1' ) ? true : false
   };

   this.route = {
      avoidHostile: false,
      avoidOffLimits: false,
      avoidUnknownJumppoints: false
   };
   if ( this.storage && 'route' in this.storage ) {
      this.load( 'route' );
   }

   this.mode = ( this.storage && this.storage.mode ) ? this.storage.mode : '3d';
};

SCMAP.Settings.prototype = {

   constructor: SCMAP.Settings,

   load: function save( key ) {
      if ( this.storage && ( key in this.storage ) ) {
         try {
            this[ key ] = JSON.parse( this.storage[ key ] );
         } catch ( e ) {
            console.error( "Error parsing 'localStorage." + key + "'; " + e.name + ": " + e.message );
         }
      }
   },

   save: function save( key ) {
      if ( this.storage && ( key in this ) ) {
         this.storage[ key ] = JSON.stringify( this[ key ] );
      }
   }

};

SCMAP.settings = new SCMAP.Settings();

function _build_selected_system_object () {
   var object = new THREE.JSONLoader().parse( {
    "metadata" : {
        "formatVersion" : 3.1,
        "sourceFile"    : "selected_system.obj",
        "generatedBy"   : "OBJConverter",
        "vertices"      : 248,
        "faces"         : 248,
        "normals"       : 960,
        "colors"        : 0,
        "uvs"           : 0,
        "materials"     : 1
    },
    "scale" : 1,
    "vertices": [-0.5,0.5,0.5,-0.52,0.2,0.5,-0.52,0.2,0.44,-0.52,0.44,0.44,-0.52,0.5,0.5,-0.5,0.52,0.5,-0.5,0.5,0.52,-0.52,0.44,0.2,-0.52,0.5,0.2,-0.5,0.52,0.2,-0.44,0.52,0.2,-0.44,0.52,0.44,-0.44,0.44,0.52,-0.5,0.2,0.52,-0.44,0.2,0.52,-0.2,0.52,0.44,-0.2,0.52,0.5,-0.2,0.5,0.52,-0.2,0.44,0.52,-0.5,0.44,0.2,-0.5,0.5,0.2,-0.44,0.5,0.2,-0.2,0.44,0.5,-0.2,0.5,0.44,-0.2,0.5,0.5,-0.5,0.44,0.44,-0.44,0.44,0.5,-0.44,0.5,0.44,-0.5,0.2,0.5,-0.5,0.2,0.44,-0.44,0.2,0.5,0.5,0.5,0.5,0.52,0.2,0.5,0.52,0.2,0.44,0.52,0.44,0.44,0.52,0.5,0.5,0.5,0.52,0.5,0.5,0.5,0.52,0.52,0.44,0.2,0.52,0.5,0.2,0.5,0.52,0.2,0.44,0.52,0.2,0.44,0.52,0.44,0.44,0.44,0.52,0.5,0.2,0.52,0.44,0.2,0.52,0.2,0.52,0.44,0.2,0.52,0.5,0.2,0.5,0.52,0.2,0.44,0.52,0.5,0.44,0.2,0.5,0.5,0.2,0.44,0.5,0.2,0.2,0.44,0.5,0.2,0.5,0.44,0.2,0.5,0.5,0.5,0.44,0.44,0.44,0.44,0.5,0.44,0.5,0.44,0.5,0.2,0.5,0.5,0.2,0.44,0.44,0.2,0.5,-0.5,-0.5,0.5,-0.52,-0.2,0.5,-0.52,-0.2,0.44,-0.52,-0.44,0.44,-0.52,-0.5,0.5,-0.5,-0.52,0.5,-0.5,-0.5,0.52,-0.52,-0.44,0.2,-0.52,-0.5,0.2,-0.5,-0.52,0.2,-0.44,-0.52,0.2,-0.44,-0.52,0.44,-0.44,-0.44,0.52,-0.5,-0.2,0.52,-0.44,-0.2,0.52,-0.2,-0.52,0.44,-0.2,-0.52,0.5,-0.2,-0.5,0.52,-0.2,-0.44,0.52,-0.5,-0.44,0.2,-0.5,-0.5,0.2,-0.44,-0.5,0.2,-0.2,-0.44,0.5,-0.2,-0.5,0.44,-0.2,-0.5,0.5,-0.5,-0.44,0.44,-0.44,-0.44,0.5,-0.44,-0.5,0.44,-0.5,-0.2,0.5,-0.5,-0.2,0.44,-0.44,-0.2,0.5,0.5,-0.5,0.5,0.52,-0.2,0.5,0.52,-0.2,0.44,0.52,-0.44,0.44,0.52,-0.5,0.5,0.5,-0.52,0.5,0.5,-0.5,0.52,0.52,-0.44,0.2,0.52,-0.5,0.2,0.5,-0.52,0.2,0.44,-0.52,0.2,0.44,-0.52,0.44,0.44,-0.44,0.52,0.5,-0.2,0.52,0.44,-0.2,0.52,0.2,-0.52,0.44,0.2,-0.52,0.5,0.2,-0.5,0.52,0.2,-0.44,0.52,0.5,-0.44,0.2,0.5,-0.5,0.2,0.44,-0.5,0.2,0.2,-0.44,0.5,0.2,-0.5,0.44,0.2,-0.5,0.5,0.5,-0.44,0.44,0.44,-0.44,0.5,0.44,-0.5,0.44,0.5,-0.2,0.5,0.5,-0.2,0.44,0.44,-0.2,0.5,-0.5,0.5,-0.5,-0.52,0.2,-0.5,-0.52,0.2,-0.44,-0.52,0.44,-0.44,-0.52,0.5,-0.5,-0.5,0.52,-0.5,-0.5,0.5,-0.52,-0.52,0.44,-0.2,-0.52,0.5,-0.2,-0.5,0.52,-0.2,-0.44,0.52,-0.2,-0.44,0.52,-0.44,-0.44,0.44,-0.52,-0.5,0.2,-0.52,-0.44,0.2,-0.52,-0.2,0.52,-0.44,-0.2,0.52,-0.5,-0.2,0.5,-0.52,-0.2,0.44,-0.52,-0.5,0.44,-0.2,-0.5,0.5,-0.2,-0.44,0.5,-0.2,-0.2,0.44,-0.5,-0.2,0.5,-0.44,-0.2,0.5,-0.5,-0.5,0.44,-0.44,-0.44,0.44,-0.5,-0.44,0.5,-0.44,-0.5,0.2,-0.5,-0.5,0.2,-0.44,-0.44,0.2,-0.5,0.5,0.5,-0.5,0.52,0.2,-0.5,0.52,0.2,-0.44,0.52,0.44,-0.44,0.52,0.5,-0.5,0.5,0.52,-0.5,0.5,0.5,-0.52,0.52,0.44,-0.2,0.52,0.5,-0.2,0.5,0.52,-0.2,0.44,0.52,-0.2,0.44,0.52,-0.44,0.44,0.44,-0.52,0.5,0.2,-0.52,0.44,0.2,-0.52,0.2,0.52,-0.44,0.2,0.52,-0.5,0.2,0.5,-0.52,0.2,0.44,-0.52,0.5,0.44,-0.2,0.5,0.5,-0.2,0.44,0.5,-0.2,0.2,0.44,-0.5,0.2,0.5,-0.44,0.2,0.5,-0.5,0.5,0.44,-0.44,0.44,0.44,-0.5,0.44,0.5,-0.44,0.5,0.2,-0.5,0.5,0.2,-0.44,0.44,0.2,-0.5,-0.5,-0.5,-0.5,-0.52,-0.2,-0.5,-0.52,-0.2,-0.44,-0.52,-0.44,-0.44,-0.52,-0.5,-0.5,-0.5,-0.52,-0.5,-0.5,-0.5,-0.52,-0.52,-0.44,-0.2,-0.52,-0.5,-0.2,-0.5,-0.52,-0.2,-0.44,-0.52,-0.2,-0.44,-0.52,-0.44,-0.44,-0.44,-0.52,-0.5,-0.2,-0.52,-0.44,-0.2,-0.52,-0.2,-0.52,-0.44,-0.2,-0.52,-0.5,-0.2,-0.5,-0.52,-0.2,-0.44,-0.52,-0.5,-0.44,-0.2,-0.5,-0.5,-0.2,-0.44,-0.5,-0.2,-0.2,-0.44,-0.5,-0.2,-0.5,-0.44,-0.2,-0.5,-0.5,-0.5,-0.44,-0.44,-0.44,-0.44,-0.5,-0.44,-0.5,-0.44,-0.5,-0.2,-0.5,-0.5,-0.2,-0.44,-0.44,-0.2,-0.5,0.5,-0.5,-0.5,0.52,-0.2,-0.5,0.52,-0.2,-0.44,0.52,-0.44,-0.44,0.52,-0.5,-0.5,0.5,-0.52,-0.5,0.5,-0.5,-0.52,0.52,-0.44,-0.2,0.52,-0.5,-0.2,0.5,-0.52,-0.2,0.44,-0.52,-0.2,0.44,-0.52,-0.44,0.44,-0.44,-0.52,0.5,-0.2,-0.52,0.44,-0.2,-0.52,0.2,-0.52,-0.44,0.2,-0.52,-0.5,0.2,-0.5,-0.52,0.2,-0.44,-0.52,0.5,-0.44,-0.2,0.5,-0.5,-0.2,0.44,-0.5,-0.2,0.2,-0.44,-0.5,0.2,-0.5,-0.44,0.2,-0.5,-0.5,0.5,-0.44,-0.44,0.44,-0.44,-0.5,0.44,-0.5,-0.44,0.5,-0.2,-0.5,0.5,-0.2,-0.44,0.44,-0.2,-0.5],
    "morphTargets": [],
    "morphColors": [],
    "normals": [-0.25969,0.62694,-0.73451,-0.62694,0.25969,-0.73451,-0.91018,0.29289,0.29289,-0.29289,0.91018,0.29289,-0.62694,-0.73451,0.25969,-0.25969,-0.73451,0.62694,-0.29289,0.29289,0.91018,-0.91018,0.29289,0.29289,0.73451,0.25969,0.62694,0.73451,0.62694,0.25969,-0.29289,0.91018,0.29289,-0.29289,0.29289,0.91018,-0.29289,0.29289,0.91018,-0.29289,0.91018,0.29289,-0.91018,0.29289,0.29289,0.57735,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.40825,-0.40825,0.8165,0.40825,-0.40825,-0.8165,0.57735,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.40825,-0.40825,-0.8165,0.40825,-0.40825,0.8165,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.40825,-0.8165,-0.40825,0.40825,0.8165,-0.40825,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.40825,0.8165,-0.40825,0.40825,-0.8165,-0.40825,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.8165,-0.40825,-0.40825,-0.8165,-0.40825,-0.40825,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.8165,-0.40825,-0.40825,0.8165,-0.40825,-0.40825,0.57735,-0.57735,0.57735,0.40825,-0.40825,0.8165,-0.29289,0.29289,0.91018,-0.25969,-0.73451,0.62694,0.40825,-0.40825,0.8165,0.57735,-0.57735,0.57735,0.73451,0.25969,0.62694,-0.29289,0.29289,0.91018,-0.91018,0.29289,0.29289,-0.8165,-0.40825,-0.40825,-0.57735,-0.57735,-0.57735,-0.62694,-0.73451,0.25969,-0.57735,-0.57735,-0.57735,-0.8165,-0.40825,-0.40825,-0.91018,0.29289,0.29289,-0.62694,0.25969,-0.73451,0.40825,0.8165,-0.40825,0.57735,0.57735,-0.57735,-0.25969,0.62694,-0.73451,-0.29289,0.91018,0.29289,0.57735,0.57735,-0.57735,0.40825,0.8165,-0.40825,-0.29289,0.91018,0.29289,0.73451,0.62694,0.25969,0.57735,-0.57735,-0.57735,0.8165,-0.40825,-0.40825,0.57735,-0.57735,-0.57735,0.30151,-0.90453,-0.30151,0.8165,-0.40825,-0.40825,0.57735,-0.57735,-0.57735,0.30151,-0.30151,-0.90453,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.40825,-0.8165,-0.40825,0.57735,-0.57735,-0.57735,0.30151,-0.30151,-0.90453,0.57735,-0.57735,-0.57735,0.40825,-0.8165,-0.40825,0.57735,-0.57735,-0.57735,0.90453,-0.30151,-0.30151,0.40825,-0.40825,-0.8165,0.57735,-0.57735,-0.57735,0.30151,-0.90453,-0.30151,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.40825,-0.40825,-0.8165,0.57735,-0.57735,-0.57735,0.90453,-0.30151,-0.30151,0.57735,-0.57735,-0.57735,0.90453,-0.30151,-0.30151,0.73451,0.25969,0.62694,0.57735,-0.57735,0.57735,0.90453,-0.30151,-0.30151,0.73451,0.62694,0.25969,0.73451,0.25969,0.62694,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.73451,0.62694,0.25969,0.90453,-0.30151,-0.30151,-0.62694,0.25969,-0.73451,-0.25969,0.62694,-0.73451,0.30151,-0.30151,-0.90453,-0.62694,0.25969,-0.73451,0.30151,-0.30151,-0.90453,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.62694,-0.73451,0.25969,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.30151,-0.90453,-0.30151,-0.62694,-0.73451,0.25969,0.30151,-0.90453,-0.30151,-0.25969,-0.73451,0.62694,0.30151,-0.30151,-0.90453,-0.25969,0.62694,-0.73451,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.57735,-0.25969,-0.73451,0.62694,0.30151,-0.90453,-0.30151,0.57735,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.91018,0.29289,0.29289,0.62694,0.25969,-0.73451,0.25969,0.62694,-0.73451,0.29289,0.91018,0.29289,0.29289,0.29289,0.91018,0.25969,-0.73451,0.62694,0.62694,-0.73451,0.25969,0.91018,0.29289,0.29289,0.29289,0.91018,0.29289,-0.73451,0.62694,0.25969,-0.73451,0.25969,0.62694,0.29289,0.29289,0.91018,0.29289,0.91018,0.29289,0.29289,0.29289,0.91018,0.91018,0.29289,0.29289,-0.40825,-0.40825,0.8165,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.40825,-0.40825,-0.8165,-0.40825,-0.40825,-0.8165,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.40825,-0.40825,0.8165,-0.40825,-0.8165,-0.40825,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.40825,0.8165,-0.40825,-0.40825,0.8165,-0.40825,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.40825,-0.8165,-0.40825,-0.8165,-0.40825,-0.40825,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.8165,-0.40825,-0.40825,0.8165,-0.40825,-0.40825,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.8165,-0.40825,-0.40825,0.29289,0.29289,0.91018,-0.40825,-0.40825,0.8165,-0.57735,-0.57735,0.57735,0.25969,-0.73451,0.62694,-0.73451,0.25969,0.62694,-0.57735,-0.57735,0.57735,-0.40825,-0.40825,0.8165,0.29289,0.29289,0.91018,0.57735,-0.57735,-0.57735,0.8165,-0.40825,-0.40825,0.91018,0.29289,0.29289,0.62694,-0.73451,0.25969,0.91018,0.29289,0.29289,0.8165,-0.40825,-0.40825,0.57735,-0.57735,-0.57735,0.62694,0.25969,-0.73451,0.25969,0.62694,-0.73451,-0.57735,0.57735,-0.57735,-0.40825,0.8165,-0.40825,0.29289,0.91018,0.29289,0.29289,0.91018,0.29289,-0.40825,0.8165,-0.40825,-0.57735,0.57735,-0.57735,-0.73451,0.62694,0.25969,-0.57735,-0.57735,-0.57735,-0.8165,-0.40825,-0.40825,-0.57735,-0.57735,-0.57735,-0.30151,-0.90453,-0.30151,-0.30151,-0.30151,-0.90453,-0.57735,-0.57735,-0.57735,-0.8165,-0.40825,-0.40825,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.40825,-0.8165,-0.40825,-0.57735,-0.57735,-0.57735,-0.30151,-0.30151,-0.90453,-0.57735,-0.57735,-0.57735,-0.40825,-0.8165,-0.40825,-0.57735,-0.57735,-0.57735,-0.90453,-0.30151,-0.30151,-0.30151,-0.90453,-0.30151,-0.57735,-0.57735,-0.57735,-0.40825,-0.40825,-0.8165,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.40825,-0.40825,-0.8165,-0.57735,-0.57735,-0.57735,-0.90453,-0.30151,-0.30151,-0.73451,0.25969,0.62694,-0.90453,-0.30151,-0.30151,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.73451,0.62694,0.25969,-0.90453,-0.30151,-0.30151,-0.73451,0.25969,0.62694,-0.73451,0.62694,0.25969,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.90453,-0.30151,-0.30151,0.25969,0.62694,-0.73451,0.62694,0.25969,-0.73451,-0.30151,-0.30151,-0.90453,-0.57735,-0.57735,-0.57735,-0.30151,-0.30151,-0.90453,0.62694,0.25969,-0.73451,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.62694,-0.73451,0.25969,-0.30151,-0.90453,-0.30151,-0.30151,-0.90453,-0.30151,0.62694,-0.73451,0.25969,0.25969,-0.73451,0.62694,-0.57735,0.57735,-0.57735,0.25969,0.62694,-0.73451,-0.30151,-0.30151,-0.90453,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.30151,-0.90453,-0.30151,0.25969,-0.73451,0.62694,-0.57735,-0.57735,0.57735,-0.91018,-0.29289,0.29289,-0.62694,-0.25969,-0.73451,-0.25969,-0.62694,-0.73451,-0.29289,-0.91018,0.29289,-0.29289,-0.29289,0.91018,-0.25969,0.73451,0.62694,-0.62694,0.73451,0.25969,-0.91018,-0.29289,0.29289,-0.29289,-0.91018,0.29289,0.73451,-0.62694,0.25969,0.73451,-0.25969,0.62694,-0.29289,-0.29289,0.91018,-0.29289,-0.91018,0.29289,-0.29289,-0.29289,0.91018,-0.91018,-0.29289,0.29289,0.40825,0.40825,0.8165,0.57735,0.57735,0.57735,0.57735,0.57735,-0.57735,0.40825,0.40825,-0.8165,0.40825,0.40825,-0.8165,0.57735,0.57735,-0.57735,0.57735,0.57735,0.57735,0.40825,0.40825,0.8165,0.40825,0.8165,-0.40825,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.40825,-0.8165,-0.40825,0.40825,-0.8165,-0.40825,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.40825,0.8165,-0.40825,0.8165,0.40825,-0.40825,0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.8165,0.40825,-0.40825,-0.8165,0.40825,-0.40825,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.8165,0.40825,-0.40825,-0.29289,-0.29289,0.91018,0.40825,0.40825,0.8165,0.57735,0.57735,0.57735,-0.25969,0.73451,0.62694,0.73451,-0.25969,0.62694,0.57735,0.57735,0.57735,0.40825,0.40825,0.8165,-0.29289,-0.29289,0.91018,-0.57735,0.57735,-0.57735,-0.8165,0.40825,-0.40825,-0.91018,-0.29289,0.29289,-0.62694,0.73451,0.25969,-0.91018,-0.29289,0.29289,-0.8165,0.40825,-0.40825,-0.57735,0.57735,-0.57735,-0.62694,-0.25969,-0.73451,-0.25969,-0.62694,-0.73451,0.57735,-0.57735,-0.57735,0.40825,-0.8165,-0.40825,-0.29289,-0.91018,0.29289,-0.29289,-0.91018,0.29289,0.40825,-0.8165,-0.40825,0.57735,-0.57735,-0.57735,0.73451,-0.62694,0.25969,0.57735,0.57735,-0.57735,0.8165,0.40825,-0.40825,0.57735,0.57735,-0.57735,0.30151,0.90453,-0.30151,0.30151,0.30151,-0.90453,0.57735,0.57735,-0.57735,0.8165,0.40825,-0.40825,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.40825,0.8165,-0.40825,0.57735,0.57735,-0.57735,0.30151,0.30151,-0.90453,0.57735,0.57735,-0.57735,0.40825,0.8165,-0.40825,0.57735,0.57735,-0.57735,0.90453,0.30151,-0.30151,0.30151,0.90453,-0.30151,0.57735,0.57735,-0.57735,0.40825,0.40825,-0.8165,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.40825,0.40825,-0.8165,0.57735,0.57735,-0.57735,0.90453,0.30151,-0.30151,0.73451,-0.25969,0.62694,0.90453,0.30151,-0.30151,0.57735,0.57735,-0.57735,0.57735,0.57735,0.57735,0.73451,-0.62694,0.25969,0.90453,0.30151,-0.30151,0.73451,-0.25969,0.62694,0.73451,-0.62694,0.25969,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.90453,0.30151,-0.30151,-0.25969,-0.62694,-0.73451,-0.62694,-0.25969,-0.73451,0.30151,0.30151,-0.90453,0.57735,0.57735,-0.57735,0.30151,0.30151,-0.90453,-0.62694,-0.25969,-0.73451,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.62694,0.73451,0.25969,0.30151,0.90453,-0.30151,0.30151,0.90453,-0.30151,-0.62694,0.73451,0.25969,-0.25969,0.73451,0.62694,0.57735,-0.57735,-0.57735,-0.25969,-0.62694,-0.73451,0.30151,0.30151,-0.90453,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.30151,0.90453,-0.30151,-0.25969,0.73451,0.62694,0.57735,0.57735,0.57735,0.25969,-0.62694,-0.73451,0.62694,-0.25969,-0.73451,0.91018,-0.29289,0.29289,0.29289,-0.91018,0.29289,0.62694,0.73451,0.25969,0.25969,0.73451,0.62694,0.29289,-0.29289,0.91018,0.91018,-0.29289,0.29289,-0.73451,-0.25969,0.62694,-0.73451,-0.62694,0.25969,0.29289,-0.91018,0.29289,0.29289,-0.29289,0.91018,0.29289,-0.29289,0.91018,0.29289,-0.91018,0.29289,0.91018,-0.29289,0.29289,-0.57735,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.40825,0.40825,0.8165,-0.40825,0.40825,-0.8165,-0.57735,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.40825,0.40825,-0.8165,-0.40825,0.40825,0.8165,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.40825,0.8165,-0.40825,-0.40825,-0.8165,-0.40825,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.40825,-0.8165,-0.40825,-0.40825,0.8165,-0.40825,0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.8165,0.40825,-0.40825,0.8165,0.40825,-0.40825,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.8165,0.40825,-0.40825,-0.8165,0.40825,-0.40825,-0.57735,0.57735,0.57735,-0.40825,0.40825,0.8165,0.29289,-0.29289,0.91018,0.25969,0.73451,0.62694,-0.40825,0.40825,0.8165,-0.57735,0.57735,0.57735,-0.73451,-0.25969,0.62694,0.29289,-0.29289,0.91018,0.91018,-0.29289,0.29289,0.8165,0.40825,-0.40825,0.57735,0.57735,-0.57735,0.62694,0.73451,0.25969,0.57735,0.57735,-0.57735,0.8165,0.40825,-0.40825,0.91018,-0.29289,0.29289,0.62694,-0.25969,-0.73451,-0.40825,-0.8165,-0.40825,-0.57735,-0.57735,-0.57735,0.25969,-0.62694,-0.73451,0.29289,-0.91018,0.29289,-0.57735,-0.57735,-0.57735,-0.40825,-0.8165,-0.40825,0.29289,-0.91018,0.29289,-0.73451,-0.62694,0.25969,-0.57735,0.57735,-0.57735,-0.8165,0.40825,-0.40825,-0.57735,0.57735,-0.57735,-0.30151,0.90453,-0.30151,-0.8165,0.40825,-0.40825,-0.57735,0.57735,-0.57735,-0.30151,0.30151,-0.90453,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.40825,0.8165,-0.40825,-0.57735,0.57735,-0.57735,-0.30151,0.30151,-0.90453,-0.57735,0.57735,-0.57735,-0.40825,0.8165,-0.40825,-0.57735,0.57735,-0.57735,-0.90453,0.30151,-0.30151,-0.40825,0.40825,-0.8165,-0.57735,0.57735,-0.57735,-0.30151,0.90453,-0.30151,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.40825,0.40825,-0.8165,-0.57735,0.57735,-0.57735,-0.90453,0.30151,-0.30151,-0.57735,0.57735,-0.57735,-0.90453,0.30151,-0.30151,-0.73451,-0.25969,0.62694,-0.57735,0.57735,0.57735,-0.90453,0.30151,-0.30151,-0.73451,-0.62694,0.25969,-0.73451,-0.25969,0.62694,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.73451,-0.62694,0.25969,-0.90453,0.30151,-0.30151,0.62694,-0.25969,-0.73451,0.25969,-0.62694,-0.73451,-0.30151,0.30151,-0.90453,0.62694,-0.25969,-0.73451,-0.30151,0.30151,-0.90453,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.62694,0.73451,0.25969,0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.30151,0.90453,-0.30151,0.62694,0.73451,0.25969,-0.30151,0.90453,-0.30151,0.25969,0.73451,0.62694,-0.30151,0.30151,-0.90453,0.25969,-0.62694,-0.73451,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,0.25969,0.73451,0.62694,-0.30151,0.90453,-0.30151,-0.57735,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.91018,0.29289,-0.29289,-0.62694,0.25969,0.73451,-0.25969,0.62694,0.73451,-0.29289,0.91018,-0.29289,-0.29289,0.29289,-0.91018,-0.25969,-0.73451,-0.62694,-0.62694,-0.73451,-0.25969,-0.91018,0.29289,-0.29289,-0.29289,0.91018,-0.29289,0.73451,0.62694,-0.25969,0.73451,0.25969,-0.62694,-0.29289,0.29289,-0.91018,-0.29289,0.91018,-0.29289,-0.29289,0.29289,-0.91018,-0.91018,0.29289,-0.29289,0.40825,-0.40825,-0.8165,0.57735,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.40825,-0.40825,0.8165,0.40825,-0.40825,0.8165,0.57735,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.40825,-0.40825,-0.8165,0.40825,-0.8165,0.40825,0.57735,-0.57735,0.57735,0.57735,0.57735,0.57735,0.40825,0.8165,0.40825,0.40825,0.8165,0.40825,0.57735,0.57735,0.57735,0.57735,-0.57735,0.57735,0.40825,-0.8165,0.40825,0.8165,-0.40825,0.40825,0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.8165,-0.40825,0.40825,-0.8165,-0.40825,0.40825,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.8165,-0.40825,0.40825,-0.29289,0.29289,-0.91018,0.40825,-0.40825,-0.8165,0.57735,-0.57735,-0.57735,-0.25969,-0.73451,-0.62694,0.73451,0.25969,-0.62694,0.57735,-0.57735,-0.57735,0.40825,-0.40825,-0.8165,-0.29289,0.29289,-0.91018,-0.57735,-0.57735,0.57735,-0.8165,-0.40825,0.40825,-0.91018,0.29289,-0.29289,-0.62694,-0.73451,-0.25969,-0.91018,0.29289,-0.29289,-0.8165,-0.40825,0.40825,-0.57735,-0.57735,0.57735,-0.62694,0.25969,0.73451,-0.25969,0.62694,0.73451,0.57735,0.57735,0.57735,0.40825,0.8165,0.40825,-0.29289,0.91018,-0.29289,-0.29289,0.91018,-0.29289,0.40825,0.8165,0.40825,0.57735,0.57735,0.57735,0.73451,0.62694,-0.25969,0.57735,-0.57735,0.57735,0.8165,-0.40825,0.40825,0.57735,-0.57735,0.57735,0.30151,-0.90453,0.30151,0.30151,-0.30151,0.90453,0.57735,-0.57735,0.57735,0.8165,-0.40825,0.40825,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.40825,-0.8165,0.40825,0.57735,-0.57735,0.57735,0.30151,-0.30151,0.90453,0.57735,-0.57735,0.57735,0.40825,-0.8165,0.40825,0.57735,-0.57735,0.57735,0.90453,-0.30151,0.30151,0.30151,-0.90453,0.30151,0.57735,-0.57735,0.57735,0.40825,-0.40825,0.8165,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.40825,-0.40825,0.8165,0.57735,-0.57735,0.57735,0.90453,-0.30151,0.30151,0.73451,0.25969,-0.62694,0.90453,-0.30151,0.30151,0.57735,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.73451,0.62694,-0.25969,0.90453,-0.30151,0.30151,0.73451,0.25969,-0.62694,0.73451,0.62694,-0.25969,0.57735,0.57735,0.57735,0.57735,-0.57735,0.57735,0.90453,-0.30151,0.30151,-0.25969,0.62694,0.73451,-0.62694,0.25969,0.73451,0.30151,-0.30151,0.90453,0.57735,-0.57735,0.57735,0.30151,-0.30151,0.90453,-0.62694,0.25969,0.73451,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.62694,-0.73451,-0.25969,0.30151,-0.90453,0.30151,0.30151,-0.90453,0.30151,-0.62694,-0.73451,-0.25969,-0.25969,-0.73451,-0.62694,0.57735,0.57735,0.57735,-0.25969,0.62694,0.73451,0.30151,-0.30151,0.90453,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.30151,-0.90453,0.30151,-0.25969,-0.73451,-0.62694,0.57735,-0.57735,-0.57735,0.25969,0.62694,0.73451,0.62694,0.25969,0.73451,0.91018,0.29289,-0.29289,0.29289,0.91018,-0.29289,0.62694,-0.73451,-0.25969,0.25969,-0.73451,-0.62694,0.29289,0.29289,-0.91018,0.91018,0.29289,-0.29289,-0.73451,0.25969,-0.62694,-0.73451,0.62694,-0.25969,0.29289,0.91018,-0.29289,0.29289,0.29289,-0.91018,0.29289,0.29289,-0.91018,0.29289,0.91018,-0.29289,0.91018,0.29289,-0.29289,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.40825,-0.40825,-0.8165,-0.40825,-0.40825,0.8165,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.40825,-0.40825,0.8165,-0.40825,-0.40825,-0.8165,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.40825,-0.8165,0.40825,-0.40825,0.8165,0.40825,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.40825,0.8165,0.40825,-0.40825,-0.8165,0.40825,0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.8165,-0.40825,0.40825,0.8165,-0.40825,0.40825,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.8165,-0.40825,0.40825,-0.8165,-0.40825,0.40825,-0.57735,-0.57735,-0.57735,-0.40825,-0.40825,-0.8165,0.29289,0.29289,-0.91018,0.25969,-0.73451,-0.62694,-0.40825,-0.40825,-0.8165,-0.57735,-0.57735,-0.57735,-0.73451,0.25969,-0.62694,0.29289,0.29289,-0.91018,0.91018,0.29289,-0.29289,0.8165,-0.40825,0.40825,0.57735,-0.57735,0.57735,0.62694,-0.73451,-0.25969,0.57735,-0.57735,0.57735,0.8165,-0.40825,0.40825,0.91018,0.29289,-0.29289,0.62694,0.25969,0.73451,-0.40825,0.8165,0.40825,-0.57735,0.57735,0.57735,0.25969,0.62694,0.73451,0.29289,0.91018,-0.29289,-0.57735,0.57735,0.57735,-0.40825,0.8165,0.40825,0.29289,0.91018,-0.29289,-0.73451,0.62694,-0.25969,-0.57735,-0.57735,0.57735,-0.8165,-0.40825,0.40825,-0.57735,-0.57735,0.57735,-0.30151,-0.90453,0.30151,-0.8165,-0.40825,0.40825,-0.57735,-0.57735,0.57735,-0.30151,-0.30151,0.90453,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.40825,-0.8165,0.40825,-0.57735,-0.57735,0.57735,-0.30151,-0.30151,0.90453,-0.57735,-0.57735,0.57735,-0.40825,-0.8165,0.40825,-0.57735,-0.57735,0.57735,-0.90453,-0.30151,0.30151,-0.40825,-0.40825,0.8165,-0.57735,-0.57735,0.57735,-0.30151,-0.90453,0.30151,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.40825,-0.40825,0.8165,-0.57735,-0.57735,0.57735,-0.90453,-0.30151,0.30151,-0.57735,-0.57735,0.57735,-0.90453,-0.30151,0.30151,-0.73451,0.25969,-0.62694,-0.57735,-0.57735,-0.57735,-0.90453,-0.30151,0.30151,-0.73451,0.62694,-0.25969,-0.73451,0.25969,-0.62694,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.73451,0.62694,-0.25969,-0.90453,-0.30151,0.30151,0.62694,0.25969,0.73451,0.25969,0.62694,0.73451,-0.30151,-0.30151,0.90453,0.62694,0.25969,0.73451,-0.30151,-0.30151,0.90453,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.62694,-0.73451,-0.25969,0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.30151,-0.90453,0.30151,0.62694,-0.73451,-0.25969,-0.30151,-0.90453,0.30151,0.25969,-0.73451,-0.62694,-0.30151,-0.30151,0.90453,0.25969,0.62694,0.73451,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.57735,0.25969,-0.73451,-0.62694,-0.30151,-0.90453,0.30151,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.25969,-0.62694,0.73451,-0.62694,-0.25969,0.73451,-0.91018,-0.29289,-0.29289,-0.29289,-0.91018,-0.29289,-0.62694,0.73451,-0.25969,-0.25969,0.73451,-0.62694,-0.29289,-0.29289,-0.91018,-0.91018,-0.29289,-0.29289,0.73451,-0.25969,-0.62694,0.73451,-0.62694,-0.25969,-0.29289,-0.91018,-0.29289,-0.29289,-0.29289,-0.91018,-0.29289,-0.29289,-0.91018,-0.29289,-0.91018,-0.29289,-0.91018,-0.29289,-0.29289,0.57735,0.57735,0.57735,0.57735,0.57735,-0.57735,0.40825,0.40825,-0.8165,0.40825,0.40825,0.8165,0.57735,0.57735,-0.57735,0.57735,0.57735,0.57735,0.40825,0.40825,0.8165,0.40825,0.40825,-0.8165,0.57735,-0.57735,0.57735,0.57735,0.57735,0.57735,0.40825,0.8165,0.40825,0.40825,-0.8165,0.40825,0.57735,0.57735,0.57735,0.57735,-0.57735,0.57735,0.40825,-0.8165,0.40825,0.40825,0.8165,0.40825,-0.57735,0.57735,0.57735,0.57735,0.57735,0.57735,0.8165,0.40825,0.40825,-0.8165,0.40825,0.40825,0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.8165,0.40825,0.40825,0.8165,0.40825,0.40825,0.57735,0.57735,-0.57735,0.40825,0.40825,-0.8165,-0.29289,-0.29289,-0.91018,-0.25969,0.73451,-0.62694,0.40825,0.40825,-0.8165,0.57735,0.57735,-0.57735,0.73451,-0.25969,-0.62694,-0.29289,-0.29289,-0.91018,-0.91018,-0.29289,-0.29289,-0.8165,0.40825,0.40825,-0.57735,0.57735,0.57735,-0.62694,0.73451,-0.25969,-0.57735,0.57735,0.57735,-0.8165,0.40825,0.40825,-0.91018,-0.29289,-0.29289,-0.62694,-0.25969,0.73451,0.40825,-0.8165,0.40825,0.57735,-0.57735,0.57735,-0.25969,-0.62694,0.73451,-0.29289,-0.91018,-0.29289,0.57735,-0.57735,0.57735,0.40825,-0.8165,0.40825,-0.29289,-0.91018,-0.29289,0.73451,-0.62694,-0.25969,0.57735,0.57735,0.57735,0.8165,0.40825,0.40825,0.57735,0.57735,0.57735,0.30151,0.90453,0.30151,0.8165,0.40825,0.40825,0.57735,0.57735,0.57735,0.30151,0.30151,0.90453,0.57735,0.57735,0.57735,0.57735,0.57735,0.57735,0.40825,0.8165,0.40825,0.57735,0.57735,0.57735,0.30151,0.30151,0.90453,0.57735,0.57735,0.57735,0.40825,0.8165,0.40825,0.57735,0.57735,0.57735,0.90453,0.30151,0.30151,0.40825,0.40825,0.8165,0.57735,0.57735,0.57735,0.30151,0.90453,0.30151,0.57735,0.57735,0.57735,0.57735,0.57735,0.57735,0.40825,0.40825,0.8165,0.57735,0.57735,0.57735,0.90453,0.30151,0.30151,0.57735,0.57735,0.57735,0.90453,0.30151,0.30151,0.73451,-0.25969,-0.62694,0.57735,0.57735,-0.57735,0.90453,0.30151,0.30151,0.73451,-0.62694,-0.25969,0.73451,-0.25969,-0.62694,0.57735,0.57735,0.57735,0.57735,-0.57735,0.57735,0.73451,-0.62694,-0.25969,0.90453,0.30151,0.30151,-0.62694,-0.25969,0.73451,-0.25969,-0.62694,0.73451,0.30151,0.30151,0.90453,-0.62694,-0.25969,0.73451,0.30151,0.30151,0.90453,0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.62694,0.73451,-0.25969,-0.57735,0.57735,0.57735,0.57735,0.57735,0.57735,0.30151,0.90453,0.30151,-0.62694,0.73451,-0.25969,0.30151,0.90453,0.30151,-0.25969,0.73451,-0.62694,0.30151,0.30151,0.90453,-0.25969,-0.62694,0.73451,0.57735,-0.57735,0.57735,0.57735,0.57735,0.57735,-0.25969,0.73451,-0.62694,0.30151,0.90453,0.30151,0.57735,0.57735,0.57735,0.57735,0.57735,-0.57735,0.91018,-0.29289,-0.29289,0.62694,-0.25969,0.73451,0.25969,-0.62694,0.73451,0.29289,-0.91018,-0.29289,0.29289,-0.29289,-0.91018,0.25969,0.73451,-0.62694,0.62694,0.73451,-0.25969,0.91018,-0.29289,-0.29289,0.29289,-0.91018,-0.29289,-0.73451,-0.62694,-0.25969,-0.73451,-0.25969,-0.62694,0.29289,-0.29289,-0.91018,0.29289,-0.91018,-0.29289,0.29289,-0.29289,-0.91018,0.91018,-0.29289,-0.29289,-0.40825,0.40825,-0.8165,-0.57735,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.40825,0.40825,0.8165,-0.40825,0.40825,0.8165,-0.57735,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.40825,0.40825,-0.8165,-0.40825,0.8165,0.40825,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.40825,-0.8165,0.40825,-0.40825,-0.8165,0.40825,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.40825,0.8165,0.40825,-0.8165,0.40825,0.40825,-0.57735,0.57735,0.57735,0.57735,0.57735,0.57735,0.8165,0.40825,0.40825,0.8165,0.40825,0.40825,0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.8165,0.40825,0.40825,0.29289,-0.29289,-0.91018,-0.40825,0.40825,-0.8165,-0.57735,0.57735,-0.57735,0.25969,0.73451,-0.62694,-0.73451,-0.25969,-0.62694,-0.57735,0.57735,-0.57735,-0.40825,0.40825,-0.8165,0.29289,-0.29289,-0.91018,0.57735,0.57735,0.57735,0.8165,0.40825,0.40825,0.91018,-0.29289,-0.29289,0.62694,0.73451,-0.25969,0.91018,-0.29289,-0.29289,0.8165,0.40825,0.40825,0.57735,0.57735,0.57735,0.62694,-0.25969,0.73451,0.25969,-0.62694,0.73451,-0.57735,-0.57735,0.57735,-0.40825,-0.8165,0.40825,0.29289,-0.91018,-0.29289,0.29289,-0.91018,-0.29289,-0.40825,-0.8165,0.40825,-0.57735,-0.57735,0.57735,-0.73451,-0.62694,-0.25969,-0.57735,0.57735,0.57735,-0.8165,0.40825,0.40825,-0.57735,0.57735,0.57735,-0.30151,0.90453,0.30151,-0.30151,0.30151,0.90453,-0.57735,0.57735,0.57735,-0.8165,0.40825,0.40825,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.40825,0.8165,0.40825,-0.57735,0.57735,0.57735,-0.30151,0.30151,0.90453,-0.57735,0.57735,0.57735,-0.40825,0.8165,0.40825,-0.57735,0.57735,0.57735,-0.90453,0.30151,0.30151,-0.30151,0.90453,0.30151,-0.57735,0.57735,0.57735,-0.40825,0.40825,0.8165,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.40825,0.40825,0.8165,-0.57735,0.57735,0.57735,-0.90453,0.30151,0.30151,-0.73451,-0.25969,-0.62694,-0.90453,0.30151,0.30151,-0.57735,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.73451,-0.62694,-0.25969,-0.90453,0.30151,0.30151,-0.73451,-0.25969,-0.62694,-0.73451,-0.62694,-0.25969,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.90453,0.30151,0.30151,0.25969,-0.62694,0.73451,0.62694,-0.25969,0.73451,-0.30151,0.30151,0.90453,-0.57735,0.57735,0.57735,-0.30151,0.30151,0.90453,0.62694,-0.25969,0.73451,0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,0.57735,0.57735,0.57735,0.62694,0.73451,-0.25969,-0.30151,0.90453,0.30151,-0.30151,0.90453,0.30151,0.62694,0.73451,-0.25969,0.25969,0.73451,-0.62694,-0.57735,-0.57735,0.57735,0.25969,-0.62694,0.73451,-0.30151,0.30151,0.90453,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.30151,0.90453,0.30151,0.25969,0.73451,-0.62694,-0.57735,0.57735,-0.57735],
    "colors": [],
    "uvs": [[]],
    "faces": [35,9,8,4,5,0,0,1,2,3,35,1,13,6,4,0,4,5,6,7,35,17,16,5,6,0,8,9,10,11,34,6,5,4,0,12,13,14,35,22,18,12,26,0,15,16,17,18,35,14,30,26,12,0,19,20,21,22,35,15,23,27,11,0,23,24,25,26,35,21,10,11,27,0,27,28,29,30,35,7,19,25,3,0,31,32,33,34,35,29,2,3,25,0,35,36,37,38,35,14,12,6,13,0,39,40,41,42,35,12,18,17,6,0,43,44,45,46,35,4,3,2,1,0,47,48,49,50,35,7,3,4,8,0,51,52,53,54,35,11,10,9,5,0,55,56,57,58,35,15,11,5,16,0,59,60,61,62,35,29,25,0,28,0,63,64,65,66,35,25,19,20,0,0,67,68,69,70,35,21,27,0,20,0,71,72,73,74,35,0,27,23,24,0,75,76,77,78,35,26,30,28,0,0,79,80,81,82,35,22,26,0,24,0,83,84,85,86,35,22,24,17,18,0,87,88,89,90,34,24,16,17,0,91,92,93,35,23,15,16,24,0,94,95,96,97,34,8,9,20,0,98,99,100,35,8,20,19,7,0,101,102,103,104,35,1,2,29,28,0,105,106,107,108,34,1,28,13,0,109,110,111,35,20,9,10,21,0,112,113,114,115,35,13,28,30,14,0,116,117,118,119,35,35,39,40,36,0,120,121,122,123,35,37,44,32,35,0,124,125,126,127,35,36,47,48,37,0,128,129,130,131,34,36,37,35,0,132,133,134,35,43,49,53,57,0,135,136,137,138,35,57,61,45,43,0,139,140,141,142,35,58,54,46,42,0,143,144,145,146,35,42,41,52,58,0,147,148,149,150,35,56,50,38,34,0,151,152,153,154,35,34,33,60,56,0,155,156,157,158,35,37,43,45,44,0,159,160,161,162,35,48,49,43,37,0,163,164,165,166,35,33,34,35,32,0,167,168,169,170,35,35,34,38,39,0,171,172,173,174,35,40,41,42,36,0,175,176,177,178,35,36,42,46,47,0,179,180,181,182,35,31,56,60,59,0,183,184,185,186,35,51,50,56,31,0,187,188,189,190,35,31,58,52,51,0,191,192,193,194,35,54,58,31,55,0,195,196,197,198,35,59,61,57,31,0,199,200,201,202,35,31,57,53,55,0,203,204,205,206,35,48,55,53,49,0,207,208,209,210,34,47,55,48,0,211,212,213,35,47,46,54,55,0,214,215,216,217,34,40,39,51,0,218,219,220,35,50,51,39,38,0,221,222,223,224,35,60,33,32,59,0,225,226,227,228,34,59,32,44,0,229,230,231,35,41,40,51,52,0,232,233,234,235,35,61,59,44,45,0,236,237,238,239,35,66,70,71,67,0,240,241,242,243,35,68,75,63,66,0,244,245,246,247,35,67,78,79,68,0,248,249,250,251,34,67,68,66,0,252,253,254,35,74,80,84,88,0,255,256,257,258,35,88,92,76,74,0,259,260,261,262,35,89,85,77,73,0,263,264,265,266,35,73,72,83,89,0,267,268,269,270,35,87,81,69,65,0,271,272,273,274,35,65,64,91,87,0,275,276,277,278,35,68,74,76,75,0,279,280,281,282,35,79,80,74,68,0,283,284,285,286,35,64,65,66,63,0,287,288,289,290,35,66,65,69,70,0,291,292,293,294,35,71,72,73,67,0,295,296,297,298,35,67,73,77,78,0,299,300,301,302,35,62,87,91,90,0,303,304,305,306,35,82,81,87,62,0,307,308,309,310,35,62,89,83,82,0,311,312,313,314,35,85,89,62,86,0,315,316,317,318,35,90,92,88,62,0,319,320,321,322,35,62,88,84,86,0,323,324,325,326,35,79,86,84,80,0,327,328,329,330,34,78,86,79,0,331,332,333,35,78,77,85,86,0,334,335,336,337,34,71,70,82,0,338,339,340,35,81,82,70,69,0,341,342,343,344,35,91,64,63,90,0,345,346,347,348,34,90,63,75,0,349,350,351,35,72,71,82,83,0,352,353,354,355,35,92,90,75,76,0,356,357,358,359,35,102,101,97,98,0,360,361,362,363,35,94,106,99,97,0,364,365,366,367,35,110,109,98,99,0,368,369,370,371,34,99,98,97,0,372,373,374,35,115,111,105,119,0,375,376,377,378,35,107,123,119,105,0,379,380,381,382,35,108,116,120,104,0,383,384,385,386,35,114,103,104,120,0,387,388,389,390,35,100,112,118,96,0,391,392,393,394,35,122,95,96,118,0,395,396,397,398,35,107,105,99,106,0,399,400,401,402,35,105,111,110,99,0,403,404,405,406,35,97,96,95,94,0,407,408,409,410,35,100,96,97,101,0,411,412,413,414,35,104,103,102,98,0,415,416,417,418,35,108,104,98,109,0,419,420,421,422,35,122,118,93,121,0,423,424,425,426,35,118,112,113,93,0,427,428,429,430,35,114,120,93,113,0,431,432,433,434,35,93,120,116,117,0,435,436,437,438,35,119,123,121,93,0,439,440,441,442,35,115,119,93,117,0,443,444,445,446,35,115,117,110,111,0,447,448,449,450,34,117,109,110,0,451,452,453,35,116,108,109,117,0,454,455,456,457,34,101,102,113,0,458,459,460,35,101,113,112,100,0,461,462,463,464,35,94,95,122,121,0,465,466,467,468,34,94,121,106,0,469,470,471,35,113,102,103,114,0,472,473,474,475,35,106,121,123,107,0,476,477,478,479,35,128,132,133,129,0,480,481,482,483,35,130,137,125,128,0,484,485,486,487,35,129,140,141,130,0,488,489,490,491,34,129,130,128,0,492,493,494,35,136,142,146,150,0,495,496,497,498,35,150,154,138,136,0,499,500,501,502,35,151,147,139,135,0,503,504,505,506,35,135,134,145,151,0,507,508,509,510,35,149,143,131,127,0,511,512,513,514,35,127,126,153,149,0,515,516,517,518,35,130,136,138,137,0,519,520,521,522,35,141,142,136,130,0,523,524,525,526,35,126,127,128,125,0,527,528,529,530,35,128,127,131,132,0,531,532,533,534,35,133,134,135,129,0,535,536,537,538,35,129,135,139,140,0,539,540,541,542,35,124,149,153,152,0,543,544,545,546,35,144,143,149,124,0,547,548,549,550,35,124,151,145,144,0,551,552,553,554,35,147,151,124,148,0,555,556,557,558,35,152,154,150,124,0,559,560,561,562,35,124,150,146,148,0,563,564,565,566,35,141,148,146,142,0,567,568,569,570,34,140,148,141,0,571,572,573,35,140,139,147,148,0,574,575,576,577,34,133,132,144,0,578,579,580,35,143,144,132,131,0,581,582,583,584,35,153,126,125,152,0,585,586,587,588,34,152,125,137,0,589,590,591,35,134,133,144,145,0,592,593,594,595,35,154,152,137,138,0,596,597,598,599,35,164,163,159,160,0,600,601,602,603,35,156,168,161,159,0,604,605,606,607,35,172,171,160,161,0,608,609,610,611,34,161,160,159,0,612,613,614,35,177,173,167,181,0,615,616,617,618,35,169,185,181,167,0,619,620,621,622,35,170,178,182,166,0,623,624,625,626,35,176,165,166,182,0,627,628,629,630,35,162,174,180,158,0,631,632,633,634,35,184,157,158,180,0,635,636,637,638,35,169,167,161,168,0,639,640,641,642,35,167,173,172,161,0,643,644,645,646,35,159,158,157,156,0,647,648,649,650,35,162,158,159,163,0,651,652,653,654,35,166,165,164,160,0,655,656,657,658,35,170,166,160,171,0,659,660,661,662,35,184,180,155,183,0,663,664,665,666,35,180,174,175,155,0,667,668,669,670,35,176,182,155,175,0,671,672,673,674,35,155,182,178,179,0,675,676,677,678,35,181,185,183,155,0,679,680,681,682,35,177,181,155,179,0,683,684,685,686,35,177,179,172,173,0,687,688,689,690,34,179,171,172,0,691,692,693,35,178,170,171,179,0,694,695,696,697,34,163,164,175,0,698,699,700,35,163,175,174,162,0,701,702,703,704,35,156,157,184,183,0,705,706,707,708,34,156,183,168,0,709,710,711,35,175,164,165,176,0,712,713,714,715,35,168,183,185,169,0,716,717,718,719,35,195,194,190,191,0,720,721,722,723,35,187,199,192,190,0,724,725,726,727,35,203,202,191,192,0,728,729,730,731,34,192,191,190,0,732,733,734,35,208,204,198,212,0,735,736,737,738,35,200,216,212,198,0,739,740,741,742,35,201,209,213,197,0,743,744,745,746,35,207,196,197,213,0,747,748,749,750,35,193,205,211,189,0,751,752,753,754,35,215,188,189,211,0,755,756,757,758,35,200,198,192,199,0,759,760,761,762,35,198,204,203,192,0,763,764,765,766,35,190,189,188,187,0,767,768,769,770,35,193,189,190,194,0,771,772,773,774,35,197,196,195,191,0,775,776,777,778,35,201,197,191,202,0,779,780,781,782,35,215,211,186,214,0,783,784,785,786,35,211,205,206,186,0,787,788,789,790,35,207,213,186,206,0,791,792,793,794,35,186,213,209,210,0,795,796,797,798,35,212,216,214,186,0,799,800,801,802,35,208,212,186,210,0,803,804,805,806,35,208,210,203,204,0,807,808,809,810,34,210,202,203,0,811,812,813,35,209,201,202,210,0,814,815,816,817,34,194,195,206,0,818,819,820,35,194,206,205,193,0,821,822,823,824,35,187,188,215,214,0,825,826,827,828,34,187,214,199,0,829,830,831,35,206,195,196,207,0,832,833,834,835,35,199,214,216,200,0,836,837,838,839,35,221,225,226,222,0,840,841,842,843,35,223,230,218,221,0,844,845,846,847,35,222,233,234,223,0,848,849,850,851,34,222,223,221,0,852,853,854,35,229,235,239,243,0,855,856,857,858,35,243,247,231,229,0,859,860,861,862,35,244,240,232,228,0,863,864,865,866,35,228,227,238,244,0,867,868,869,870,35,242,236,224,220,0,871,872,873,874,35,220,219,246,242,0,875,876,877,878,35,223,229,231,230,0,879,880,881,882,35,234,235,229,223,0,883,884,885,886,35,219,220,221,218,0,887,888,889,890,35,221,220,224,225,0,891,892,893,894,35,226,227,228,222,0,895,896,897,898,35,222,228,232,233,0,899,900,901,902,35,217,242,246,245,0,903,904,905,906,35,237,236,242,217,0,907,908,909,910,35,217,244,238,237,0,911,912,913,914,35,240,244,217,241,0,915,916,917,918,35,245,247,243,217,0,919,920,921,922,35,217,243,239,241,0,923,924,925,926,35,234,241,239,235,0,927,928,929,930,34,233,241,234,0,931,932,933,35,233,232,240,241,0,934,935,936,937,34,226,225,237,0,938,939,940,35,236,237,225,224,0,941,942,943,944,35,246,219,218,245,0,945,946,947,948,34,245,218,230,0,949,950,951,35,227,226,237,238,0,952,953,954,955,35,247,245,230,231,0,956,957,958,959]
   } );
   return object.geometry;
}
SCMAP.SelectedSystemGeometry = SCMAP.SelectedSystemGeometry || _build_selected_system_object();

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.JumpPoint = function ( data ) {
   this.name = ( typeof data.name === 'string' && data.name.length > 1 ) ? data.name : undefined;
   this.source = ( data.source instanceof SCMAP.System ) ? data.source : undefined;
   this.destination = ( data.destination instanceof SCMAP.System ) ? data.destination : undefined;
   this.drawn = false;
   this.typeId = ( typeof data.typeId === 'number' ) ? data.typeId : 4;
   this.entryAU = new THREE.Vector3(
      (typeof data.entryAU[ 0 ] === 'number') ? data.entryAU[ 0 ] : 0,
      (typeof data.entryAU[ 1 ] === 'number') ? data.entryAU[ 1 ] : 0,
      (typeof data.entryAU[ 2 ] === 'number') ? data.entryAU[ 2 ] : 0
   );

   if ( !this.isValid() ) {
      console.error( "Invalid route created" );
   } else {
      if ( this.name === undefined || this.name === '' ) {
         this.name = "[" + this.source.name + " to " + this.destination.name + "]";
      }
   }
};

SCMAP.JumpPoint.prototype = {
   constructor: SCMAP.JumpPoint,

   length: function() {
      if ( !this.isValid() ) { return; }
      return this.source.position.distanceTo( this.destination.position );
   },

   jumpTime: function() {
      if ( !this.isValid() ) { return; }
      // TODO FIXME: This is a rough guesstimate on how long it will take
      // to travel a JP, and not based in any facts ... no word from devs
      // on this so far.
      return this.length() * 4; // 2 mins for 30LY, ~Sol to Vega (27LY)
   },

   fuelConsumption: function() {
      if ( !this.isValid() ) { return; }
      // TODO: Devs have stated that JP's don't consume fuel to traverse.
      // If that changes, this needs to be quantified and fixed.
      return 0;
   },

   buildSceneObject: function() {
      var oppositeJumppoint, geometry;

      if ( this.drawn ) {
         return;
      }

      // Check if the opposite jumppoint has already been drawn
      oppositeJumppoint = this.getOppositeJumppoint();
      if ( oppositeJumppoint instanceof SCMAP.JumpPoint && oppositeJumppoint.drawn ) {
         return;
      }

      geometry = new THREE.Geometry();
      geometry.colors.push( this.source.faction.lineColor );
      geometry.vertices.push( this.source.sceneObject.position );
      geometry.colors.push( this.destination.faction.lineColor );
      geometry.vertices.push( this.destination.sceneObject.position );

      // Set both the jumppoints as drawn
      this.setDrawn();
      if ( oppositeJumppoint instanceof SCMAP.JumpPoint ) {
         oppositeJumppoint.setDrawn();
      }

      // This is apparently needed for dashed lines
      geometry.computeLineDistances();
      return new THREE.Line( geometry, this.getMaterial(), THREE.LinePieces );
   },

   getOppositeJumppoint: function() {
      for ( var i = 0; i < this.destination.jumpPoints.length; i++ ) {
         var jumppoint = this.destination.jumpPoints[i];
         if ( jumppoint.destination == this.source ) {
            return jumppoint;
         }
      }
   },

   getMaterial: function() {
      if ( this.typeId === 2 ) {
         return SCMAP.JumpPoint.Material.Undiscovered;
      } else if ( this.typeId === 4 ) {
         return SCMAP.JumpPoint.Material.Possible;
      } else {
         return SCMAP.JumpPoint.Material.Regular;
      }
   },

   isValid: function() {
      return( this.source instanceof SCMAP.System &&
         this.destination instanceof SCMAP.System &&
         this.source !== this.destination );
   },

   isUnconfirmed: function() {
      return ( this.typeId === 2 || this.typeId === 4 );
   },

   setDrawn: function() {
      this.drawn = true;
   }
};

SCMAP.JumpPoint.Material = {};
SCMAP.JumpPoint.Material.Regular = new THREE.LineBasicMaterial({
   color: 0xFFFFFF,
   linewidth: 2,
   vertexColors: true
});
SCMAP.JumpPoint.Material.Undiscovered = new THREE.LineDashedMaterial({
   color: 0xFFFFFF,
   dashSize: 0.75,
   gapSize: 0.75,
   linewidth: 2,
   vertexColors: true
});
SCMAP.JumpPoint.Material.Possible = new THREE.LineDashedMaterial({
   color: 0xFFFFFF,
   dashSize: 2,
   gapSize: 2,
   linewidth: 2,
   vertexColors: true
});

// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.Faction = function ( data ) {

   this.id = undefined;
   this.name = 'Unclaimed';
   this.shortName = 'NONE';
   this.isRealFaction = false;
   this.color = new THREE.Color( 0xFFFFFF );
   this.planeColor = new THREE.Color( 0xFF0000 );
   this.lineColor = new THREE.Color( 0xFFFF00 );

   this.setValues( data );

   // Internals
   this._claimed = {
      systems: {}
   };
   this._darkMaterial = undefined;

};

SCMAP.Faction.prototype = {
   constructor: SCMAP.Faction,

   claim: function ( system ) {
      if ( ! system instanceof SCMAP.System ) {
         new Error( "A faction can only claim ownership over a system" );
         return;
      }
      this._claimed.systems[ system.uuid ] = true;
      return this;
   },

   claimed: function ( system ) {
      if ( ! system instanceof SCMAP.System ) {
         new Error( "A faction can only test ownership over a system" );
         return;
      }
      return this._claimed.systems[ system.uuid ];
   },

   material: function ( ) {
      if ( typeof this._darkMaterial === 'undefined' ) {
         this._darkMaterial = new THREE.MeshBasicMaterial({
            color: this.planeColor, vertexColors: true });
      }
      return this._darkMaterial;
   },

   isHostileTo: function ( comparedTo ) {
      if ( !( comparedTo instanceof SCMAP.Faction ) ) {
         throw "Can only compare to other factions";
      }
      // TODO: more data in database, more logic here
      // rather than lots of hardcoding
      if ( comparedTo.name === 'Vanduul' ) {
         return ( this.name !== 'Vanduul' );
      } else {
         return ( this.name === 'Vanduul' );
      }
   },

   getValue: function ( key ) {
      if ( key === undefined ) {
         return;
      }
      var value = this[ key ];
      return value;
   },

   setValues: function ( values ) {
      if ( values === undefined ) {
         return;
      }

      for ( var key in values ) {

         var newValue = values[ key ];
         if ( newValue === undefined ) {
            console.log( 'SCMAP.Faction: "' + key + '" parameter is undefined for "'+this.name+'"' );
            continue;
         }

         if ( key in this )
         {
            var currentValue = this[ key ];
            if ( currentValue instanceof THREE.Color ) {

               if ( newValue instanceof THREE.Color ) {
                  this[ key ] = newValue;
               } else {
                  newValue = newValue.replace( '0x', '#' );
                  this[ key ] = new THREE.Color( newValue );
               }
               if ( key === 'color' ) {
                  this.planeColor = this[ key ].clone().offsetHSL( 0, 0.5, 0 ).multiplyScalar( 0.20 );
                  this.lineColor = this[ key ].clone().offsetHSL( 0, 0.05, -0.05 );
               }

            } else {
               this[ key ] = newValue;
            }
         }

      }
   }
};

SCMAP.Faction.preprocessFactions = function () {
   var factionId, faction;

   SCMAP.data.factionsByName = {};

   for ( factionId in SCMAP.data.factions ) {

      faction = SCMAP.data.factions[ factionId ];
      if ( faction instanceof SCMAP.Faction ) {
         SCMAP.data.factionsByName[ faction.name ]      = faction;
         SCMAP.data.factionsByName[ faction.shortName ] = faction;
         continue;
      }

      faction = new SCMAP.Faction({
         id: factionId,
         name: faction.name,
         shortName: faction.short_name,
         color: faction.color,
         isRealFaction: faction.is_real_faction
      });

      SCMAP.data.factions[ factionId ]               = faction;
      SCMAP.data.factionsByName[ faction.name ]      = faction;
      SCMAP.data.factionsByName[ faction.shortName ] = faction;
   }
};

SCMAP.Faction.getById = function ( id ) {
   var faction = SCMAP.data.factions[ id ];
   if ( ! ( faction instanceof SCMAP.Faction ) ) {
      faction = SCMAP.data.factionsByName.Unclaimed;
   }
   return faction;
};
SCMAP.Faction.getByName = function ( name ) {
   var faction = SCMAP.data.factionsByName[ name ];
   if ( ! ( faction instanceof SCMAP.Faction ) ) {
      faction = SCMAP.data.factionsByName.Unclaimed;
   }
   return faction;
};

// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.Goods = function ( data ) {

   this.id = undefined;
   this.name = 'Unknown';
   this.isBlackMarket = false;

   this.setValues( data );

   // Internals
   this._trade = {
      importing: [],
      exporting: [],
      blackMarket: []
   };

};

SCMAP.Goods.prototype = {
   constructor: SCMAP.Goods,

//   claim: function ( system ) {
//      if ( ! system instanceof SCMAP.System ) {
//         new Error( "A faction can only claim ownership over a system" );
//         return;
//      }
//      this._claimed.systems[ system.uuid ] = true;
//   },
//
//   claimed: function ( system ) {
//      if ( ! system instanceof SCMAP.System ) {
//         new Error( "A faction can only test ownership over a system" );
//         return;
//      }
//      return this._claimed.systems[ system.uuid ];
//   },
//
//   material: function ( ) {
//      if ( typeof this._darkMaterial === 'undefined' ) {
//         this._darkMaterial = new THREE.MeshBasicMaterial({ color: this.dark, vertexColors: false });
//      }
//      return this._darkMaterial;
//   },

   getValue: function ( key ) {
      if ( key === undefined ) {
         return;
      }
      var value = this[ key ];
      return value;
   },

   setValues: function ( values ) {
      if ( values === undefined ) {
         return;
      }

      for ( var key in values ) {

         var newValue = values[ key ];
         if ( newValue === undefined ) {
            console.log( 'SCMAP.Goods: "' + key + '" parameter is undefined for "'+this.name+'"' );
            continue;
         }

         if ( key in this )
         {
            var currentValue = this[ key ];
            this[ key ] = newValue;
         }

      }
   }
};

SCMAP.Goods.preprocessGoods = function () {
   var goodsId, goods;

   SCMAP.data.goodsByName = {};

   for ( goodsId in SCMAP.data.goods ) {

      goods = SCMAP.data.goods[ goodsId ];
      if ( goods instanceof SCMAP.Goods ) {
         SCMAP.data.goodsByName[ goods.name ] = goods;
         continue;
      }

      goods = new SCMAP.Goods({
         id: goodsId,
         name: goods.name,
         isBlackMarket: goods.black_market
      });

      SCMAP.data.goods[ goodsId ] = goods;
      SCMAP.data.goodsByName[ goods.name ] = goods;
   }
};

SCMAP.Goods.getById = function ( id ) {
   return SCMAP.data.goods[ id ];
};
SCMAP.Goods.getByName = function ( name ) {
   return SCMAP.data.goodsByName[ name ];
};

// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.System = function ( data ) {
   // Filled in from the config
   this.id = undefined;
   this.uuid = undefined;
   this.name = '';
   this.nickname = '';
   this.position = new THREE.Vector3();
   this.faction = new SCMAP.Faction();
   this.size = 'medium';
   this.jumpPoints = [];
   this.starColor = new THREE.Color( 0xFFFFFF );
   this.source = undefined;
   this.planets = 0;
   this.planetaryRotation = [];
   this.import = [];
   this.export = [];
   this.crimeStatus = '';
   this.blackMarket = [];
   this.ueeStrategicValue = undefined;
   this.blob = [];
   this.scale = 1.0;
   this.binary = false;

   this.setValues( data );

   // Generated, internal
   this._routeObjects = [];
   this._drawnText = '';
   this._drawnSymbols = '';
};

SCMAP.System.prototype = {
   constructor: SCMAP.System,

   buildSceneObject: function () {
      var star, label, glow, position, lod, boxSize;

      this.sceneObject = new THREE.Object3D();

      // To make systems easier to click, we add an invisible cube to them
      // (probably also easier for the raycaster)
      star = new THREE.Mesh( SCMAP.System.CUBE, SCMAP.System.CUBE_MATERIAL );
      star.visible = false;
      boxSize = Math.min( 5.75, Math.max( 3.5, 5 * this.scale ) );
      star.scale.set( boxSize, boxSize, boxSize );
      this.sceneObject.add( star );

      // LOD for the systems to make them properly round up close
      lod = new THREE.LOD();
      for ( i = 0; i < SCMAP.System.LODMESH.length; i++ ) {
         star = new THREE.Mesh( SCMAP.System.LODMESH[ i ][ 0 ], this.starMaterial() );
         star.scale.set( this.scale, this.scale, this.scale );
         star.updateMatrix();
         star.matrixAutoUpdate = false;
         lod.addLevel( star, SCMAP.System.LODMESH[ i ][ 1 ] );
      }
      lod.updateMatrix();
      lod.matrixAutoUpdate = false;
      this.sceneObject.add( lod );

//if ( this.name === 'Nul' ) {
      //var customMaterial = this.glowShaderMaterial( this.starColor );
      //var moonGlow = new THREE.Mesh( SCMAP.System.LODMESH[ 1 ][ 0 ].clone(), customMaterial );
      //moonGlow.scale.multiplyScalar( 2.3 * this.scale );
      //moonGlow.userData.isGlow = true;
      //this.sceneObject.add( moonGlow );
//}

      glow = new THREE.Sprite( this.glowMaterial() );
      glow.scale.set( SCMAP.System.GLOW_SCALE * this.scale, SCMAP.System.GLOW_SCALE * this.scale, 1.0 );
      glow.userData.isGlow = true;
      glow.sortParticles = true;
      glow.visible = SCMAP.settings.glow;
      this.sceneObject.add( glow );

      label = new THREE.Sprite( this.labelSprite( SCMAP.settings.labelIcons ) );
      label.position.set( 0, 3.5, 0 );
      label.position.set( 0, this.scale * 3, 0 );
      label.scale.set( SCMAP.System.LABEL_SCALE * label.material.map.image.width, SCMAP.System.LABEL_SCALE * label.material.map.image.height, 1 );
      label.userData.isLabel = true;
      label.sortParticles = true;
      label.visible = SCMAP.settings.labels;
      this.sceneObject.add( label );

      position = this.position.clone();
      if ( storage && storage.mode === '2d' ) {
         position.setY( position.y * 0.005 );
      }
      this.sceneObject.position = position;
      this.sceneObject.userData.system = this;
      this.sceneObject.userData.scaleY = this.scaleY;
      return this.sceneObject;
   },

   updateSceneObject: function ( scene ) {
      for ( var i = 0; i < this.sceneObject.children.length; i++ ) {
         var object = this.sceneObject.children[i];
         if ( object.userData.isLabel ) {
            this.updateLabelSprite( object.material, SCMAP.settings.labelIcons );
            object.visible = SCMAP.settings.labels;
         } else if ( object.userData.isGlow ) {
            object.visible = SCMAP.settings.glow;
         }
      }
   },

   setLabelScale: function ( vector ) {
      for ( var i = 0; i < this.sceneObject.children.length; i++ ) {
         if ( this.sceneObject.children[i].userData.isLabel ) {
            this.sceneObject.children[i].scale.copy( vector );
         }
      }
   },

   starMaterial: function () {
      return SCMAP.System.STAR_MATERIAL_WHITE;
   },

   glowShaderMaterial: function ( color ) {
      var material = SCMAP.System.GLOW_SHADER_MATERIAL.clone();
      material.uniforms.glowColor.value = color;
      return material;
   },

   glowMaterial: function () {
      var color = this.starColor;
      if ( color.equals( SCMAP.Color.BLACK ) ) {
         color.copy( SCMAP.Color.UNSET );
      }
      return new THREE.SpriteMaterial({
         map: SCMAP.System.GLOW_MAP,
         blending: THREE.AdditiveBlending,
         transparent: false,
         useScreenCoordinates: false,
         color: color
      });
   },

   labelSprite: function ( drawIcons ) {
      var canvas, texture, material;

      if ( !SCMAP.UI.fontAwesomeIsReady ) {
         drawIcons = false;
      }

      var icons = ( drawIcons ) ? this.getIcons() : [];
      canvas = this.drawSystemText( this.name, icons );

      texture = new THREE.Texture( canvas ) ;
      texture.needsUpdate = true;

      material = new THREE.SpriteMaterial({
         map: texture,
         useScreenCoordinates: false,
         blending: THREE.CustomBlending
      });

      return material;
   },

   // Refreshes the text and icons on the system's label
   updateLabelSprite: function ( spriteMaterial, drawLabels ) {
      var canvas, texture;
      var icons = ( drawLabels ) ? this.getIcons() : [];
      var iconsKey = this.iconsToKey( icons );
      if ( this._drawnText !== this.name || this._drawnSymbols !== iconsKey ) {
         canvas = this.drawSystemText( this.name, icons );
         texture = new THREE.Texture( canvas );
         texture.needsUpdate = true;
         spriteMaterial.map = texture;
      }
   },

   // Draws the text on a label
   drawSystemText: function ( text, icons ) {
      var canvas, context, texture, actualWidth;
      var textX, textY;

      canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      context = canvas.getContext('2d');

      context.font = '36pt Electrolize, Calibri, sans-serif';
      context.textAlign = 'center';
      context.strokeStyle = 'rgba(0,0,0,1.0)';
      context.lineWidth = 5;
      actualWidth = Math.ceil( context.measureText( text ).width + 1 );
      while ( actualWidth > canvas.width ) {
         canvas.width *= 2;
         canvas.height *= 2;
      }

      if ( false ) {
         context.beginPath();
         context.rect( 0, 0, canvas.width, canvas.height );
         context.lineWidth = 5;
         context.strokeStyle = 'yellow';
         context.stroke();
      }

      textX = canvas.width / 2;
      textY = canvas.height / 2;

      context.font = '36pt Electrolize, Calibri, sans-serif';
      context.strokeStyle = 'rgba(0,0,0,1.0)';
      context.textAlign = 'center';
      context.lineWidth = 5;
      context.strokeText( text, textX, textY );

      context.fillStyle = this.faction.color.getStyle();
      context.fillText( text, textX, textY );

      this._drawnText = text;
      this._drawnSymbols = '';

      if ( icons && icons.length ) {
         this._drawnSymbols = this.iconsToKey( icons );
         this._drawSymbols( context, textX, textY - 50, icons );
      }

      return canvas;
   },

   // Draws the icon(s) on a label
   _drawSymbols: function ( context, x, y, symbols ) {
      var i, symbol, totalWidth = ( SCMAP.Symbol.SIZE * symbols.length ) + ( SCMAP.Symbol.SPACING * ( symbols.length - 1 ) );
      var offX, offY;
      x -= totalWidth / 2;

      for ( i = 0; i < symbols.length; i++ )
      {
         symbol = symbols[ i ];

         offX = 0;
         offY = 0;

         if ( false ) {
            context.beginPath();
            context.rect( x, y - SCMAP.Symbol.SIZE, SCMAP.Symbol.SIZE, SCMAP.Symbol.SIZE );
            context.lineWidth = 5;
            context.strokeStyle = 'yellow';
            context.stroke();
         }

         if ( symbol.offset ) {
            offX = symbol.offset.x;
            offY = symbol.offset.y;
         }

         context.font = ( SCMAP.Symbol.SIZE * symbol.scale).toFixed(1) + 'pt FontAwesome';
         context.strokeStyle = 'rgba(0,0,0,1.0)';
         context.textAlign = 'center';
         context.lineWidth = 5;
         context.strokeText( symbol.code, x + offX + ( SCMAP.Symbol.SIZE / 2 ), y + offY );

         context.fillStyle = symbol.color;
         context.fillText( symbol.code, x + offX + ( SCMAP.Symbol.SIZE / 2 ), y + offY );

         x += SCMAP.Symbol.SIZE + SCMAP.Symbol.SPACING;
      }
   },

   createInfoLink: function ( noIcons ) {
      var $line = $( '<a></a>' );

      if ( typeof this.faction !== 'undefined' && typeof this.faction !== 'undefined' ) {
         $line.css( 'color', this.faction.color.getStyle() );
      }

      $line.addClass('system-link');
      $line.attr( 'data-goto', 'system' );
      $line.attr( 'data-system', this.id );
      $line.attr( 'href', '#system='+encodeURI( this.name ) );
      $line.attr( 'title', 'Show information on '+this.name );
      $line.html( '<i class="fa fa-crosshairs"></i>&nbsp;' + this.name );

      if ( !noIcons )
      {
         var icons = this.getIcons();
         if ( icons.length )
         {
            var $span = $('<span class="icons"></span>');
            for ( var i = 0; i < icons.length; i++ ) {
               $span.append( SCMAP.Symbol.getTag( icons[i] ) );
            }
            $line.append( $span );
         }
      }

      return $line;
   },

   iconsToKey: function ( icons ) {
      var list = [];
      for ( var i = 0; i < icons.length; i++ ) {
         list.push( icons[i].code );
      }
      return list.join( ';' );
   },

   getIcons: function () {
      var mySymbols = [];
      if ( false && this.name === 'Sol' ) {
         mySymbols.push( SCMAP.Symbols.DANGER );
         mySymbols.push( SCMAP.Symbols.WARNING );
         mySymbols.push( SCMAP.Symbols.HANGAR );
         mySymbols.push( SCMAP.Symbols.INFO );
         mySymbols.push( SCMAP.Symbols.TRADE );
         mySymbols.push( SCMAP.Symbols.BANNED );
         mySymbols.push( SCMAP.Symbols.COMMENTS );
         mySymbols.push( SCMAP.Symbols.BOOKMARK );
         return mySymbols;
      }
      if ( this.faction.isHostileTo( SCMAP.usersFaction() ) ) { mySymbols.push( SCMAP.Symbols.DANGER ); }
      if ( this.hasWarning() ) { mySymbols.push( SCMAP.Symbols.WARNING ); }
      if ( this.hasHangar() ) { mySymbols.push( SCMAP.Symbols.HANGAR ); }
      if ( this.blob.length ) { mySymbols.push( SCMAP.Symbols.INFO ); }
      if ( this.isMajorTradeHub() ) { mySymbols.push( SCMAP.Symbols.TRADE ); }
      if ( this.isOffLimits() ) { mySymbols.push( SCMAP.Symbols.BANNED ); }
      if ( this.hasComments() ) { mySymbols.push( SCMAP.Symbols.COMMENTS ); }
      if ( this.isBookmarked() ) { mySymbols.push( SCMAP.Symbols.BOOKMARK ); }
      return mySymbols;
   },

   displayInfo: function ( doNotSwitch ) {
      var worlds = '(No information)';
      var _import = '&mdash;';
      var _export = '&mdash;';
      var blackMarket = '&mdash;';
      var strategicValue = 'Unknown';
      var crimeStatus = 'Unknown';
      var i;
      var tmp = [];
      var $blurb = $('<div class="sc_system_info" '+SCMAP.UI.makeSafeForCSS(this.name)+'"></div>');
      var currentStep = window.map.route().indexOfCurrentRoute( this );

      $('#systemname')
         .attr( 'class', SCMAP.UI.makeSafeForCSS( this.faction.name ) )
         .css( 'color', this.faction.color.getStyle() )
         .text( 'System: ' + this.name );

      if ( typeof this.nickname === 'string' && this.nickname.length ) {
         $('#systemnickname').text( this.nickname ).show();
      } else {
         $('#systemnickname').text( '' ).hide();
      }

      if ( typeof currentStep === 'number' )
      {
         var currentRoute = window.map.route().currentRoute();
         var header = [];

         if ( currentStep > 0 ) {
            var $prev = currentRoute[currentStep-1].system.createInfoLink();
            $prev.attr( 'title', 'Previous jump to ' + currentRoute[currentStep-1].system.name +
               ' (' + currentRoute[currentStep-1].system.faction.name + ' territory)' );
            $prev.empty().append( '<i class="left fa fa-fw fa-arrow-left"></i>' );
            header.push( $prev );
         } else {
            header.push( $('<i class="left fa fa-fw"></i>') );
         }

         if ( currentStep < ( currentRoute.length - 1 ) ) {
            var $next = currentRoute[currentStep+1].system.createInfoLink();
            $next.attr( 'title', 'Next jump to ' + currentRoute[currentStep+1].system.name +
               ' (' + currentRoute[currentStep+1].system.faction.name + ' territory)'  );
            $next.empty().append( '<i class="right fa fa-fw fa-arrow-right"></i>' );
            header.push( $next );
         } else {
            header.push( $('<i class="right fa fa-fw"></i>') );
         }

         header.push( this.name );

         $('#systemname').empty().attr( 'class', SCMAP.UI.makeSafeForCSS( this.faction.name ) ).append( header );
      }

      if ( this.planetaryRotation.length ) {
         worlds = this.planetaryRotation.join( ', ' );
      }

      if ( this.import.length ) {
         _import = $.map( this.import, function( elem, i ) {
            return SCMAP.data.goods[ elem ].name;
         }).join( ', ' );
      }

      if ( this.export.length ) {
         _export = $.map( this.export, function( elem, i ) {
            return SCMAP.data.goods[ elem ].name;
         }).join( ', ' );
      }

      if ( this.blackMarket.length ) {
         blackMarket = $.map( this.blackMarket, function( elem, i ) {
            return SCMAP.data.goods[ elem ].name;
         }).join( ', ' );
      }

      //if ( typeof this.planets === 'string' || typeof this.planets === 'number' ) {
      //   planets = this.planets;
      //}

      if ( typeof this.crimeStatus === 'object' ) {
         crimeStatus = this.crimeStatus.name;
      }

      if ( typeof this.ueeStrategicValue === 'object' ) {
         strategicValue = this.ueeStrategicValue.color;
      }

      $("dl.basic-system dd.faction").text( this.faction.name );
      //$("dl.basic-system dd.planets").text( planets );
      $("dl.basic-system dd.rotation").html( worlds );
      $("dl.basic-system dd.import").html( _import );
      $("dl.basic-system dd.export").html( _export );
      $("dl.basic-system dd.blackMarket").html( blackMarket );
      $("dl.basic-system dt.crime").addClass( 'crime_'+crimeStatus.toLowerCase() );
      $("dl.basic-system dd.crime").text( crimeStatus );
      $("dl.basic-system dt.strategic").addClass( 'strategic_value_'+strategicValue.toLowerCase() );
      $("dl.basic-system dd.strategic").text( strategicValue );

      if ( this.faction.name !== 'Unclaimed' ) {
         $('dl.basic-system dd.faction').css( 'color', this.faction.color.getStyle() );
      }

      // User's notes and bookmarks

      $('#hangar-location').prop( 'checked', this.hasHangar() ).attr( 'data-system', this.id );
      $('#bookmark').prop( 'checked', this.isBookmarked() ).attr( 'data-system', this.id );

      if ( storage && storage['comments.'+this.id] ) {
         $('#comments').empty().val( storage['comments.'+this.id] );
         var $commentmd = $( markdown.toHTML( storage['comments.'+this.id] ) );
         $('#comments-md').html( $commentmd );
      } else {
         $('#comments').empty().val('');
         $('#comments-md').empty();
      }

      $('#comments').data( 'system', this.id );
      $('#bookmark').data( 'system', this.id );
      $('#hangar-location').data( 'system', this.id );

      if ( this.blob.length ) {
         var $md = $(markdown.toHTML( this.blob ));
         $md.find('p').prepend('<i class="fa fa-2x fa-quote-left"></i>');
         $blurb.append( '<div id="systemInfo">', $md, '</div>' );
         $('#system-background-info').show();
      } else {
         $('#system-background-info').hide();
      }

      if ( this.source ) {
         $blurb.append( '<p><a class="system-source-url" href="' + this.source + '" target="_blank">(source)</a></p>' );
      }

      $('#systemblurb').empty();
      $('#systemblurb').append( $blurb );

      $('#map_ui #system-selected').show();
      $('#map_ui #system-not-selected').hide();
      if ( !doNotSwitch ) {
         $('#map_ui').tabs( 'option', 'active', 2 );
         $('#map_ui').data( 'jsp' ).reinitialise();
         $('#map_ui').data( 'jsp' ).scrollToPercentY( 0 );
      }
   },

   // 2d/3d tween callback
   scaleY: function scaleY( object, scalar ) {
      var wantedY = object.userData.system.position.y * ( scalar / 100 );
      object.userData.system.sceneObject.translateY( wantedY - object.userData.system.sceneObject.position.y );
      object.userData.system.routeNeedsUpdate();
   },

   moveTo: function moveTo( vector ) {
      this.system.sceneObject.position.copy( vector );
      this.system.routeNeedsUpdate();
   },

   translateVector: function translateVector( vector ) {
      this.system.sceneObject.add( vector );
      this.system.routeNeedsUpdate();
   },

   routeNeedsUpdate: function () {
      for ( var j = 0; j < this._routeObjects.length; j++ ) {
         this._routeObjects[j].geometry.verticesNeedUpdate = true;
      }
   },

   // Returns the jumppoint leading to the given destination
   jumpPointTo: function ( destination ) {
      for ( var i = 0; i < this.jumpPoints.length; i++ ) {
         if ( this.jumpPoints[i].destination === destination ) {
            return this.jumpPoints[i];
         }
      }
   },

   isBookmarked: function ( ) {
      return storage && storage[ 'bookmarks.' + this.id ] === '1';
   },

   hasHangar: function ( ) {
      return storage && storage[ 'hangarLocation.' + this.id ] === '1';
   },

   hasComments: function ( ) {
      return storage && storage[ 'comments.' + this.id ];
   },

   isOffLimits: function ( ) {
      // TODO this needs to come from the DB
      return ( this.id === 90 || this.id === 97 );
   },

   hasWarning: function ( ) {
      // TODO this needs to come from the DB
      return ( this.id === 81 || this.id === 94 );
   },

   isMajorTradeHub: function ( ) {
      // TODO this needs to come from the DB
      return ( this.id === 82 || this.id === 95 || this.id === 80 || this.id === 102 || this.id === 100 || this.id === 108 || this.id === 96 || this.id === 85 || this.id === 83 || this.id === 106 || this.id === 15 || this.id === 84 || this.id === 88 || this.id === 19 || this.id === 92 );
   },

   getValue: function ( key ) {
      if ( key === undefined ) {
         return;
      }
      var value = this[ key ];
      return value;
   },

   setValues: function ( values ) {
      var key, currentValue, newValue, jumpPoint;

      if ( values === undefined ) {
         return;
      }

      for ( key in values ) {
         newValue = values[ key ];
         if ( newValue === undefined ) {
            console.log( 'SCMAP.System: "' + key + '" parameter is undefined for "'+this.name+'"' );
            continue;
         }

         if ( key in this )
         {
            currentValue = this[ key ];

            if ( key == 'size' ) {
               switch ( newValue ) {
                  case 'dwarf': this.scale = 0.6; break;
                  case 'medium': this.scale = 1.0; break;
                  case 'large': this.scale = 1.25; break;
                  case 'giant': this.scale = 1.6; break;
                  case 'binary': this.scale = 1.6; this.binary = true; break;
               }
               this[ key ] = newValue;
            }

            if ( currentValue instanceof THREE.Color ) {

               if ( newValue instanceof THREE.Color ) {
                  this[ key ] = newValue;
               } else {
                  newValue = newValue.replace( '0x', '#' );
                  this[ key ] = new THREE.Color( newValue );
               }

            } else if ( currentValue instanceof SCMAP.Faction ) {

               this[ key ] = newValue.claim( this );

            } else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

               currentValue.copy( newValue );

            } else if ( currentValue instanceof THREE.Vector3 ) {

               if ( newValue instanceof THREE.Vector3 ) {
                  currentValue.copy( newValue );
               } else if ( newValue instanceof Array ) {
                  currentValue.fromArray( newValue );
               }

            } else {

               this[ key ] = newValue;

            }
         }
      }
   }
};

SCMAP.System.preprocessSystems = function () {
   var i, systemName, system, data, faction;

   SCMAP.data.systemsById = {};
   SCMAP.System.List = [];

   for ( systemName in SCMAP.data.systems ) {

      data = SCMAP.data.systems[ systemName ];
      if ( data instanceof SCMAP.System ) {
         SCMAP.data.systemsById[ system.id ]   = data;
         SCMAP.data.systemsById[ system.uuid ] = data;
         continue;
      }

      faction = SCMAP.Faction.getById( data.faction_id );

      system = new SCMAP.System({
         id: data.system_id,
         uuid: data.uuid,
         name: systemName,
         position: data.coords,
         scale: data.scale || 1.0,
         starColor: data.color,
         faction: faction
      });

      system.setValues({
         'nickname': data.nickname,
         'size': data.size,
         'source': data.source,
         'crimeStatus': SCMAP.data.crime_levels[ data.crime_level_id ],
         'ueeStrategicValue': SCMAP.data.uee_strategic_values[ ""+data.uee_strategic_value_id ],
         'import': data.import,
         'export': data.export,
         'blackMarket': data.black_market,
         'blob': data.blob,
         'planets': 0,
         'planetaryRotation': [],
         'jumpPoints': data.jumppoints
      });

      SCMAP.data.systems[ system.name ]     = system;
      SCMAP.data.systemsById[ system.id ]   = system;
      SCMAP.data.systemsById[ system.uuid ] = system;

   }

   for ( systemName in SCMAP.data.systems )
   {

      system = SCMAP.System.getByName( systemName );

      SCMAP.System.List.push( system );

      for ( i = 0; i < system.jumpPoints.length; i++ )
      {
         jumpPoint = system.jumpPoints[ i ];
         system.jumpPoints[ i ] = new SCMAP.JumpPoint({
            source: system,
            destination: SCMAP.System.getById( jumpPoint.destination ),
            name: jumpPoint.name,
            typeId: jumpPoint.type_id,
            entryAU: jumpPoint.coords_au
         });
      }

   }
};

SCMAP.System.List = [];

SCMAP.System.SortedList = function() {
   var array = [];
   var i = SCMAP.System.List.length;
   while( i-- ) {
      array[i] = SCMAP.System.List[i];
   }
   var sorted = array.sort( humanSort );
   return sorted;
};

SCMAP.System.getByName = function ( name ) {
   return SCMAP.data.systems[ name ];
};

SCMAP.System.getById = function ( id ) {
   return SCMAP.data.systemsById[ id ];
};

SCMAP.Color = {};
SCMAP.Color.BLACK = new THREE.Color( 'black' );
SCMAP.Color.UNSET = new THREE.Color( 0x80A0CC );

SCMAP.System.COLORS = {
   RED: 0xFF6060,
   BLUE: 0x6060FF,
   WHITE: 0xFFFFFF,
   YELLOW: 0xFFFF60,
   ORANGE: 0xF0F080,
   UNKNOWN: 0xFFFFFF //0xC0FFC0
};
SCMAP.System.LABEL_SCALE = 0.06;
SCMAP.System.GLOW_SCALE = 6.5;

SCMAP.System.CUBE = new THREE.CubeGeometry( 1, 1, 1 );
//SCMAP.System.MESH = new THREE.SphereGeometry( 1, 12, 12 );

SCMAP.System.LODMESH = [
   [ new THREE.IcosahedronGeometry( 1, 3 ), 20 ],
   [ new THREE.IcosahedronGeometry( 1, 2 ), 50 ],
   [ new THREE.IcosahedronGeometry( 1, 1 ), 150 ]
];

SCMAP.System.STAR_MATERIAL_WHITE = new THREE.MeshBasicMaterial({ color: SCMAP.System.COLORS.WHITE, name: 'STAR_MATERIAL_WHITE' });

SCMAP.System.CUBE_MATERIAL = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true });
SCMAP.System.CUBE_MATERIAL.opacity = 0.3;
SCMAP.System.CUBE_MATERIAL.transparent = true;

SCMAP.System.GLOW_MAP = new THREE.ImageUtils.loadTexture( $('#gl-info').data('glow-image') );

// create custom material from the shader code in the html
$(function() {
   SCMAP.System.GLOW_SHADER_MATERIAL = new THREE.ShaderMaterial({
      uniforms: { 
         "c":   { type: "f", value: 0.05 },
         "p":   { type: "f", value: 3.3 },
         glowColor: { type: "c", value: SCMAP.Color.BLACK },
         viewVector: { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) }
      },
      vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
      fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
      side: THREE.BackSide,
      blending: THREE.AdditiveBlending,
      transparent: true
   });
});

// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.Dijkstra = function ( systems ) {
   if ( ! ( typeof systems === 'object' && Array.isArray( systems ) ) ) {
      console.error( "No array specified to SCMAP.Dijkstra constructor!" );
      return;
   }

   // First build a list of all nodes in the graph and
   // map them by system.id so they can be found quickly
   this._nodes = [];
   this._mapping = {}; // system.id to _nodes map
   i = systems.length;
   while( i-- ) {
      this._nodes[ i ] = {
         system:   systems[i],
         distance: Number.POSITIVE_INFINITY,
         previous: null
      };
      this._mapping[ systems[i].id ] = this._nodes[ i ];
   }

   this._result = {};
};

SCMAP.Dijkstra.prototype = {
   constructor: SCMAP.Dijkstra,

   buildGraph: function( parameters ) {
      var nodes, i, distance, system, currentNode, jumpPoint,
         otherNode, endTime, startTime = new Date();

      if ( typeof parameters !== "object" ) { throw "No parameters object given"; }
      if ( !parameters.source instanceof SCMAP.System ) { throw "No source given"; }
      if ( parameters.destination !== undefined && !parameters.destination instanceof SCMAP.System ) { throw "Invalid destination given"; }

      // This model allows for two priorities, time or fuel ... can't think
      // of any others which make sense (distance is really irrelevant for
      // gameplay purposes).
      // There will be other parameters to work out the route as well, but
      // this decides the main "cost" algorithm for the graph.
      if ( typeof priority !== 'string' || priority !== 'fuel' ) {
         priority = 'time';
      }

      if ( !( parameters.source instanceof SCMAP.System ) ) { return; }

      // TODO: expiry, map may have changed
      if ( this._result.source instanceof SCMAP.System && this._result.source === parameters.source && this._result.priority === priority ) {
         console.log( 'Reusing generated graph starting at', parameters.source.name );
         if ( parameters.destination instanceof SCMAP.System ) {
            this._result.destination = parameters.destination;
         }
         return;
      }

      if ( parameters.destination instanceof SCMAP.System ) {
         console.log( 'Building graph, starting at', parameters.source.name, 'and ending at', parameters.destination.name );
      } else {
         console.log( 'Building graph, starting at', parameters.source.name );
      }

      this.destroyGraph();
      this._result.source = parameters.source;
      this._result.destination = parameters.destination;

      // Created using http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Pseudocode

      for ( i = 0; i < this._nodes.length; i++ ) {
         this._nodes[ i ].distance = Number.POSITIVE_INFINITY;
         this._nodes[ i ].previous = null;
      }

      currentNode = this._mapping[ parameters.source.id ];
      currentNode.distance = 0; // distance from source to source
      currentNode.previous = null;

      nodes = SCMAP.Dijkstra.quickSort( this._nodes );

var distAU;

      while ( nodes.length )
      {
         currentNode = nodes[0];
         // Remove currentNode (the first node) from set
         nodes.splice( 0, 1 );
         //delete this._mapping[ currentNode.system.id ];

         // Don't bother with this node if it's not reachable
         if ( isInfinite( currentNode.distance ) ) {
            break;
         }

//console.log( "Working on node", currentNode.system.name, ', ', currentNode.system.jumpPoints.length, 'jumppoints to test' );

         for ( i = 0; i < currentNode.system.jumpPoints.length; i++ )
         {
            jumpPoint = currentNode.system.jumpPoints[i];
            otherNode = this._mapping[ jumpPoint.destination.id ];

            if ( jumpPoint.isUnconfirmed() && SCMAP.settings.route.avoidUnknownJumppoints ) {
               continue;
            }

            // Don't go into "hostile" nodes, unless we already are in one
            if ( SCMAP.settings.route.avoidHostile && !currentNode.system.faction.isHostileTo( SCMAP.usersFaction() ) && otherNode.system.faction.isHostileTo( SCMAP.usersFaction() ) ) {
               continue;
            }
            if ( SCMAP.settings.route.avoidOffLimits && currentNode.system.isOffLimits() ) {
               continue;
            }

//console.log( "  JP to", otherNode.system.name );

            if ( priority === 'time' )
            {
               // cost = half time to JP + JP time + half time from JP
               // TODO: at start and end this can be from start and to dest rather than half
               //distance = currentNode.distance + jumpPoint.length();
               distance = currentNode.distance + jumpPoint.jumpTime();
               if ( currentNode.previous === null ) {
distance += SCMAP.travelTimeAU( 0.35 ); // FIXME
                  //distance += SCMAP.travelTimeAU( jumpPoint.entryAU.length() ); // FIXME
                  //console.log( '    Flight time to JP entrance is', SCMAP.travelTimeAU( distAU ), 's' );
               }
               else
               {
//                  distance += SCMAP.travelTimeAU( currentNode.previous.system.jumpPointTo( currentNode.system ).entryAU.length() );
                  distance += SCMAP.travelTimeAU( 0.7 );
                  //distAU = currentNode.previous.system.jumpPointTo( currentNode.system ).entryAU.length();
                  //console.log( '    AU from', currentNode.previous.system.name, 'to', currentNode.system.name, 'is', distAU.toFixed(2) );
                  //console.log( "would add", SCMAP.travelTimeAU( currentNode.previous.system.jumpPointTo( currentNode.system ).entryAU.length() ).toFixed( 1 ) );
               }
            }
            else // priority == 'fuel'
            {
               // cost = half fuel to JP +         + half fuel from JP
               // TODO: at start and end this can be from start and to dest rather than half
               distance = currentNode.distance + jumpPoint.length();
            }

            // Get out of "never" nodes asap by increasing the cost massively
            if ( SCMAP.settings.route.avoidHostile && otherNode.system.faction.isHostileTo( SCMAP.usersFaction() ) ) {
               distance *= 15;
            }

            if ( distance < otherNode.distance ) {
               otherNode.distance = distance;
               otherNode.previous = currentNode;
               nodes = SCMAP.Dijkstra.quickSort( nodes );
            }
         }
      }

      this._result.nodes = nodes;
      this._result.priority = priority;
      endTime = new Date();
      console.log( 'Graph building took ' + (endTime.getTime() - startTime.getTime()) + ' msec' );
   },

   source: function() {
      var source = this._result.source;
      if ( source instanceof SCMAP.System ) {
         return source;
      }
   },

   destination: function() {
      var destination = this._result.destination;
      if ( destination instanceof SCMAP.System ) {
         return destination;
      }
   },

   rebuildGraph: function() {
      var source = this._result.source;
      var destination = this._result.destination;

      //console.log( "rebuildGraph from", source, 'to', destination );
      this.destroyGraph();

      if ( source instanceof SCMAP.System ) {
         this.buildGraph({
            source: source,
            destination: destination,
         });
         return true;
      }
   },

   destroyGraph: function() {
      this._result = {};
   },

   routeArray: function( destination ) {
      if ( ! ( destination instanceof SCMAP.System ) ) {
         console.error( 'No or invalid destination specified.' );
         return;
      }

      if ( this._result.nodes.length > 0 ) {
         // Get path and print it out, we're traversing backwards
         // through the optimal path for the destination
         var visited = [];
         var x = this._mapping[ destination.id ];
         var seen = {};
         while ( x !== null ) {
            seen[ x.system.name ] = true;
            visited.push( x );
            x = x.previous;
         }
         visited.reverse();
         return visited;
      }
   },

   constructRouteObject: function( from, to, callback ) {
      var routeArray, i, object;

      if ( !( from instanceof SCMAP.System ) || !( to instanceof SCMAP.System ) ) {
         return;
      }

      if ( typeof callback !== 'function' ) {
         console.error( "Callback not given or not a function" );
         return;
      }

      this.buildGraph({
         source: from,
         destination: to,
      });

      routeArray = this.routeArray( to );
      if ( typeof routeArray === 'object' && Array.isArray( routeArray ) ) {

         object = new THREE.Object3D();
         for ( i = 0; i < routeArray.length - 1; i++ ) {
            object.add( callback( routeArray[i+0].system, routeArray[i+1].system ) );
         }
         return object;

      }
   }
};

SCMAP.Dijkstra.quickSort = function ( nodes ) {
   // makes a copy, prevents overwriting
   var array = [];
   var i = nodes.length;
   while( i-- ) {
      array[i] = nodes[i];
   }

   if ( array.length <= 1 ) {
      return array;
   }

   var lhs = [];
   var rhs = [];
   var pivot = Math.ceil( array.length / 2 ) - 1;

   pivot = array.splice( pivot, 1 )[0];

   for ( i = 0; i < array.length; i++ ) {
      if ( array[i].distance <= pivot.distance ) {
         lhs.push( array[i] );
      } else {
         rhs.push( array[i] );
      }
   }

   var t1 = SCMAP.Dijkstra.quickSort( lhs );
   var t2 = SCMAP.Dijkstra.quickSort( rhs );

   t1.push( pivot );
   return t1.concat( t2 );
};

function isInfinite ( num ) {
   return !isFinite( num );
}

// End of file


/**
  * @author Lianna Eeftinck / https://github.com/Leeft
  */

SCMAP.Route = function ( start, end ) {
   this.start = ( start instanceof SCMAP.System ) ? start : null;
   this.end = ( this.start && end instanceof SCMAP.System ) ? end : null;
   this.waypoints = [];

   this._graph = new SCMAP.Dijkstra( SCMAP.System.List );
   this._routeObject = undefined;
};

SCMAP.Route.prototype = {
   constructor: SCMAP.Route,

   currentRoute: function () {
      if ( this.end instanceof SCMAP.System ) {
         return this._graph.routeArray( this.end );
      }
      return [];
   },

   indexOfCurrentRoute: function ( system ) {
      if ( ! system instanceof SCMAP.System ) {
         return;
      }

      var currentStep;
      var currentRoute = this.currentRoute();

      if ( currentRoute.length ) {
         for ( var i = 0; i < currentRoute.length; i++ ) {
            if ( currentRoute[i].system === system ) {
               currentStep = i;
               break;
            }
         }
      }

      return currentStep;
   },

   rebuildCurrentRoute: function () {
      this.removeFromScene();
      if ( this._graph.rebuildGraph() ) {
         console.log( "Have new graph" );
         var destination = this._graph.destination();
         if ( destination ) {
            console.log( "Have existing destination, updating route" );
            this.update( destination );
         }
      }
   },

   destroy: function () {
      this.remove();
      this.start = null;
      this.end = null;
      this.waypoints = [];
   },

   removeFromScene: function () {
      if ( this._routeObject ) {
         scene.remove( this._routeObject );
      }
      $('#routelist').empty();
   },

   update: function update( destination ) {
      var _this = this, i, route, material, system, $entry;

      if ( !( destination instanceof SCMAP.System ) ) {
         destination = this.end;
      }

      material = new THREE.MeshBasicMaterial( { color: 0xDD3322 } );
      material.opacity = 0.8;
      material.transparent = true;

      this.removeFromScene();

      // building all the parts of the route together in a single geometry group
      // the constructRouteObject method will iterate for us here with the callback
      this._routeObject = _this._graph.constructRouteObject( _this.start, destination, function ( from, to ) {
         var geometry = _this.createRouteGeometry( from, to );
         var mesh = new THREE.Mesh( geometry, material );
         mesh.position = from.sceneObject.position.clone();
         mesh.lookAt( to.sceneObject.position );
         return mesh;
      });

      if ( this._routeObject ) {
         scene.add( this._routeObject );
         this.end = destination;
         route = this._graph.routeArray( destination );
         $('#routelist').empty();
         if ( route.length > 1 )
         {
            $('#routelist').append('<p>The shortest route from '+route[0].system.createInfoLink( true ).outerHtml()+' to ' +
               route[route.length-1].system.createInfoLink( true ).outerHtml()+' along <strong>' + (route.length - 1) +
               '</strong> jump points:</p>').append( '<ol class="routelist"></ol>' );

            for ( i = 0; i < route.length; i++ ) {
               system = route[i+0].system;
               $entry = $('<li></li>').append( system.createInfoLink() );
               $('#routelist ol').append( $entry );
            }
         }
         else
         {
            $('#routelist').append('<p class="impossible">No route available to '+
               route[0].system.createInfoLink( true ).outerHtml()+' with your current settings</p>');
         }

         $('#map_ui').tabs( 'option', 'active', 3 );
      }
   },

   createRouteGeometry: function ( source, destination ) {
      var distance = source.sceneObject.position.distanceTo( destination.sceneObject.position );
      var geometry = new THREE.CylinderGeometry( 0.6, 0.6, distance, 8, 1, true );
      geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, distance / 2, 0 ) );
      geometry.applyMatrix( new THREE.Matrix4().makeRotationX( THREE.Math.degToRad( 90 ) ) );
      return geometry;
   }
};

// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.Map = function ( scene ) {
   this.name = "Star Citizen Persistent Universe";
   this.scene = scene;

   // No editing available for the moment (doesn't work yet)
   this.canEdit = false;
   $('#map_ui li.editor').hide();

   this._interactables = [];
   this._route = null; // The main route the user can set

   this._selectorObject = this.__createSelectorObject( 0xCCCC99 );
   scene.add( this._selectorObject );

   this._mouseOverObject = this.__createSelectorObject( 0x8844FF );
   this._mouseOverObject.scale.set( 4.0, 4.0, 4.0 );
   scene.add( this._mouseOverObject );

   SCMAP.Faction.preprocessFactions();
   SCMAP.Goods.preprocessGoods();
   SCMAP.System.preprocessSystems();

   this.__currentlySelected = null;
};

SCMAP.Map.prototype = {
   constructor: SCMAP.Map,

   getSelected: function getSelected () {
      return this.__currentlySelected;
   },

   selected: function selected() {
      return this.getSelected();
   },

   setSelected: function setSelected ( system ) {
      if ( system !== null && !(system instanceof SCMAP.System) ) {
         throw new Error( system, "is not an instance of SCMAP.System" );
      }
      this.__currentlySelected = system;
      return system;
   },

   __createSelectorObject: function __createSelectorObject ( color ) {
      var mesh = new THREE.Mesh( SCMAP.SelectedSystemGeometry, new THREE.MeshBasicMaterial({ color: color }) );
      mesh.scale.set( 4.2, 4.2, 4.2 );
      mesh.visible = false;
      mesh.userData.systemPosition = new THREE.Vector3( 0, 0, 0 );
      // 2d/3d tween callback
      mesh.userData.scaleY = function ( object, scalar ) {
         var wantedY = object.userData.systemPosition.y * ( scalar / 100 );
         object.translateY( wantedY - object.position.y );
      };
      return mesh;
   },

   __updateSelectorObject: function __updateSelectorObject ( system ) {
      if ( system instanceof SCMAP.System ) {
         this._selectorObject.visible = true;
         this._selectorObject.userData.systemPosition.copy( system.position );
         //this._selectorObject.position.copy( system.sceneObject.position );
         this.moveSelectorTo( system );
         this.setSelected( system );
      } else {
         this._selectorObject.visible = false;
         this.setSelected( null );
      }
   },

   // Lazy builds the route
   route: function route () {
      if ( !( this._route instanceof SCMAP.Route ) ) {
         this._route = new SCMAP.Route();
         console.log( "Created new route", this._route );
      }
      return this._route;
   },

   setSelectionTo: function setSelectionTo ( system ) {
      return this.__updateSelectorObject( system );
   },

   clearSelection: function clearSelection () {
      return this.__updateSelectorObject();
   },

   getSystemByName: function getSystemByName ( name ) {
      return SCMAP.System.getByName( name );
   },

   interactables: function interactables () {
      return this._interactables;
   },

   deselect: function deselect () {
      this.clearSelection();
      $('#system-selected').hide();
      $('#system-not-selected').show();
   },

   animateSelector: function animateSelector () {
      if ( this._selectorObject.visible ) {
         this._selectorObject.rotation.y = THREE.Math.degToRad( Date.now() * 0.00025 ) * 200;
      }
      if ( this._mouseOverObject.visible ) {
         this._mouseOverObject.rotation.y = THREE.Math.degToRad( Date.now() * 0.00025 ) * 200;
      }
   },

   updateSystems: function updateSystems () {
      for ( var i = 0; i < SCMAP.System.List.length; i++ ) {
         SCMAP.System.List[i].updateSceneObject( this.scene );
      }
   },

   setAllLabelSizes: function setAllLabelSizes ( vector ) {
      for ( var i = 0; i < SCMAP.System.List.length; i++ ) {
         var system = SCMAP.System.List[i];
         SCMAP.System.List[i].setLabelScale( vector );
      }
   },

   moveSelectorTo: function moveSelectorTo ( system ) {
      var tween, newPosition, position, _this = this, poi, graph, route;
      var tweens = [];

      if ( !(_this._selectorObject.visible) || !(_this.getSelected() instanceof SCMAP.System) ) {
         _this._selectorObject.userData.systemPosition.copy( system.position );
         _this._selectorObject.position.copy( system.sceneObject.position );
         _this._selectorObject.visible = true;
         _this.getSelected( system );
         return;
      }

      newPosition = system.sceneObject.position.clone();
      graph = new SCMAP.Dijkstra( SCMAP.System.List );
      graph.buildGraph({
         source: _this.getSelected(),
         destination: system
      });

      route = graph.routeArray( system );
      if ( route.length <= 1 ) {
         _this._selectorObject.userData.systemPosition.copy( system.position );
         _this._selectorObject.position.copy( system.sceneObject.position );
         _this._selectorObject.visible = true;
         _this.setSelected( system );
         return;
      }

      position = {
         x: _this._selectorObject.position.x,
         y: _this._selectorObject.position.y,
         z: _this._selectorObject.position.z
      };

      /* jshint ignore:start */
      for ( i = 0; i < route.length - 1; i++ ) {
         poi = route[ i + 1 ].system;

         tween = new TWEEN.Tween( position )
            .to( {
               x: poi.sceneObject.position.x,
               y: poi.sceneObject.position.y,
               z: poi.sceneObject.position.z
            }, 800 / ( route.length - 1 ) )
            .easing( TWEEN.Easing.Linear.None )
            .onUpdate( function () {
               _this._selectorObject.position.set( this.x, this.y, this.z );
            } );

         if ( i == 0 ) {
            if ( route.length == 2 ) {
               tween.easing( TWEEN.Easing.Cubic.InOut );
            } else {
               tween.easing( TWEEN.Easing.Cubic.In );
            }
         }

         if ( i > 0 ) {
            tweens[ i - 1 ].chain( tween );
         }

         if ( i == route.length - 2 ) {
            tween.easing( TWEEN.Easing.Cubic.Out );
            tween.onComplete( function() {
               _this._selectorObject.userData.systemPosition.copy( poi.position );
               _this._selectorObject.position.copy( poi.sceneObject.position );
               _this.setSelected( system );
            } );
         }

         tweens.push( tween );
      }
      /* jshint ignore:end */

      tweens[0].start();

   },

   populateScene: function populateScene () {
      var territory, territoryName, routeMaterial, system, systemName,
         source, destinations, destination, geometry,
         data, jumpPoint, jumpPointObject, faction, systemObject,
         endTime, startTime, systemCount = 0, good,
         i, systems, exports, black_markets, systemInfo, imports;

      endTime = startTime = new Date();

      // TODO: clean up the existing scene and map data when populating with
      // new data

      // First we go through the data to build the basic systems so
      // the routes can be built as well

      for ( systemName in SCMAP.data.systems ) {
         system = SCMAP.System.getByName( systemName );
         sceneObject = system.buildSceneObject();
         this.scene.add( sceneObject );
         this._interactables.push( sceneObject.children[0] );
         systemCount++;
      }

      // Then we go through again and add the routes

      for ( systemName in SCMAP.data.systems )
      {

         system = SCMAP.System.getByName( systemName );

         for ( i = 0; i < system.jumpPoints.length; i ++ ) {

            jumpPoint = system.jumpPoints[ i ];
            jumpPointObject = jumpPoint.buildSceneObject();
            if ( jumpPointObject instanceof THREE.Object3D ) {
               system._routeObjects.push( jumpPointObject );
               this.scene.add( jumpPointObject );
            }

         }

      }

      endTime = new Date();
      console.log( "Populating the scene (without ref plane) took " +
         (endTime.getTime() - startTime.getTime()) + " msec" );

      $('#debug-systems').html( systemCount + ' systems loaded' );

      var _this = this;
      SCMAP.UI.waitForFontAwesome( function() { _this.updateSystems(); } );
   },

   closestPOI: function closestPOI ( vector ) {
      var closest = Infinity, _closestPOI, system, length, systemname, xd, zd;

      for ( systemname in SCMAP.data.systems ) {
         system = SCMAP.System.getByName( systemname );
         xd = vector.x - system.position.x;
         zd = vector.z - system.position.z;
         length = Math.sqrt( xd * xd + zd * zd );
         if ( length < closest ) {
            closest = length;
            _closestPOI = system;
         }
      }

      return [ closest, _closestPOI ];
   },

   closestFromArray: function closestFromArray ( vector, systems ) {
      var closest = Infinity, closestPOI, system, length, systemname, xd, zd;

      for ( var i = 0; i < systems.length; i++ ) {
         system = systems[i];
         xd = vector.x - system.position.x;
         zd = vector.z - system.position.z;
         length = Math.sqrt( xd * xd + zd * zd );
         if ( length < closest ) {
            closest = length;
            closestPOI = system;
         }
      }

      return [ closest, closestPOI ];
   },

   // Get a quick list of systems nearby (within a square)
   withinApproxDistance: function withinApproxDistance ( vector, distance ) {
      var systems = [];
      for ( var i = 0; i < SCMAP.System.List.length; i += 1 ) {
         var system = SCMAP.System.List[i];
         if ( system.position.x < ( vector.x - distance ) ) { continue; }
         if ( system.position.x > ( vector.x + distance ) ) { continue; }
         if ( system.position.z < ( vector.z - distance ) ) { continue; }
         if ( system.position.z > ( vector.z + distance ) ) { continue; }
         systems.push( system );
      }
      return systems;
   },

   furthestPOI: function furthestPOI ( vector ) {
      var furthest = 0, _furthestPOI, system, length, systemname, xd, zd;

      for ( systemname in SCMAP.data.systems ) {
         system = SCMAP.System.getByName[ systemname ];
         xd = vector.x - system.position.x;
         zd = vector.z - system.position.z;
         length = Math.sqrt( xd * xd + zd * zd );
         if ( length > furthest ) {
            furthest = length;
            _furthestPOI = system;
         }
      }
      return [ furthest, _furthestPOI ];
   },

   referencePlaneTerritoryColor: function referencePlaneTerritoryColor () {
      if ( ! this.referencePlane instanceof THREE.Object3D ) {
         return;
      }

      var geometry = this.referencePlane.geometry,
         minDistance = 55;

      for ( var i = 0; i < geometry.vertices.length; i++ )
      {
         var point = geometry.vertices[ i ];
         var arr = this.closestPOI( point );
         var distance = arr[0],
             closest = arr[1];
         if ( distance > minDistance ) { distance = minDistance; }
         var strength = ( minDistance - distance ) / minDistance;
         var color = closest.faction.planeColor.clone();
         color.multiplyScalar( strength * 0.8 );
         geometry.colors[i] = color;

         //var color = closest.faction.color.clone();
         //   var strength = ( minDistance - distance ) / minDistance;
         //   color.multiplyScalar( strength * 1.2 );
         //   geometry.colors[i] = color;
      }
   },

   referencePlaneSolidColor: function referencePlaneSolidColor( color ) {
      var geometry = this.referencePlane.geometry,
         i, point;
      if ( ! this.referencePlane instanceof THREE.Object3D ) {
         return;
      }
      for ( i = 0; i < geometry.vertices.length; i++ ) {
         point = geometry.vertices[ i ];
         geometry.colors[i] = color;
      }
   },

   pointAtPlane: function pointAtPlane( theta, radius, y ) {
      return new THREE.Vector3( radius * Math.cos( theta ), y, -radius * Math.sin( theta ) );
   },

   referencePlaneTerritoryColourMesh: function referencePlaneTerritoryColourMesh( material, prevTheta, nextTheta, innerRadius, outerRadius ) {
      var geo, mesh;
      geo = new THREE.Geometry();
      geo.vertices.push( this.pointAtPlane( prevTheta, innerRadius, -0.04 ) );
      geo.vertices.push( this.pointAtPlane( nextTheta, innerRadius, -0.04 ) );
      geo.vertices.push( this.pointAtPlane( nextTheta, outerRadius, -0.04 ) );
      geo.vertices.push( this.pointAtPlane( prevTheta, outerRadius, -0.04 ) );
      geo.faces.push( new THREE.Face3( 2, 1, 0 ) );
      geo.faces.push( new THREE.Face3( 3, 2, 0 ) );
      mesh = new THREE.Mesh( geo, material );
      return mesh;
   },

   buildReferenceGrid: function buildReferenceGrid() {
      var segmentSize = 10, i, j, k, x, z, position;
      var minX = 0, minZ = 0, maxX = 0, maxZ = 0;
      var endTime, startTime;
      var uniqueColours = {};
      var left, right, above, below;
      var vertices, vertexColours;
      var geo = new THREE.Geometry();
      var color;
      var grid = {};
      var alongX = {};

      endTime = startTime = new Date();

      // First we compute rough outer bounds based on all the systems on the map
      // (plus a bit extra because we want to fade to black as well)
      for ( i = 0; i < SCMAP.System.List.length; i += 1 ) {
         position = SCMAP.System.List[i].position;
         if ( position.x < minX ) { minX = position.x - (  6 * 10 ); }
         if ( position.x > maxX ) { maxX = position.x + (  8 * 10 ); }
         if ( position.z < minZ ) { minZ = position.z - (  6 * 10 ); }
         if ( position.z > maxZ ) { maxZ = position.z + ( 10 * 10 ); }
      }

      // Now round those numbers to a multiple of segmentSize
      minX = Math.floor( minX / segmentSize ) * segmentSize;
      minZ = Math.floor( minZ / segmentSize ) * segmentSize;
      maxX = Math.floor( maxX / segmentSize ) * segmentSize;
      maxZ = Math.floor( maxZ / segmentSize ) * segmentSize;

      // With the boundaries established, go through each coordinate
      // on the map, and set the colour for each gridpoint on the
      // map with the nearest system's faction being used for that
      // colour. We also take note of each X coordinate visited.
      // There is a bit of room for optimisation left here; the
      // systems could be sorted by a X or Z coordinate, sort of like
      // in an octree, and could possibly be found quicker that way.
      for ( var iz = minZ; iz <= maxZ; iz += segmentSize ) {

         grid[ iz ] = {};

         for ( var ix = minX; ix <= maxX; ix += segmentSize ) {

            alongX[ ix ] = true;

            var vector = new THREE.Vector3( ix, 0, iz );
            var systems = this.withinApproxDistance( vector, 6.5 * segmentSize );

            color = this.colorForVector( vector, systems, segmentSize );

            if ( color !== SCMAP.Map.BLACK )
            {
               grid[ iz ][ ix ] = color.getHexString();
               if ( uniqueColours[ grid[iz][ix] ] === undefined ) {
                  uniqueColours[ grid[iz][ix] ] = color;
               }
            }
            else
            {
               grid[ iz ][ ix ] = null;
               uniqueColours[ null ] = SCMAP.Map.BLACK;
            }

         }

      }

      // Now for both X and Z we build a sorted list of each of
      // those coordinates seen, allowing for quick iteration.
      var alongX2 = []; for ( j in alongX ) { alongX2.push( j ); }
      alongX2.sort( function ( a, b ) { return a - b; } );
      alongX = alongX2;

      var alongZ = []; for ( j in grid ) { alongZ.push( j ); }
      alongZ.sort( function ( a, b ) { return a - b; } );

      // Now we got most data worked out, and we can start drawing
      // the horizontal lines. We draw a line from start vertex to
      // end vertex for each section where the colour doesn't
      // change. This gives us the fewest number of lines drawn.
      for ( i = 1; i < alongZ.length; i += 1 ) {
         z = alongZ[i];
         vertices = [];
         vertexColours = [];

         for ( j = 1; j < alongX.length; j += 1 ) {
            x = alongX[ j ];
            left = Math.floor( Number( x ) - segmentSize );
            right = Math.floor( Number( x ) + segmentSize );

            vertexColor = grid[ z ][ x ];

            if ( (vertexColor !== grid[z][left]  && grid[z][left] ) ||
                 (vertexColor !== grid[z][right] && grid[z][right])    ) {
               vertices.push( new THREE.Vector3( x, 0, z ) );
               vertexColours.push( uniqueColours[ vertexColor ] );
            }
         }

         for ( k = 0; k < vertices.length - 1; k++ ) {
            geo.vertices.push( vertices[k] );
            geo.colors.push( vertexColours[k] );
            geo.vertices.push( vertices[k+1] );
            geo.colors.push( vertexColours[k+1] );
         }
      }

      // And do the same for the vertical lines in a separate pass
      for ( i = 1; i < alongX.length; i += 1 ) {
         x = alongX[i];
         vertices = [];
         vertexColours = [];

         for ( j = 1; j < alongZ.length; j += 1 ) {
            z = alongZ[j];
            above = Math.floor( Number( z ) - segmentSize );
            below = Math.floor( Number( z ) + segmentSize );

            vertexColor = grid[ z ][ x ];

            if ( ( grid[above] && grid[above][x] && vertexColor !== grid[above][x] ) ||
                 ( grid[below] && grid[below][x] && vertexColor !== grid[below][x] )    ) {
               vertices.push( new THREE.Vector3( x, 0, z ) );
               vertexColours.push( uniqueColours[ vertexColor ] );
            }
         }

         for ( k = 0; k < vertices.length - 1; k++ ) {
            geo.vertices.push( vertices[k] );
            geo.colors.push( vertexColours[k] );
            geo.vertices.push( vertices[k+1] );
            geo.colors.push( vertexColours[k+1] );
         }
      }

      // Finally create the object with the geometry just built
      var referenceLines = new THREE.Line( geo, new THREE.LineBasicMaterial({
         linewidth: 1.5, wireframe: true, vertexColors: THREE.VertexColors
      }), THREE.LinePieces );

      endTime = new Date();
      console.log( "Building the grid reference plane took " +
         (endTime.getTime() - startTime.getTime()) + " msec" );

      return referenceLines;
   },

   colorForVector: function colorForVector( vector, systems, segmentSize ) {
      var color = SCMAP.Map.BLACK;
      var arr = this.closestFromArray( vector, systems );
      if ( arr[0] <= 4.5 * segmentSize && arr[1] ) {
         color = arr[1].faction.planeColor.clone();
         if ( arr[0] >= 4.0 * segmentSize ) {
            color.multiplyScalar( 0.5 );
         } else if ( arr[0] >= 3.0 * segmentSize ) {
            color.multiplyScalar( 0.8 );
         }
      }
      return color;
   },

   buildOldReferencePlane: function buildOldReferencePlane()
   {
      var ringWidth = 10.0, // plane circle scaling factor to match the map video
         step = 2 * Math.PI / 36, // 36 radial segments
         radius, insideRadius, outsideRadius,
         lineMaterial, referenceLines, lineGeometry,
         centerTheta, cosPrevTheta, sinPrevTheta, cosCenterTheta, sinCenterTheta,
         xInside, zInside, xOutside, zOutside, zInside2, xOutside2, zOutside2,
         maxRadius, arr,
         endTime, startTime,
         referenceColours = new THREE.Object3D(), prevTheta, nextTheta, i;

      endTime = startTime = new Date();

      // Work out how far away the furtest system is
      // so that we can stop drawing just beyond that
      // point
      arr = this.furthestPOI( new THREE.Vector3() );
      maxRadius = arr[0] + 50;

      lineMaterial = new THREE.LineBasicMaterial({
         color: 0x6060A0,
         linewidth: 1.5,
         vertexColors: true,
         opacity: 0.6
      } );
      lineGeometry = new THREE.Geometry();

      // Around in a circle, processing each center point of the
      // squares we'll be drawing (dividing our step by 2 makes it
      // the center point)
      var theta;
      for ( centerTheta = step / 2; centerTheta < 2 * Math.PI; centerTheta += step )
      {
         cosCenterTheta = Math.cos( centerTheta );
         sinCenterTheta = Math.sin( centerTheta );

         prevTheta = centerTheta - step / 2;
         nextTheta = centerTheta + step / 2;
         cosPrevTheta = Math.cos( prevTheta );
         sinPrevTheta = Math.sin( prevTheta );

         // inside to out, stop at furthest out
         for ( radius = ringWidth / 2; radius < maxRadius; radius += ringWidth )
         {
            insideRadius  = radius - ringWidth / 2;
            outsideRadius = radius + ringWidth / 2;
            arr = this.closestPOI( new THREE.Vector3( radius * cosCenterTheta, 0, -radius * sinCenterTheta ) );

            if ( arr[0] <= 35 )
            {
               //var mesh = this.referencePlaneTerritoryColourMesh(
               //   arr[1].faction.material(), prevTheta, nextTheta, insideRadius, outsideRadius
               //);
               //if ( mesh ) {
               //   referenceColours.add( mesh );
               //}
         //var point = geometry.vertices[ i ];
         //var arr = this.closestPOI( point );
         //var distance = arr[0],
         //    closest = arr[1];
         //if ( distance > minDistance ) { distance = minDistance; }
         //var strength = ( minDistance - distance ) / minDistance;
         //var color = closest.faction.planeColor.clone();
         //color.multiplyScalar( strength * 0.8 );
         //geometry.colors[i] = color;
            }

            if ( arr[0] < 55 )
            {
               xInside  =  insideRadius  * cosPrevTheta;
               zInside  = -insideRadius  * sinPrevTheta;
               xOutside =  outsideRadius * cosPrevTheta;
               zOutside = -outsideRadius * sinPrevTheta;
               lineGeometry.vertices.push( new THREE.Vector3( xInside,  0, zInside  ) );
               lineGeometry.vertices.push( new THREE.Vector3( xOutside, 0, zOutside ) );
               lineGeometry.vertices.push( new THREE.Vector3( xInside,  0, zInside  ) );
               lineGeometry.vertices.push( new THREE.Vector3(
                  insideRadius * Math.cos( nextTheta ), 0, -insideRadius * Math.sin( nextTheta )
               ) );
            }
         }
      }

      // set basic color
      for ( i = 0; i < lineGeometry.vertices.length; i++ ) {
         lineGeometry.colors[i] = lineMaterial.color;
      }

      // and create the ground reference plane
      referenceLines = new THREE.Line( lineGeometry, lineMaterial, THREE.LinePieces );
      this.referencePlane = referenceLines;
      scene.add( referenceLines );

      scene.add( referenceColours );

      endTime = new Date();
      console.log( "Building the territory reference plane took " +
         (endTime.getTime() - startTime.getTime()) + " msec" );
   }
};

SCMAP.Map.BLACK = new THREE.Color( 0x000000 );

// EOF

/**
  * @author Lianna Eeftinck / https://github.com/Leeft
  */

SCMAP.UI = function () {

   $('#bookmark-list-header a').append( SCMAP.Symbol.getTag( SCMAP.Symbols.BOOKMARK ).addClass('fa-lg') );
   $('#hangar-list-header a').append( SCMAP.Symbol.getTag( SCMAP.Symbols.HANGAR ).addClass('fa-lg') );
   $('#commented-list-header a').append( SCMAP.Symbol.getTag( SCMAP.Symbols.COMMENTS ).addClass('fa-lg') );

   $('#faction-list').empty();
   for ( var factionId in SCMAP.data.factions ) {
      var faction = SCMAP.data.factions[factionId];
      var $factionHeader = $('<h3><a href="#" data-toggle-next="next"><i class="fa fa-fw fa-lg fa-caret-right"></i>'+faction.name+'</a></h3>');
          $factionHeader.find('a').css( 'color', faction.color.getStyle() );
      var $factionSystems = $('<ul style="display: none;" id="list-faction-'+faction.id+'" class="fa-ul ui-section"></ul>');
      $('#faction-list').append( $factionHeader ).append( $factionSystems );
   }

   $( "#map_ui" ).tabs({
      active: 0,
      activate: function( event, ui ) {
         event.preventDefault();
         var clicked_on = ui.newTab.find('a').attr('href');

         switch ( clicked_on ) {

            case '#editor':
               if ( map.canEdit ) {
                  $('#webgl-container').removeClass().addClass( 'noselect webgl-container-edit' );
                  //window.editor.enabled = true;
                  //window.controls.requireAlt = true;
               }
               break;

            case '#listing':
               var systems = SCMAP.System.SortedList();
               var bookmarkCount = 0, hangarCount = 0, commentedCount = 0;
               var system;

               $('#hangar-list').empty();
               $('#bookmark-list').empty();
               $('#commented-list').empty();
               $('#a-z-list').empty();

               for ( var i = 0; i < systems.length; i += 1 ) {
                  system = systems[ i ];
                  var link = system.createInfoLink().outerHtml();

                  if ( storage && storage[ 'hangarLocation.' + system.id ] === '1' ) {
                     hangarCount += 1;
                     $('#hangar-list').append( $('<li>'+link+'</li>') );
                  }

                  if ( storage && storage[ 'bookmarks.' + system.id ] === '1' ) {
                     bookmarkCount += 1;
                     $('#bookmark-list').append( $('<li>'+link+'</li>') );
                  }

                  if ( storage ) {
                     if ( 'comments.'+system.id in storage ) {
                        commentedCount += 1;
                        $('#commented-list').append( $('<li>'+link+'</li>') );
                     }
                  }

                  $('#a-z-list').append( $('<li>'+link+'</li>') );
               }

               if ( bookmarkCount > 0 ) {
                  $('#bookmark-list-wrapper').show();
               } else {
                  $('#bookmark-list-wrapper').hide();
               }

               if ( hangarCount > 0 ) {
                  $('#hangar-list-wrapper').show();
               } else {
                  $('#hangar-list-wrapper').hide();
               }

               if ( commentedCount > 0 ) {
                  $('#commented-list-wrapper').show();
               } else {
                  $('#commented-list-wrapper').hide();
               }

               for ( var factionId in SCMAP.data.factions ) {
                  var faction = SCMAP.data.factions[factionId];
                  $('#list-faction-'+faction.id).empty();
                  for ( i = 0; i < systems.length; i += 1 ) {
                     system = systems[i];
                     if ( system.faction.id === faction.id ) {
                        $('#list-faction-'+faction.id).append( '<li>'+system.createInfoLink().outerHtml()+'</li>' );
                     }
                  }
               }

               break;

            default:
               $('#webgl-container').removeClass().addClass( 'noselect webgl-container-noedit' );
               //window.editor.enabled = false;
               //window.controls.requireAlt = false;
               //if ( clicked_on === '#info' && map.selected() instanceof SCMAP.System ) {
               //   map.selected().displayInfo();
               //}
               break;
         }

         $('#map_ui').data( 'jsp' ).reinitialise();
      }
   });

   /* jScrollPane */
   $('#map_ui').jScrollPane({ showArrows: true });

   $('#toggle-glow').prop( 'checked', SCMAP.settings.glow );
   $('#toggle-labels').prop( 'checked', SCMAP.settings.labels );
   $('#toggle-label-icons').prop( 'checked', SCMAP.settings.labelIcons );

   $('#avoid-hostile').prop( 'checked', SCMAP.settings.route.avoidHostile );
   $('#avoid-off-limits').prop( 'checked', SCMAP.settings.route.avoidOffLimits );
   $('#avoid-unknown-jumppoints').prop( 'checked', SCMAP.settings.route.avoidUnknownJumppoints );

   for ( var icon in SCMAP.Symbols ) {
      icon = SCMAP.Symbols[ icon ];
      var $li = $('<li><i class="fa-li fa '+icon.faClass+'"></i>'+icon.description+'</li>' );
      $li.css( 'color', icon.color );
      $('#map_ui ul.legend').append( $li );
   }

   // Event handlers

   $('#3d-mode').prop( 'checked', SCMAP.settings.mode === '3d' );

   // Some simple UI stuff

   $('#lock-rotation').prop( 'checked', SCMAP.settings.control.rotationLocked );

   $('#3d-mode').on( 'change', function() { if ( this.checked ) displayState.to3d(); else displayState.to2d(); });

   $('#avoid-hostile').on( 'change', function() {
      SCMAP.settings.route.avoidHostile = this.checked;
      SCMAP.settings.save( 'route' );
      map.route().rebuildCurrentRoute();
   });
   $('#avoid-off-limits').on( 'change', function() {
      SCMAP.settings.route.avoidOffLimits = this.checked;
      SCMAP.settings.save( 'route' );
      map.route().rebuildCurrentRoute();
   });
   $('#avoid-unknown-jumppoints').on( 'change', function() {
      SCMAP.settings.route.avoidUnknownJumppoints = this.checked;
      SCMAP.settings.save( 'route' );
      map.route().rebuildCurrentRoute();
   });

   $('#lock-rotation').on( 'change', function() {
      controls.noRotate = this.checked;
      if ( storage ) {
         storage['control.rotationLocked'] = ( this.checked ) ? '1' : '0';
      }
   });

   $('#toggle-stats')
      .prop( 'checked', ( storage && storage['renderer.Stats'] === '1' ) ? true : false )
      .on( 'change', function() {
         if ( this.checked ) {
            $('#stats').show();
         } else {
            $('#stats').hide();
         }
         if ( storage ) {
            storage['renderer.Stats'] = ( this.checked ) ? '1' : '0';
         }
      });

   $('#toggle-antialias')
      .prop( 'checked', SCMAP.settings.effect.Antialias )
      .on( 'change', function() {
         SCMAP.settings.effect.Antialias = this.checked;
         SCMAP.settings.save( 'effect' );
         console.log( localStorage.effect );
         window.location.reload( false );
      });

   $('#toggle-fxaa')
      .prop( 'checked', SCMAP.settings.effect.FXAA )
      .prop( 'disabled', SCMAP.settings.effect.Antialias )

      .on( 'change', function() {
         SCMAP.settings.effect.FXAA = this.checked;
         SCMAP.settings.save( 'effect' );
         if ( effectFXAA ) {
            effectFXAA.enabled = this.checked;
         }
      });

   $('#toggle-bloom')
      .prop( 'checked', SCMAP.settings.effect.Bloom )
      .prop( 'disabled', SCMAP.settings.effect.Antialias )

      .on( 'change', function() {
         SCMAP.settings.effect.Bloom = this.checked;
         SCMAP.settings.save( 'effect' );
         if ( composer ) {
            for ( var i = 0; i < composer.passes.length; i++ ) {
               if ( composer.passes[i] instanceof THREE.BloomPass ) {
                  composer.passes[i].enabled = this.checked;
               }
            }
         }
      });

   $('#toggle-glow').on( 'change', function() {
      SCMAP.settings.glow = this.checked;
      map.updateSystems();
      if ( storage ) {
         storage['settings.Glow'] = ( this.checked ) ? '1' : '0';
      }
   });
   $('#toggle-labels').on( 'change', function() {
      SCMAP.settings.labels = this.checked;
      map.updateSystems();
      if ( storage ) {
         storage['settings.Labels'] = ( this.checked ) ? '1' : '0';
      }
   });
   $('#toggle-label-icons').on( 'change', function() {
      SCMAP.settings.labelIcons = this.checked;
      map.updateSystems();
      if ( storage ) {
         storage['settings.LabelIcons'] = ( this.checked ) ? '1' : '0';
      }
   });

   $('#resetCamera').on( 'click', function() {
      controls.cameraTo(
         SCMAP.settings.cameraDefaults.target,
         SCMAP.settings.cameraDefaults.orientation.theta,
         SCMAP.settings.cameraDefaults.orientation.phi,
         SCMAP.settings.cameraDefaults.orientation.radius
      );
   });
   $('#centreCamera').on( 'click', function() {
      controls.moveTo( SCMAP.settings.cameraDefaults.target );
   });
   $('#northCamera').on( 'click', function() {
      controls.rotateTo( 0, undefined, undefined );
   });
   $('#topCamera').on( 'click', function() {
      controls.rotateTo( 0, 0, 180 );
   });
   $('#top2D').on( 'click', function() {
      controls.noRotate = true;
      $('#lock-rotation').prop( 'checked', true );
      displayState.to2d();
      controls.rotateTo( 0, 0, 180 );
   });
   $('.quick-button.with-checkbox').on( 'click', function ( event ) {
      var $this = $(this);
      $this.find('input[type=checkbox]').click();
   });

   $('#map_ui').on( 'click', 'a[data-toggle-next]', function ( event ) {
      var $this = $(this);
      event.preventDefault();
      var $element = $this.parent().next();
      $element.toggle();
      if ( $element.is(':visible') ) {
         $this.parent().find('> a > i').first().removeClass('fa-caret-right').addClass('fa-caret-down');
      } else {
         $this.parent().find('> a > i').first().addClass('fa-caret-right').removeClass('fa-caret-down');
      }
      $('#map_ui').data( 'jsp' ).reinitialise();
   });

   $('#map_ui').on( 'click', 'a[data-toggle-child]', function ( event ) {
      var $this = $(this);
      event.preventDefault();
      var $element = $this.parent().find( $this.data('toggle-child') );
      $element.toggle();
      if ( $element.is(':visible') ) {
         $this.parent().find('> a > i').removeClass('fa-caret-right').addClass('fa-caret-down');
      } else {
         $this.parent().find('> a > i').addClass('fa-caret-right').removeClass('fa-caret-down');
      }
      $('#map_ui').data( 'jsp' ).reinitialise();
   });

   $('#map_ui').on( 'click', "a[data-goto='system']", function( event ) {
      event.preventDefault();
      var $this = $(this);
      var system = SCMAP.System.getById( $this.data('system') );
      system.displayInfo();
      controls.moveTo( system );
   });

   var updateComments = function( event ) {
      event.preventDefault();
      if ( !storage ) { return; }
      var system = SCMAP.System.getById( $(this).data('system') );
      var text = $(this).val();
      if ( typeof text === 'string' && text.length > 0 ) {
         storage['comments.'+system.id] = text;
         //$md.find('p').prepend('<i class="fa fa-2x fa-quote-left"></i>');
         var $commentmd = $(markdown.toHTML( text ));
         $('#comments-md').html( $commentmd );
      } else {
         delete storage['comments.'+system.id];
         $('#comments-md').empty();
      }
      system.updateSceneObject( scene );
   };
   $('#comments').on( 'keyup', updateComments );
   $('#comments').on( 'blur', updateComments );
   $('#comments').on( 'change', updateComments );

   $('#bookmark').on( 'change', function() {
      var system = SCMAP.System.getById( $(this).data('system') );
      if ( !storage ) { return; }
      if ( this.checked ) {
         storage['bookmarks.'+system.id] = '1';
      } else {
         delete storage['bookmarks.'+system.id];
      }
      system.updateSceneObject( scene );
   });

   $('#hangar-location').on( 'change', function() {
      var system = SCMAP.System.getById( $(this).data('system') );
      if ( !storage ) { return; }
      if ( this.checked ) {
         storage['hangarLocation.'+system.id] = '1';
      } else {
         delete storage['hangarLocation.'+system.id];
      }
      system.updateSceneObject( scene );
   });
};

SCMAP.UI.prototype = {

   constructor: SCMAP.UI

};

SCMAP.UI.makeSafeForCSS = function makeSafeForCSS( name ) {
   if ( typeof name !== 'string' ) {
      return;
   }
   return name.replace( /[^a-zA-Z0-9]/g, function(s) {
      var c = s.charCodeAt(0);
      if (c == 32) return '-';
      if (c >= 65 && c <= 90) return '_' + s.toLowerCase();
      return (c.toString(16)).slice(-4);
   });
};

SCMAP.UI.fontAwesomeIsReady = false;
SCMAP.UI.waitForFontAwesome = function waitForFontAwesome( callback ) {
   var retries = 5;

   function checkReady () {
      var canvas, context;
      retries -= 1;
      canvas = document.createElement('canvas');
      canvas.width = 20;
      canvas.height = 20;
      context = canvas.getContext('2d');
      context.font = '16pt FontAwesome';
      context.textAlign = 'center';
      context.fillStyle = 'rgba(255,255,255,1.0)';
      context.fillText( '\uf0c8', 10, 18 );
      var data = context.getImageData( 10, 10, 1, 1 ).data;
      if ( data[0] === 0 && data[1] === 0 && data[2] === 0 ) {
         console.log( "FontAwesome is not yet available, retrying ..." );
         if ( retries > 0 ) {
            setTimeout( checkReady, 200 );
         }
      } else {
         console.log( "FontAwesome is loaded" );
         SCMAP.UI.fontAwesomeIsReady = true;
         if ( typeof callback === 'function' ) {
            callback();
         }
      }
   }

   checkReady();
};

// End of file

/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 * @author Leeft / https://github.com/Leeft
 */
/*global THREE, console */

// This set of controls performs orbiting, dollying (zooming), and panning. It maintains
// the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
// supported.
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finter swipe

// Heavily modified version of OrbitControls.js (by Leeft) with a finite
// state machine for dealing with the user's input (I needed more than
// just basic control).

SCMAP.OrbitControls = function ( object, domElement ) {

   this.object = object;
   this.domElement = ( domElement !== undefined ) ? domElement : document;

   // API

   // Set to false to disable this control
   this.enabled = true;

   // "target" sets the location of focus, where the control orbits around
   // and where it pans with respect to.
   this.target = new THREE.Vector3();
   // center is old, deprecated; use "target" instead
   this.center = this.target;

   // This option actually enables dollying in and out; left as "zoom" for
   // backwards compatibility
   this.noZoom = false;
   this.zoomSpeed = 1.0;
   // Limits to how far you can dolly in and out
   this.minDistance = 20;
   this.maxDistance = 800;

   // Set to true to disable this control
   this.noRotate = false;
   this.rotateSpeed = 1.0;

   // Set to true to disable this control
   this.noPan = false;
   this.keyPanSpeed = 25; // pixels moved per arrow key push
   this.mapMode = true; // map mode pans on x,z
   this.requireAlt = false; // to allow soft-disable of this control temporarily

   // How far you can orbit vertically, upper and lower limits.
   // Range is 0 to Math.PI radians.
   this.minPolarAngle = 0; // radians
   this.maxPolarAngle = THREE.Math.degToRad( 85 ); // radians

   // Set to true to disable use of the keys
   this.noKeys = false;
   // The four arrow keys
   this.keys = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      BOTTOM: 40,
      ESCAPE: 27,
      R: 82,
      C: 67,
      T: 84,
      2: 50,
      3: 51,
      L: 76,
      SPACE: 32,
      TAB: 9
   };

   this.debug = false;

   ////////////
   // internals

   //var STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };
   //var state = STATE.NONE;

   var startObject; // drag start
   var endObject;   // drag end

   var mouseOver; // where the mouse is at

   var scope = this;
   var labelScale = '15.0';

   var state = StateMachine.create({
      initial: { state: 'idle', event: 'init', defer: true },

      events: [
         // Start events
         { name: 'starttouch',  from: 'idle',   to: 'touch'  },
            { name: 'touchtodrag',   from: 'touch',  to: 'drag'   }, // LMB; Dragging with initial target
            { name: 'touchtorotate', from: 'touch',  to: 'rotate' }, // LMB; Dragging without initial target
            { name: 'touchtodolly',  from: 'touch',  to: 'dolly'  }, // MMB; Dollying (zooming)
            { name: 'touchtopan',    from: 'touch',  to: 'pan'    }, // RMB; Panning

         { name: 'startdolly',  from: 'idle',   to: 'dolly'  },
         { name: 'startpan',    from: 'idle',   to: 'pan' },

         // Stop events
         { name: 'idle', from: ['*'], to: 'idle' }

      ],

      callbacks: {

         onentertouch: function( stateEvent, from, to, event ) {
            if ( scope.enabled === false ) { return; }
            if ( scope.requireAlt === true && event.altKey === false ) { return; }
            event.preventDefault();
            if ( scope.debug ) {
               console.log( stateEvent, ": entered state", to, "from", from );
            }

            var intersect;

            if ( event.button === 0 ) { // left mouse

               // If the click starts on an object, we're dragging from
               // that object (possibly to another object) so we take
               // note of that object and switch to the drag state
               intersect = scope.getIntersect( event );
               if ( intersect && intersect.object.parent.userData.system ) {
                  startObject = intersect.object.parent.userData.system;
                  if ( scope.debug ) {
                     console.log( 'Click at "' + intersect.object.parent.userData.system.name + '"' );
                  }
                  window.map.setSelectionTo( startObject );
                  startObject.displayInfo( 'doNotSwitch' );
                  this.touchtodrag( event );
               }
               else if ( ! scope.noRotate )
               {
                  // If the click starts in empty space, we're just going to
                  // the mode for rotating the camera around the scene as
                  // that is the easiest thing to do
                  if ( scope.noRotate === true ) { return; }
                  rotateStart.set( event.clientX, event.clientY );
                  this.touchtorotate( event );
               }

            } else if ( event.button === 1 ) { // middle mouse

               if ( scope.noZoom === true ) { return; }
               dollyStart.set( event.clientX, event.clientY );
               this.touchtodolly( event );

            }

            if ( event.button === 2 || (scope.noRotate && ! intersect) ) { // right mouse

               if ( scope.noPan === true ) { return; }
               panStart.set( event.clientX, event.clientY );
               this.touchtopan( event );

            }
         },

         onenteridle: function( stateEvent, from, to, event ) {
            if ( scope.debug ) {
               console.log( stateEvent, ": idling after", from );
            }
            if ( from === 'drag' ) {
               var intersect = scope.getIntersect( event );
               if ( intersect && intersect.object.parent.userData.system ) {
                  endObject = intersect.object.parent.userData.system;
                  if ( window.map.selected() === endObject ) {
                     endObject.displayInfo();
                  }
                  if ( scope.debug ) {
                     console.log( 'Ended dragging at "' + intersect.object.parent.userData.system.name + '"' );
                  }
               }
            }
            startObject = undefined;
            endObject = undefined;
            if ( scope.debug ) {
               console.log( 'idling ...' );
            }
         },

      },

      //error: function( eventName, from, to, args, errorCode, errorMessage ) {
      //   scope.debug && console.log( 'event ' + eventName + ' was naughty : ' + errorMessage );
      //}
   });

   var EPS = 0.000001;

   var rotateStart = new THREE.Vector2();
   var rotateEnd = new THREE.Vector2();
   var rotateDelta = new THREE.Vector2();

   var panStart = new THREE.Vector2();
   var panEnd = new THREE.Vector2();
   var panDelta = new THREE.Vector2();

   var dollyStart = new THREE.Vector2();
   var dollyEnd = new THREE.Vector2();
   var dollyDelta = new THREE.Vector2();

   var mousePrevious = new THREE.Vector2();

   var phiDelta = 0;
   var thetaDelta = 0;
   var scale = 1;
   var pan = new THREE.Vector3();

   var lastPosition = new THREE.Vector3();
   var targetTween;
   var rotationTween;
   var rotationLeft;
   var rotationUp;
   var rotationRadius;

   // events

   var changeEvent = { type: 'change' };

   this.stateMachine = function () {
      return state;
   };

   this.showState = function () {
      if ( window.jQuery && window.jQuery('#debug-state') ) {
         window.jQuery('#debug-state').text( 'State: ' + state.current );
      }
   };

   this.rotateLeft = function ( angle ) {
      if ( angle === undefined ) {
         angle = getAutoRotationAngle();
      }
      thetaDelta -= angle;
   };

   this.rotateUp = function ( angle ) {
      if ( angle === undefined ) {
         angle = getAutoRotationAngle();
      }
      phiDelta -= angle;
   };

   // pass in distance in world space to move left
   this.panLeft = function ( distance ) {

      var panOffset = new THREE.Vector3();
      var te = this.object.matrix.elements;
      // get X column of matrix
      panOffset.set( te[0], te[1], te[2] );
      panOffset.multiplyScalar(-distance);

      pan.add( panOffset );
   };

   // pass in distance in world space to move up
   this.panUp = function ( distance ) {

      if ( this.mapMode ) {
         return this.panBack( distance );
      }
      var panOffset = new THREE.Vector3();
      var te = this.object.matrix.elements;
      // get Y column of matrix
      panOffset.set( te[4], te[5], te[6] );
      panOffset.multiplyScalar(distance);

      pan.add( panOffset );
   };

   // pass in distance in world space to move forward
   this.panBack = function ( distance ) {

      var sameLevelTarget = this.target.clone().setY( this.object.position.y );
      var vectorBack = this.object.position.clone().sub( sameLevelTarget ).negate().setLength( distance );

      pan.add( vectorBack );
   };

   // assumes mapMode for now
   this.moveTo = function ( destination ) {

      var _this = this;
      var traverse = this.target.clone();
      var destinationVector;

      // makes sure the destination is at the same xz plane
      if ( destination instanceof SCMAP.System ) {
         destinationVector = destination.position.clone().setY( this.target.y );
      } else if ( destination instanceof THREE.Vector3 ) {
         destinationVector = destination.clone().setY( this.target.y );
      } else {
         return;
      }

      if ( destination instanceof SCMAP.System ) {
         window.map.setSelectionTo( destination );
      }

      if ( targetTween ) {
         targetTween.stop();
      }

      targetTween = new TWEEN.Tween( traverse )
         .to( { x: destinationVector.x, y: destinationVector.y, z: destinationVector.z }, 750 )
         .easing( TWEEN.Easing.Cubic.InOut )
         .onUpdate( function () {
            var vec = new THREE.Vector3( this.x, this.y, this.z );
            _this.goTo( vec );
         } );

      targetTween.onComplete( function() {
         targetTween = undefined;
      });

      targetTween.start();
   };

   this.rememberPosition = function rememberPosition() {
      SCMAP.settings.camera.camera = this.object.position;
      SCMAP.settings.camera.target = this.target;
      SCMAP.settings.save( 'camera' );
   };

   // assumes mapMode for now
   this.rotateTo = function ( left, up, radius ) {

      var _this = this;
      var offset = this.objectVectorToTarget();
      // angle from z-axis around y-axis
      var theta = Math.atan2( offset.x, offset.z );
      // angle from y-axis
      var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );
      var rotate = {
         left: theta,
         up: phi,
         radius: offset.length()
      };

      rotateLeft = rotate.left;
      rotateUp   = rotate.up;

      if ( rotationTween ) {
         rotationTween.stop();
      }

      rotationTween = new TWEEN.Tween( rotate )
         .to( { left: left, up: up, radius: radius }, 1000 )
         .easing( TWEEN.Easing.Cubic.InOut )
         .onUpdate( function () {
            rotationLeft   = this.left;
            rotationUp     = this.up;
            rotationRadius = this.radius;
         });

      rotationTween.onComplete( function() {
         rotationTween  = undefined;
         rotationLeft   = undefined;
         rotationUp     = undefined;
         rotationRadius = undefined;
      });

      rotationTween.start();
   };

   this.cameraTo = function ( target, theta, phi, radius ) {
      this.rotateTo( theta, phi, radius );
      this.moveTo( target );
   };


   // assumes mapMode for now
   this.goTo = function ( vector ) {

      // make sure the given vector is at the same xz plane
      vector = vector.clone().setY( this.target.y );
      vector.sub( this.target );
      pan.add( vector );
   };

   // main entry point; pass in Vector2 of change desired in pixel space,
   // right and down are positive
   this.pan = function ( delta ) {

      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

      if ( scope.object.fov !== undefined ) {

         // perspective
         var targetDistance = scope.objectVectorToTarget().length();
         var yDistance;

         // half of the fov is center to top of screen
         targetDistance *= Math.tan( (scope.object.fov/2) * Math.PI / 180.0 );
         // we actually don't use screenWidth, since perspective camera is fixed to screen height
         scope.panLeft( 2 * delta.x * targetDistance / element.clientHeight );
         scope.panUp( 2 * delta.y * targetDistance / element.clientHeight );

      } else if ( scope.object.top !== undefined ) {

         // orthographic
         scope.panLeft( delta.x * (scope.object.right - scope.object.left) / element.clientWidth );
         scope.panUp( delta.y * (scope.object.top - scope.object.bottom) / element.clientHeight );

      } else {

         // camera neither orthographic or perspective - warn user
         console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );

      }

   };

   this.dollyIn = function ( dollyScale ) {
      if ( dollyScale === undefined ) {
         dollyScale = getZoomScale();
      }

      scale /= dollyScale;
   };

   this.dollyOut = function ( dollyScale ) {
      if ( dollyScale === undefined ) {
         dollyScale = getZoomScale();
      }

      scale *= dollyScale;
   };

   // TODO: Move to map
   this.getIntersect = function ( event ) {
      if ( !window.map.interactables() ) { return; }
      var vector, projector, raycaster, intersects;
      vector = new THREE.Vector3( (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5 );
      projector = new THREE.Projector();
      projector.unprojectVector( vector, scope.object );
      raycaster = new THREE.Raycaster( scope.object.position, vector.sub( scope.object.position ).normalize() );
      intersects = raycaster.intersectObjects( window.map.interactables() );
      return intersects[0];
   };

   this.objectVectorToTarget = function () {
      return this.object.position.clone().sub( this.target );
   };

   this.update = function () {

      var offset = this.objectVectorToTarget();

      // move target to panned location
      this.target.add( pan );

      // angle from z-axis around y-axis
      var theta = Math.atan2( offset.x, offset.z );

      // angle from y-axis
      var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );

      theta += thetaDelta;
      phi += phiDelta;

      if ( rotationLeft !== undefined ) {
         theta = rotationLeft;
      }
      if ( rotationUp !== undefined ) {
         phi = rotationUp;
      }

      // restrict phi to be between desired limits
      phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );

      // restrict phi to be between EPS and PI-EPS
      phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );

      var radius = offset.length() * scale;
      if ( rotationRadius !== undefined ) {
         radius = rotationRadius;
      }

      $('#debug-angle').html(
         'Camera heading: '+THREE.Math.radToDeg( theta ).toFixed(1)+'&deg;<br>'+
         'Camera tilt: '+THREE.Math.radToDeg( phi ).toFixed(1)+'&deg;<br>'+
         'Camera distance: '+radius.toFixed(1)
      );

      var newLabelScale = radius - 20;
      newLabelScale /= 10;
      if ( newLabelScale < 17 ) {
         newLabelScale = 17;
      } else if ( newLabelScale > 22 ) {
         newLabelScale = 22;
      }
      if ( newLabelScale.toFixed(1) !== labelScale ) {
         window.map.setAllLabelSizes( new THREE.Vector3( newLabelScale, newLabelScale, 1 ) );
         labelScale = newLabelScale.toFixed(1);
      }

      // restrict radius to be between desired limits
      radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );

      offset.x = radius * Math.sin( phi ) * Math.sin( theta );
      offset.y = radius * Math.cos( phi );
      offset.z = radius * Math.sin( phi ) * Math.cos( theta );

      this.object.position.copy( this.target ).add( offset );

      this.object.lookAt( this.target );

      thetaDelta = 0;
      phiDelta = 0;
      scale = 1;
      pan.set( 0, 0, 0 );

      if ( lastPosition.distanceTo( this.object.position ) > 0 ) {
         this.dispatchEvent( changeEvent );
         lastPosition.copy( this.object.position );
      }

      this.showState();
      this.rememberPosition();
   };

   function getZoomScale() {
      return Math.pow( 0.95, scope.zoomSpeed );
   }

   function onMouseDown( event ) {
      if ( scope.enabled === false ) { return; }
      if ( scope.requireAlt === true && event.altKey === false ) { return; }
      event.preventDefault();
      state.starttouch( event );
      //scope.domElement.addEventListener( 'mousemove', onMouseMove, false );
      scope.domElement.addEventListener( 'mouseup', onMouseUp, false );
   }

   function onMouseMove( event ) {
      if ( scope.enabled === false ) return;
      if ( scope.requireAlt === true && event.altKey === false ) { return; }
      event.preventDefault();

      var intersect;
      var route;
      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

      //if ( state.current === 'idle' ) {

         // Mouse move on idle handling: highlighting systems, dragging waypoints on route

         if ( event.clientX !== mousePrevious.x && event.clientY !== mousePrevious.y ) {
            intersect = scope.getIntersect( event );
            if ( intersect && intersect.object.parent.userData.system && intersect.object.parent.userData.system !== mouseOver ) {
               mouseOver = intersect.object.parent.userData.system;
               window.map._mouseOverObject.position.copy( mouseOver.sceneObject.position );
               window.map._mouseOverObject.visible = true;
            } else {
               if ( !intersect || !intersect.object.parent.userData.system ) {
                  if ( mouseOver !== undefined ) {
                     window.map._mouseOverObject.position.set( 0, 0, 0 );
                     window.map._mouseOverObject.visible = false;
                  }
                  mouseOver = undefined;
               }
            }
         }

         mousePrevious.set( event.clientX, event.clientY );
         //return;

      //} else if ( state.current === 'touch' ) {

      if ( state.current === 'touch' ) {

         if ( event.button === 0 ) { // left mouse
            state.touchtorotate( event );
         } else if ( event.button === 1 ) { // middle mouse
            state.touchtodolly( event );
         } else if ( event.button === 2 ) { // right mouse
            state.touchtopan( event );
         }

      } else if ( state.current === 'drag' ) {

         if ( startObject ) {
            intersect = scope.getIntersect( event );
            if ( intersect && intersect.object.parent.userData.system && intersect.object.parent.userData.system !== startObject ) {
               if ( !endObject || endObject !== intersect.object.parent.userData.system ) {
                  endObject = intersect.object.parent.userData.system;
                  route = window.map.route();
                  route.start = startObject;
                  route.end = endObject;
                  route.update( endObject );
                  if ( scope.debug ) {
                     console.log( 'Intermediate object while dragging is "' + endObject.name + '"' );
                  }
               }
            } else {
               endObject = undefined;
            }
         }

      } else if ( state.current === 'rotate' ) {

         if ( scope.noRotate === true ) return;

         rotateEnd.set( event.clientX, event.clientY );
         rotateDelta.subVectors( rotateEnd, rotateStart );

         // rotating across whole screen goes 360 degrees around
         scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
         // rotating up and down along whole screen attempts to go 360, but limited to 180
         scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

         rotateStart.copy( rotateEnd );

      } else if ( state.current === 'dolly' ) {

         if ( scope.noZoom === true ) return;

         dollyEnd.set( event.clientX, event.clientY );
         dollyDelta.subVectors( dollyEnd, dollyStart );

         if ( dollyDelta.y > 0 ) {
            scope.dollyIn();
         } else {
            scope.dollyOut();
         }

         dollyStart.copy( dollyEnd );

      } else if ( state.current === 'pan' ) {

         if ( scope.noPan === true ) return;

         panEnd.set( event.clientX, event.clientY );
         panDelta.subVectors( panEnd, panStart );
         scope.pan( panDelta );
         panStart.copy( panEnd );

      }

      scope.update();

   }

   function onMouseUp( event ) {
      if ( scope.enabled === false ) return;
      if ( scope.requireAlt === true && event.altKey === false ) { return; }

      //scope.domElement.removeEventListener( 'mousemove', onMouseMove, false );
      scope.domElement.removeEventListener( 'mouseup', onMouseUp, false );

      state.idle( event );
   }

   function onMouseWheel( event ) {
      if ( scope.enabled === false || scope.noZoom === true ) return;
      if ( scope.requireAlt === true && event.altKey === false ) { return; }

      // This doesn't need the state machine, as there's no conflict between
      // various possible actions here

      var delta = 0;

      if ( event.deltaY ) { // jquery-mousewheel
         delta = event.deltaY;
      } else if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9
         delta = event.wheelDelta;
      } else if ( event.detail ) { // Firefox
         delta = - event.detail;
      }

      if ( delta > 0 ) {
         scope.dollyOut();
      } else {
         scope.dollyIn();
      }
   }

   function onKeyDown( event ) {
      if ( scope.enabled === false ) { return; }
      if ( scope.noKeys === true ) { return; }
      if ( scope.noPan === true ) { return; }
      if ( scope.requireAlt === true && event.altKey === false ) { return; }
      // TODO: allow modifiers at all?
      if ( event.altKey === true || event.shiftKey === true || event.ctrlKey === true || event.metaKey === true ) { return; }

      var $activeElement = $( document.activeElement );
      if ( $activeElement.attr( 'id' ) === 'comments' ) {
         if ( event.keyCode == scope.keys.ESCAPE || event.keyCode == scope.keys.TAB ) {
            $activeElement.blur();
         }
         return;
      }

      // This doesn't need the state machine, as there's no conflict between
      // various possible actions here

      // pan a pixel - I guess for precise positioning?
      var needUpdate = false;
      switch ( event.keyCode ) {
         case scope.keys.UP:
            scope.pan( new THREE.Vector2( 0, scope.keyPanSpeed ) );
            needUpdate = true;
            break;
         case scope.keys.BOTTOM:
            scope.pan( new THREE.Vector2( 0, -scope.keyPanSpeed ) );
            needUpdate = true;
            break;
         case scope.keys.LEFT:
            scope.pan( new THREE.Vector2( scope.keyPanSpeed, 0 ) );
            needUpdate = true;
            break;
         case scope.keys.RIGHT:
            scope.pan( new THREE.Vector2( -scope.keyPanSpeed, 0 ) );
            needUpdate = true;
            break;
         case scope.keys.ESCAPE: // Deselect selected
            window.map.deselect();
            break;
         case scope.keys.TAB: // Tab through route
            // TODO
            break;
         case scope.keys.R: // Reset orientation
            scope.rotateTo( 0, undefined, undefined );
            break;
         case scope.keys.C: // Center on default
            scope.moveTo( SCMAP.settings.camera.target );
            break;
         case scope.keys.T: // Top view
            scope.rotateTo( 0, 0, 200 );
            break;
         case scope.keys['2']: // 2D mode
            scope.noRotate = true;
            $('#lock-rotation').prop( 'checked', true );
            displayState.to2d();
            scope.rotateTo( 0, 0, 180 );
            break;
         case scope.keys['3']: // 3D mode
            displayState.to3d();
            scope.rotateTo(
               SCMAP.settings.cameraDefaults.orientation.theta,
               SCMAP.settings.cameraDefaults.orientation.phi,
               SCMAP.settings.cameraDefaults.orientation.radius
            );
            break;
         case scope.keys.L: // Lock/unlock rotation
            $('#lock-rotation').click();
            break;
         default:
            //console.log( "onkeydown", event.keyCode );
            break;
      }

      if ( needUpdate ) {
         scope.update();
      }
   }

   function touchstart( event ) {
      if ( scope.enabled === false ) { return; }
      if ( scope.requireAlt === true && event.altKey === false ) { return; }

      //switch ( event.touches.length ) {

      //   case 1:  // one-fingered touch: rotate
      //      if ( scope.noRotate === true ) { return; }

      //      state = STATE.TOUCH_ROTATE;

      //      rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
      //      break;

      //   case 2:  // two-fingered touch: dolly
      //      if ( scope.noZoom === true ) { return; }

      //      state = STATE.TOUCH_DOLLY;

      //      var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
      //      var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
      //      var distance = Math.sqrt( dx * dx + dy * dy );
      //      dollyStart.set( 0, distance );
      //      break;

      //   case 3: // three-fingered touch: pan
      //      if ( scope.noPan === true ) { return; }

      //      state = STATE.TOUCH_PAN;

      //      panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
      //      break;

      //   default:
      //      state = STATE.NONE;
      //}
   }

   function touchmove( event ) {

      if ( scope.enabled === false ) { return; }
      if ( scope.requireAlt === true && event.altKey === false ) { return; }

      event.preventDefault();
      event.stopPropagation();

      //var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

      //switch ( event.touches.length ) {

      //   case 1: // one-fingered touch: rotate
      //      if ( scope.noRotate === true ) { return; }
      //      if ( state !== STATE.TOUCH_ROTATE ) { return; }

      //      rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
      //      rotateDelta.subVectors( rotateEnd, rotateStart );

      //      // rotating across whole screen goes 360 degrees around
      //      scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
      //      // rotating up and down along whole screen attempts to go 360, but limited to 180
      //      scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

      //      rotateStart.copy( rotateEnd );
      //      break;

      //   case 2: // two-fingered touch: dolly
      //      if ( scope.noZoom === true ) { return; }
      //      if ( state !== STATE.TOUCH_DOLLY ) { return; }

      //      var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
      //      var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
      //      var distance = Math.sqrt( dx * dx + dy * dy );

      //      dollyEnd.set( 0, distance );
      //      dollyDelta.subVectors( dollyEnd, dollyStart );

      //      if ( dollyDelta.y > 0 ) {

      //         scope.dollyOut();

      //      } else {

      //         scope.dollyIn();

      //      }

      //      dollyStart.copy( dollyEnd );
      //      break;

      //   case 3: // three-fingered touch: pan
      //      if ( scope.noPan === true ) { return; }
      //      if ( state !== STATE.TOUCH_PAN ) { return; }

      //      panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
      //      panDelta.subVectors( panEnd, panStart );

      //      scope.pan( panDelta );

      //      panStart.copy( panEnd );
      //      break;

      //   default:
      //      state = STATE.NONE;

      //}

   }

   function touchend ( event ) {
      if ( scope.enabled === false ) { return; }
      state.idle( event );
   }

   state.init();

   this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
   this.domElement.addEventListener( 'mousedown', onMouseDown, false );
   this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );
   this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox

   // We need to trigger jquery-mousewheel explicitly, or the WebGL view doesn't
   // get any mousewheel events
   $( this.domElement ).on( 'mousewheel', onMouseWheel );
   $( this.domElement ).on( 'mouseenter', function ( event ) { state.idle( event ); });

   //this.domElement.addEventListener( 'keydown', onKeyDown, false );
   window.addEventListener( 'keydown', onKeyDown, false );
   //$( this.domElement ).on( 'keydown', onKeyDown );

   this.domElement.addEventListener( 'touchstart', touchstart, false );
   this.domElement.addEventListener( 'touchend', touchend, false );
   this.domElement.addEventListener( 'touchmove', touchmove, false );

   this.domElement.addEventListener( 'mousemove', onMouseMove, false );
};

SCMAP.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );

var effectFXAA, camera, scene, renderer, composer, map, dpr,
   shift, ctrl, alt, controls, editor, stats, displayState, ui,
   storage;

$(function() {
   if ( ! Detector.webgl ) {
      Detector.addGetWebGLMessage();
   }

   init();
   animate();
});

function init()
{
   var container, renderModel, effectCopy, effectBloom;
   var width = window.innerWidth;
   var height = window.innerHeight;

   if ( hasLocalStorage() ) {
      storage = window.localStorage;
   }

   dpr = 1;
   if ( window.devicePixelRatio !== undefined ) {
      dpr = window.devicePixelRatio;
   }

   container = document.getElementById( 'webgl-container' );

   camera = new THREE.PerspectiveCamera( 45, width / height, 10, 1600 );
   camera.position.copy( SCMAP.settings.camera.camera );
   camera.setViewOffset( width, height, -( $('#map_ui').width() / 2 ), 0, width, height );

   controls = new SCMAP.OrbitControls( camera, container );
   controls.target.copy( SCMAP.settings.camera.target );
   controls.rotateSpeed = $('#gl-info').data('rotateSpeed');
   controls.zoomSpeed = $('#gl-info').data('zoomSpeed');
   controls.panSpeed = $('#gl-info').data('panSpeed');
   controls.addEventListener( 'change', render );
   controls.noRotate = SCMAP.settings.control.rotationLocked;

   scene = new THREE.Scene();

   renderer = new THREE.WebGLRenderer( { antialias: true } );
   if ( ! SCMAP.settings.effect.Antialias ) {
      renderer.autoClear = false;
   }
   renderer.setClearColor( 0x000000, 1 );
   renderer.setSize( window.innerWidth, window.innerHeight );

   container.appendChild( renderer.domElement );

   map = new SCMAP.Map( scene );
   map.populateScene();
   scene.add( map.buildReferenceGrid() );

   ui = new SCMAP.UI();

   // Stats

   stats = new Stats();
   stats.domElement.style.position = 'absolute';
   stats.domElement.style.top = '0px';
   stats.domElement.style.right = '0px';
   stats.domElement.style.display = 'none';
   stats.domElement.style.zIndex = '100';
   container.appendChild( stats.domElement );
   if ( SCMAP.settings.renderer.Stats ) {
      $('#stats').show();
   }

   // Event handlers

   window.addEventListener( 'resize', onWindowResize, false );
   document.addEventListener( 'change', render );

   // Rendering

   if ( ! SCMAP.settings.effect.Antialias )
   {
      renderModel = new THREE.RenderPass( scene, camera );

      effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
      effectFXAA.uniforms.resolution.value.set( 1 / (width * dpr), 1 / (height * dpr) );
      effectFXAA.enabled = SCMAP.settings.effect.FXAA;

      effectBloom = new THREE.BloomPass( 0.6 );
      effectBloom.enabled = SCMAP.settings.effect.Bloom;

      effectCopy = new THREE.ShaderPass( THREE.CopyShader );
      effectCopy.renderToScreen = true;

      composer = new THREE.EffectComposer( renderer );
      composer.setSize( width * dpr, height * dpr );
      composer.addPass( renderModel );
      composer.addPass( effectFXAA );
      composer.addPass( effectBloom );
      composer.addPass( effectCopy );
   }

   displayState = buildDisplayModeFSM( SCMAP.settings.mode );
}

function smokeTest () {
   var smokeParticles = new THREE.Geometry();
   for (i = 0; i < 25; i++) {
       var particle = new THREE.Vector3( Math.random() * 8, Math.random() * 10 + 5, Math.random() * 8 );
       smokeParticles.vertices.push( particle );
   }
   var smokeTexture = THREE.ImageUtils.loadTexture('images/smoke.png');
   var smokeMaterial = new THREE.ParticleBasicMaterial({
      map: smokeTexture,
      transparent: true,
      blending: THREE.AdditiveBlending,
      size: 25,
      color: 0x111111
   });
   
   var smoke = new THREE.ParticleSystem(smokeParticles, smokeMaterial);
   smoke.sortParticles = true;
   smoke.position.x = 10;
   
   scene.add(smoke);
}

function buildCross () {
   var material = new THREE.MeshBasicMaterial( { wireframe: true, color: 0xFF0000, linewidth: 1 } );
   var group = new THREE.Object3D();
   var geo = new THREE.Geometry();
   geo.vertices.push( new THREE.Vector3( -50, 1, 0 ) );
   geo.vertices.push( new THREE.Vector3( 50, 1, 0 ) );
   var cross = new THREE.Line( geo, material );
   group.add( cross );
   geo = new THREE.Geometry();
   var material2 = new THREE.MeshBasicMaterial( { wireframe: true, color: 0xF0F000, linewidth: 1 } );
   geo.vertices.push( new THREE.Vector3( 0, 1, -50 ) );
   geo.vertices.push( new THREE.Vector3( 0, 1, 50 ) );
   cross = new THREE.Line( geo, material2 );
   group.add( cross );
   var material3 = new THREE.MeshBasicMaterial( { wireframe: true, color: 0x0000F0, linewidth: 1 } );
   geo = new THREE.Geometry();
   geo.vertices.push( new THREE.Vector3( 0, -50, 0 ) );
   geo.vertices.push( new THREE.Vector3( 0, 50, 0 ) );
   cross = new THREE.Line( geo, material3 );
   group.add( cross );
   return group;
}

Object.values = function (obj ) {
    var vals = [];
    for ( var key in obj ) {
        if ( obj.hasOwnProperty(key) ) {
            vals.push( obj[key] );
        }
    }
    return vals;
};

function onWindowResize() {
   var width = window.innerWidth;
   var height = window.innerHeight;
   camera.aspect = width / height;
   camera.setViewOffset( width, height, -( $('#map_ui').width() / 2 ), 0, width, height );
   camera.updateProjectionMatrix();
   effectFXAA.uniforms.resolution.value.set( 1 / (width * dpr), 1 / (height * dpr) );
   renderer.setSize( width, height );
   if ( composer ) {
      composer.reset();
   }
}

function buildDisplayModeFSM ( initialState )
{
   var tweenTo2d, tweenTo3d, position, fsm;

   position = { y: ( initialState === '3d' ) ? 100 : 0.5 };

   tweenTo2d = new TWEEN.Tween( position )
      .to( { y: 0.5 }, 1000 )
      .easing( TWEEN.Easing.Cubic.InOut )
      .onUpdate( function () {
         map.route().removeFromScene(); // TODO: find a way to animate
         for ( var i = 0; i < scene.children.length; i++ ) {
            var child = scene.children[i];
            if ( typeof child.userData.scaleY === 'function' ) {
               child.userData.scaleY( child, this.y );
            }
         }
      } );

   tweenTo3d = new TWEEN.Tween( position )
      .to( { y: 100.0 }, 1000 )
      .easing( TWEEN.Easing.Cubic.InOut )
      .onUpdate( function () {
         map.route().removeFromScene(); // TODO: find a way to animate
         for ( var i = 0; i < scene.children.length; i++ ) {
            var child = scene.children[i];
            if ( typeof child.userData.scaleY === 'function' ) {
               child.userData.scaleY( child, this.y );
            }
         }
      } );

   fsm = StateMachine.create({
      initial: initialState || '3d',

      events: [
         { name: 'to2d',  from: '3d', to: '2d' },
         { name: 'to3d', from: '2d', to: '3d' }
      ],

      callbacks: {
         onenter2d: function() {
            $('#3d-mode').prop( 'checked', false );
            if ( storage ) { storage.mode = '2d'; }
         },

         onenter3d: function() {
            $('#3d-mode').prop( 'checked', true );
            if ( storage ) { storage.mode = '3d'; }
         },

         onleave2d: function() {
            tweenTo3d.onComplete( function() {
               fsm.transition();
               map.route().update();
            });
            tweenTo3d.start();
            return StateMachine.ASYNC;
         },

         onleave3d: function() {
            tweenTo2d.onComplete( function() {
               fsm.transition();
               map.route().update();
            });
            tweenTo2d.start();
            return StateMachine.ASYNC;
         },
      },

      error: function( eventName, from, to, args, errorCode, errorMessage ) {
         console.log( 'event ' + eventName + ' was naughty : ' + errorMessage );
      }
   });

   return fsm;
}

//

function animate() {
   requestAnimationFrame( animate );
   TWEEN.update();
   if ( controls !== undefined ) {
      controls.update();
   }
   if ( editor !== undefined ) {
      editor.update();
   }
   stats.update();
   render();
}

function render() {

   scene.updateMatrixWorld();
   scene.traverse( function ( object ) {
      if ( object instanceof THREE.LOD ) {
         object.update( camera );
      }
      // Needed for the shader glow:
      //if ( object.userData.isGlow ) {
      //   object.material.uniforms.viewVector.value = new THREE.Vector3().subVectors( camera.position, object.parent.position );
      //}
   } );

   map.animateSelector();

   if ( composer ) {
      renderer.clear();
      composer.render();
   } else {
      renderer.render( scene, camera );
   }
}

function hasLocalStorage() {
   try {
      return 'localStorage' in window && window.localStorage !== null;
   } catch(e) {
      return false;
   }
}

jQuery.fn.outerHtml = function() {
     return jQuery('<div />').append(this.eq(0).clone()).html();
};

function humanSort( a, b ) {
   var x, cmp1, cmp2;
   var aa = a.name.split(/(\d+)/);
   var bb = b.name.split(/(\d+)/);

   for ( x = 0; x < Math.max( aa.length, bb.length ); x++ )
   {
      if ( aa[x] != bb[x] )
      {
         cmp1 = ( isNaN( parseInt( aa[x], 10 ) ) ) ? aa[x] : parseInt( aa[x], 10 );
         cmp2 = ( isNaN( parseInt( bb[x], 10 ) ) ) ? bb[x] : parseInt( bb[x], 10 );

         if ( cmp1 === undefined || cmp2 === undefined ) {
            return aa.length - bb.length;
         } else {
            return ( cmp1 < cmp2 ) ? -1 : 1;
         }
      }
   }

   return 0;
}

// End of file
