"format global";
(function(global) {

  var defined = {};

  // indexOf polyfill for IE8
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  var getOwnPropertyDescriptor = true;
  try {
    Object.getOwnPropertyDescriptor({ a: 0 }, 'a');
  }
  catch(e) {
    getOwnPropertyDescriptor = false;
  }

  var defineProperty;
  (function () {
    try {
      if (!!Object.defineProperty({}, 'a', {}))
        defineProperty = Object.defineProperty;
    }
    catch (e) {
      defineProperty = function(obj, prop, opt) {
        try {
          obj[prop] = opt.value || opt.get.call(obj);
        }
        catch(e) {}
      }
    }
  })();

  function register(name, deps, declare) {
    if (arguments.length === 4)
      return registerDynamic.apply(this, arguments);
    doRegister(name, {
      declarative: true,
      deps: deps,
      declare: declare
    });
  }

  function registerDynamic(name, deps, executingRequire, execute) {
    doRegister(name, {
      declarative: false,
      deps: deps,
      executingRequire: executingRequire,
      execute: execute
    });
  }

  function doRegister(name, entry) {
    entry.name = name;

    // we never overwrite an existing define
    if (!(name in defined))
      defined[name] = entry;

    // we have to normalize dependencies
    // (assume dependencies are normalized for now)
    // entry.normalizedDeps = entry.deps.map(normalize);
    entry.normalizedDeps = entry.deps;
  }


  function buildGroups(entry, groups) {
    groups[entry.groupIndex] = groups[entry.groupIndex] || [];

    if (indexOf.call(groups[entry.groupIndex], entry) != -1)
      return;

    groups[entry.groupIndex].push(entry);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];

      // not in the registry means already linked / ES6
      if (!depEntry || depEntry.evaluated)
        continue;

      // now we know the entry is in our unlinked linkage group
      var depGroupIndex = entry.groupIndex + (depEntry.declarative != entry.declarative);

      // the group index of an entry is always the maximum
      if (depEntry.groupIndex === undefined || depEntry.groupIndex < depGroupIndex) {

        // if already in a group, remove from the old group
        if (depEntry.groupIndex !== undefined) {
          groups[depEntry.groupIndex].splice(indexOf.call(groups[depEntry.groupIndex], depEntry), 1);

          // if the old group is empty, then we have a mixed depndency cycle
          if (groups[depEntry.groupIndex].length == 0)
            throw new TypeError("Mixed dependency cycle detected");
        }

        depEntry.groupIndex = depGroupIndex;
      }

      buildGroups(depEntry, groups);
    }
  }

  function link(name) {
    var startEntry = defined[name];

    startEntry.groupIndex = 0;

    var groups = [];

    buildGroups(startEntry, groups);

    var curGroupDeclarative = !!startEntry.declarative == groups.length % 2;
    for (var i = groups.length - 1; i >= 0; i--) {
      var group = groups[i];
      for (var j = 0; j < group.length; j++) {
        var entry = group[j];

        // link each group
        if (curGroupDeclarative)
          linkDeclarativeModule(entry);
        else
          linkDynamicModule(entry);
      }
      curGroupDeclarative = !curGroupDeclarative; 
    }
  }

  // module binding records
  var moduleRecords = {};
  function getOrCreateModuleRecord(name) {
    return moduleRecords[name] || (moduleRecords[name] = {
      name: name,
      dependencies: [],
      exports: {}, // start from an empty module and extend
      importers: []
    })
  }

  function linkDeclarativeModule(entry) {
    // only link if already not already started linking (stops at circular)
    if (entry.module)
      return;

    var module = entry.module = getOrCreateModuleRecord(entry.name);
    var exports = entry.module.exports;

    var declaration = entry.declare.call(global, function(name, value) {
      module.locked = true;

      if (typeof name == 'object') {
        for (var p in name)
          exports[p] = name[p];
      }
      else {
        exports[name] = value;
      }

      for (var i = 0, l = module.importers.length; i < l; i++) {
        var importerModule = module.importers[i];
        if (!importerModule.locked) {
          for (var j = 0; j < importerModule.dependencies.length; ++j) {
            if (importerModule.dependencies[j] === module) {
              importerModule.setters[j](exports);
            }
          }
        }
      }

      module.locked = false;
      return value;
    }, entry.name);

    module.setters = declaration.setters;
    module.execute = declaration.execute;

    // now link all the module dependencies
    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];
      var depModule = moduleRecords[depName];

      // work out how to set depExports based on scenarios...
      var depExports;

      if (depModule) {
        depExports = depModule.exports;
      }
      else if (depEntry && !depEntry.declarative) {
        depExports = depEntry.esModule;
      }
      // in the module registry
      else if (!depEntry) {
        depExports = load(depName);
      }
      // we have an entry -> link
      else {
        linkDeclarativeModule(depEntry);
        depModule = depEntry.module;
        depExports = depModule.exports;
      }

      // only declarative modules have dynamic bindings
      if (depModule && depModule.importers) {
        depModule.importers.push(module);
        module.dependencies.push(depModule);
      }
      else
        module.dependencies.push(null);

      // run the setter for this dependency
      if (module.setters[i])
        module.setters[i](depExports);
    }
  }

  // An analog to loader.get covering execution of all three layers (real declarative, simulated declarative, simulated dynamic)
  function getModule(name) {
    var exports;
    var entry = defined[name];

    if (!entry) {
      exports = load(name);
      if (!exports)
        throw new Error("Unable to load dependency " + name + ".");
    }

    else {
      if (entry.declarative)
        ensureEvaluated(name, []);

      else if (!entry.evaluated)
        linkDynamicModule(entry);

      exports = entry.module.exports;
    }

    if ((!entry || entry.declarative) && exports && exports.__useDefault)
      return exports['default'];

    return exports;
  }

  function linkDynamicModule(entry) {
    if (entry.module)
      return;

    var exports = {};

    var module = entry.module = { exports: exports, id: entry.name };

    // AMD requires execute the tree first
    if (!entry.executingRequire) {
      for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
        var depName = entry.normalizedDeps[i];
        var depEntry = defined[depName];
        if (depEntry)
          linkDynamicModule(depEntry);
      }
    }

    // now execute
    entry.evaluated = true;
    var output = entry.execute.call(global, function(name) {
      for (var i = 0, l = entry.deps.length; i < l; i++) {
        if (entry.deps[i] != name)
          continue;
        return getModule(entry.normalizedDeps[i]);
      }
      throw new TypeError('Module ' + name + ' not declared as a dependency.');
    }, exports, module);

    if (output)
      module.exports = output;

    // create the esModule object, which allows ES6 named imports of dynamics
    exports = module.exports;
 
    if (exports && exports.__esModule) {
      entry.esModule = exports;
    }
    else {
      entry.esModule = {};
      
      // don't trigger getters/setters in environments that support them
      if ((typeof exports == 'object' || typeof exports == 'function') && exports !== global) {
        if (getOwnPropertyDescriptor) {
          var d;
          for (var p in exports)
            if (d = Object.getOwnPropertyDescriptor(exports, p))
              defineProperty(entry.esModule, p, d);
        }
        else {
          var hasOwnProperty = exports && exports.hasOwnProperty;
          for (var p in exports) {
            if (!hasOwnProperty || exports.hasOwnProperty(p))
              entry.esModule[p] = exports[p];
          }
         }
       }
      entry.esModule['default'] = exports;
      defineProperty(entry.esModule, '__useDefault', {
        value: true
      });
    }
  }

  /*
   * Given a module, and the list of modules for this current branch,
   *  ensure that each of the dependencies of this module is evaluated
   *  (unless one is a circular dependency already in the list of seen
   *  modules, in which case we execute it)
   *
   * Then we evaluate the module itself depth-first left to right 
   * execution to match ES6 modules
   */
  function ensureEvaluated(moduleName, seen) {
    var entry = defined[moduleName];

    // if already seen, that means it's an already-evaluated non circular dependency
    if (!entry || entry.evaluated || !entry.declarative)
      return;

    // this only applies to declarative modules which late-execute

    seen.push(moduleName);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      if (indexOf.call(seen, depName) == -1) {
        if (!defined[depName])
          load(depName);
        else
          ensureEvaluated(depName, seen);
      }
    }

    if (entry.evaluated)
      return;

    entry.evaluated = true;
    entry.module.execute.call(global);
  }

  // magical execution function
  var modules = {};
  function load(name) {
    if (modules[name])
      return modules[name];

    // node core modules
    if (name.substr(0, 6) == '@node/')
      return require(name.substr(6));

    var entry = defined[name];

    // first we check if this module has already been defined in the registry
    if (!entry)
      throw "Module " + name + " not present.";

    // recursively ensure that the module and all its 
    // dependencies are linked (with dependency group handling)
    link(name);

    // now handle dependency execution in correct order
    ensureEvaluated(name, []);

    // remove from the registry
    defined[name] = undefined;

    // exported modules get __esModule defined for interop
    if (entry.declarative)
      defineProperty(entry.module.exports, '__esModule', { value: true });

    // return the defined module object
    return modules[name] = entry.declarative ? entry.module.exports : entry.esModule;
  };

  return function(mains, depNames, declare) {
    return function(formatDetect) {
      formatDetect(function(deps) {
        var System = {
          _nodeRequire: typeof require != 'undefined' && require.resolve && typeof process != 'undefined' && require,
          register: register,
          registerDynamic: registerDynamic,
          get: load, 
          set: function(name, module) {
            modules[name] = module; 
          },
          newModule: function(module) {
            return module;
          }
        };
        System.set('@empty', {});

        // register external dependencies
        for (var i = 0; i < depNames.length; i++) (function(depName, dep) {
          if (dep && dep.__esModule)
            System.register(depName, [], function(_export) {
              return {
                setters: [],
                execute: function() {
                  for (var p in dep)
                    if (p != '__esModule' && !(typeof p == 'object' && p + '' == 'Module'))
                      _export(p, dep[p]);
                }
              };
            });
          else
            System.registerDynamic(depName, [], false, function() {
              return dep;
            });
        })(depNames[i], arguments[i]);

        // register modules in this bundle
        declare(System);

        // load mains
        var firstLoad = load(mains[0]);
        if (mains.length > 1)
          for (var i = 1; i < mains.length; i++)
            load(mains[i]);

        if (firstLoad.__useDefault)
          return firstLoad['default'];
        else
          return firstLoad;
      });
    };
  };

})(typeof self != 'undefined' ? self : global)
/* (['mainModule'], ['external-dep'], function($__System) {
  System.register(...);
})
(function(factory) {
  if (typeof define && define.amd)
    define(['external-dep'], factory);
  // etc UMD / module pattern
})*/

(["1"], [], function($__System) {

(function() {
  var loader = $__System;
  
  if (typeof window != 'undefined' && typeof document != 'undefined' && window.location)
    var windowOrigin = location.protocol + '//' + location.hostname + (location.port ? ':' + location.port : '');

  loader.set('@@cjs-helpers', loader.newModule({
    getPathVars: function(moduleId) {
      // remove any plugin syntax
      var pluginIndex = moduleId.lastIndexOf('!');
      var filename;
      if (pluginIndex != -1)
        filename = moduleId.substr(0, pluginIndex);
      else
        filename = moduleId;

      var dirname = filename.split('/');
      dirname.pop();
      dirname = dirname.join('/');

      if (filename.substr(0, 8) == 'file:///') {
        filename = filename.substr(7);
        dirname = dirname.substr(7);

        // on windows remove leading '/'
        if (isWindows) {
          filename = filename.substr(1);
          dirname = dirname.substr(1);
        }
      }
      else if (windowOrigin && filename.substr(0, windowOrigin.length) === windowOrigin) {
        filename = filename.substr(windowOrigin.length);
        dirname = dirname.substr(windowOrigin.length);
      }

      return {
        filename: filename,
        dirname: dirname
      };
    }
  }));
})();

(function(__global) {
  var loader = $__System;
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  var commentRegEx = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;
  var cjsRequirePre = "(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])";
  var cjsRequirePost = "\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)";
  var fnBracketRegEx = /\(([^\)]*)\)/;
  var wsRegEx = /^\s+|\s+$/g;
  
  var requireRegExs = {};

  function getCJSDeps(source, requireIndex) {

    // remove comments
    source = source.replace(commentRegEx, '');

    // determine the require alias
    var params = source.match(fnBracketRegEx);
    var requireAlias = (params[1].split(',')[requireIndex] || 'require').replace(wsRegEx, '');

    // find or generate the regex for this requireAlias
    var requireRegEx = requireRegExs[requireAlias] || (requireRegExs[requireAlias] = new RegExp(cjsRequirePre + requireAlias + cjsRequirePost, 'g'));

    requireRegEx.lastIndex = 0;

    var deps = [];

    var match;
    while (match = requireRegEx.exec(source))
      deps.push(match[2] || match[3]);

    return deps;
  }

  /*
    AMD-compatible require
    To copy RequireJS, set window.require = window.requirejs = loader.amdRequire
  */
  function require(names, callback, errback, referer) {
    // in amd, first arg can be a config object... we just ignore
    if (typeof names == 'object' && !(names instanceof Array))
      return require.apply(null, Array.prototype.splice.call(arguments, 1, arguments.length - 1));

    // amd require
    if (typeof names == 'string' && typeof callback == 'function')
      names = [names];
    if (names instanceof Array) {
      var dynamicRequires = [];
      for (var i = 0; i < names.length; i++)
        dynamicRequires.push(loader['import'](names[i], referer));
      Promise.all(dynamicRequires).then(function(modules) {
        if (callback)
          callback.apply(null, modules);
      }, errback);
    }

    // commonjs require
    else if (typeof names == 'string') {
      var module = loader.get(names);
      return module.__useDefault ? module['default'] : module;
    }

    else
      throw new TypeError('Invalid require');
  }

  function define(name, deps, factory) {
    if (typeof name != 'string') {
      factory = deps;
      deps = name;
      name = null;
    }
    if (!(deps instanceof Array)) {
      factory = deps;
      deps = ['require', 'exports', 'module'].splice(0, factory.length);
    }

    if (typeof factory != 'function')
      factory = (function(factory) {
        return function() { return factory; }
      })(factory);

    // in IE8, a trailing comma becomes a trailing undefined entry
    if (deps[deps.length - 1] === undefined)
      deps.pop();

    // remove system dependencies
    var requireIndex, exportsIndex, moduleIndex;
    
    if ((requireIndex = indexOf.call(deps, 'require')) != -1) {
      
      deps.splice(requireIndex, 1);

      // only trace cjs requires for non-named
      // named defines assume the trace has already been done
      if (!name)
        deps = deps.concat(getCJSDeps(factory.toString(), requireIndex));
    }

    if ((exportsIndex = indexOf.call(deps, 'exports')) != -1)
      deps.splice(exportsIndex, 1);
    
    if ((moduleIndex = indexOf.call(deps, 'module')) != -1)
      deps.splice(moduleIndex, 1);

    var define = {
      name: name,
      deps: deps,
      execute: function(req, exports, module) {

        var depValues = [];
        for (var i = 0; i < deps.length; i++)
          depValues.push(req(deps[i]));

        module.uri = module.id;

        module.config = function() {};

        // add back in system dependencies
        if (moduleIndex != -1)
          depValues.splice(moduleIndex, 0, module);
        
        if (exportsIndex != -1)
          depValues.splice(exportsIndex, 0, exports);
        
        if (requireIndex != -1) 
          depValues.splice(requireIndex, 0, function(names, callback, errback) {
            if (typeof names == 'string' && typeof callback != 'function')
              return req(names);
            return require.call(loader, names, callback, errback, module.id);
          });

        var output = factory.apply(exportsIndex == -1 ? __global : exports, depValues);

        if (typeof output == 'undefined' && module)
          output = module.exports;

        if (typeof output != 'undefined')
          return output;
      }
    };

    // anonymous define
    if (!name) {
      // already defined anonymously -> throw
      if (lastModule.anonDefine)
        throw new TypeError('Multiple defines for anonymous module');
      lastModule.anonDefine = define;
    }
    // named define
    else {
      // if we don't have any other defines,
      // then let this be an anonymous define
      // this is just to support single modules of the form:
      // define('jquery')
      // still loading anonymously
      // because it is done widely enough to be useful
      if (!lastModule.anonDefine && !lastModule.isBundle) {
        lastModule.anonDefine = define;
      }
      // otherwise its a bundle only
      else {
        // if there is an anonDefine already (we thought it could have had a single named define)
        // then we define it now
        // this is to avoid defining named defines when they are actually anonymous
        if (lastModule.anonDefine && lastModule.anonDefine.name)
          loader.registerDynamic(lastModule.anonDefine.name, lastModule.anonDefine.deps, false, lastModule.anonDefine.execute);

        lastModule.anonDefine = null;
      }

      // note this is now a bundle
      lastModule.isBundle = true;

      // define the module through the register registry
      loader.registerDynamic(name, define.deps, false, define.execute);
    }
  }
  define.amd = {};

  // adds define as a global (potentially just temporarily)
  function createDefine(loader) {
    lastModule.anonDefine = null;
    lastModule.isBundle = false;

    // ensure no NodeJS environment detection
    var oldModule = __global.module;
    var oldExports = __global.exports;
    var oldDefine = __global.define;

    __global.module = undefined;
    __global.exports = undefined;
    __global.define = define;

    return function() {
      __global.define = oldDefine;
      __global.module = oldModule;
      __global.exports = oldExports;
    };
  }

  var lastModule = {
    isBundle: false,
    anonDefine: null
  };

  loader.set('@@amd-helpers', loader.newModule({
    createDefine: createDefine,
    require: require,
    define: define,
    lastModule: lastModule
  }));
  loader.amdDefine = define;
  loader.amdRequire = require;
})(typeof self != 'undefined' ? self : global);

"bundle";
$__System.register('2', ['3'], function (_export) {
  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mr.doob / http://mrdoob.com/
   */
  'use strict';

  var THREE, Detector;
  return {
    setters: [function (_) {
      THREE = _['default'];
    }],
    execute: function () {
      Detector = {

        canvas: !!window.CanvasRenderingContext2D,
        webgl: (function () {

          try {

            var canvas = document.createElement('canvas');return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
          } catch (e) {

            return false;
          }
        })(),
        workers: !!window.Worker,
        fileapi: window.File && window.FileReader && window.FileList && window.Blob,

        getWebGLErrorMessage: function getWebGLErrorMessage() {

          var element = document.createElement('div');
          element.id = 'webgl-error-message';
          element.style.fontFamily = 'monospace';
          element.style.fontSize = '13px';
          element.style.fontWeight = 'normal';
          element.style.textAlign = 'center';
          element.style.background = '#fff';
          element.style.color = '#000';
          element.style.padding = '1.5em';
          element.style.width = '400px';
          element.style.margin = '5em auto 0';

          if (!this.webgl) {

            element.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join('\n') : ['Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join('\n');
          }

          return element;
        },

        addGetWebGLMessage: function addGetWebGLMessage(parameters) {

          var parent, id, element;

          parameters = parameters || {};

          parent = parameters.parent !== undefined ? parameters.parent : document.body;
          id = parameters.id !== undefined ? parameters.id : 'oldie';

          element = Detector.getWebGLErrorMessage();
          element.id = id;

          parent.appendChild(element);
        }

      };

      _export('default', Detector);
    }
  };
});
$__System.register('4', ['5', '6', '7', '8', '9'], function (_export) {
  var travelTimeForAU, StarSystem, settings, _createClass, _classCallCheck, Dijkstra;

  return {
    setters: [function (_3) {
      travelTimeForAU = _3.travelTimeForAU;
    }, function (_4) {
      StarSystem = _4['default'];
    }, function (_5) {
      settings = _5['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      'use strict';

      Dijkstra = (function () {
        function Dijkstra(systems, start, end) {
          _classCallCheck(this, Dijkstra);

          if (!(typeof systems === 'object' && Array.isArray(systems))) {
            console.error('No array specified to Dijkstra constructor!');
            return;
          }

          this.start = start instanceof StarSystem ? start : null;
          this.end = this.start && end instanceof StarSystem ? end : null;

          // First build a list of all nodes in the graph and
          // map them by system.id so they can be found quickly
          this._nodes = [];
          this._mapping = {}; // system.id to _nodes map

          var i = systems.length;
          while (i--) {
            this._nodes[i] = {
              system: systems[i],
              distance: Number.POSITIVE_INFINITY,
              previous: null
            };
            this._mapping[systems[i].id] = this._nodes[i];
          }

          this._result = {};
        }

        _createClass(Dijkstra, [{
          key: 'buildGraph',
          value: function buildGraph(priority, forceUpdate) {
            var nodes = undefined,
                i = undefined,
                distance = undefined,
                system = undefined,
                currentNode = undefined,
                jumpPoint = undefined,
                otherNode = undefined,
                endTime = undefined,
                startTime = new Date();
            var distAU = undefined;

            if (!(this.start instanceof StarSystem)) {
              throw new Error('No source given');
            }
            if (!(this.end instanceof StarSystem)) {
              throw new Error('No or invalid destination given');
            }

            this._result.destination = this.end;
            // TODO: expiry, map may have changed
            if (!forceUpdate && this._result.source instanceof StarSystem && this._result.source === this.start && this._result.priority === priority) {
              //console.log( 'Reusing generated graph starting at', this._result.source.name );
              /////this._result.destination = this.end;
              return;
            }

            this.destroyGraph();
            this._result.source = this.start;
            this._result.destination = this.end;
            this._result.priority = priority;

            // Created using http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Pseudocode

            for (i = 0; i < this._nodes.length; i++) {
              this._nodes[i].distance = Number.POSITIVE_INFINITY;
              this._nodes[i].previous = null;
            }

            currentNode = this._mapping[this.start.id];
            currentNode.distance = 0; // distance from source to source
            currentNode.previous = null;

            nodes = Dijkstra.quickSort(this._nodes);

            while (nodes.length) {
              currentNode = nodes[0];

              // "If we are only interested in a shortest path between vertices source and
              //  target, we can terminate the search at line 13 if u = target."
              if (currentNode.system === this.end) {
                break;
              }

              // Remove currentNode (the first node) from set
              nodes.splice(0, 1);

              // Don't bother with th current node if it's not reachable
              if (Dijkstra.isInfinite(currentNode.distance)) {
                break;
              }

              //console.log( `Working on node ${ currentNode.system.name }, ${ currentNode.system.jumpPoints.length } jumppoints to test` );

              for (i = 0; i < currentNode.system.jumpPoints.length; i++) {
                jumpPoint = currentNode.system.jumpPoints[i];
                otherNode = this._mapping[jumpPoint.destination.id];

                // Don't take "unknown" and "undiscovered" jump points
                if (jumpPoint.isUnconfirmed() && settings.route.avoidUnknownJumppoints) {
                  continue;
                }

                // These checks are only done if they're not an explicit part of the route we're building
                // (which is essentially the user overriding the route)
                if (!this.isStartOrEnd(otherNode.system)) {
                  // Don't go into "hostile" nodes, unless we already are in one
                  if (settings.route.avoidHostile && !currentNode.system.faction.isHostileTo(settings.usersFaction) && otherNode.system.faction.isHostileTo(settings.usersFaction)) {
                    continue;
                  }

                  // Don't go into "off limits" nodes
                  if (settings.route.avoidOffLimits && otherNode.system.isOffLimits) {
                    continue;
                  }

                  // Don't go into "avoid" nodes, unless we already are in one
                  if (!currentNode.system.isToBeAvoided() && otherNode.system.isToBeAvoided()) {
                    continue;
                  }
                }

                // cost = half time to JP + JP time + half time from JP
                // TODO: at start and end this can be from start and to dest rather than half
                distance = currentNode.distance + jumpPoint.jumpTime();

                if (currentNode.previous === null) {
                  distance += travelTimeForAU(0.35); // FIXME
                } else {
                    distance += travelTimeForAU(0.7);
                  }

                // Get out of "never" nodes asap by increasing the cost massively
                if (settings.route.avoidHostile && otherNode.system.faction.isHostileTo(settings.usersFaction)) {
                  distance *= 15;
                }

                if (distance < otherNode.distance) {
                  otherNode.distance = distance;
                  otherNode.previous = currentNode;
                  nodes = Dijkstra.quickSort(nodes);
                }
              }
            }

            this._result.nodes = nodes;
            this._result.priority = priority;
            endTime = new Date();
            //console.log( 'Graph building took ' + (endTime.getTime() - startTime.getTime()) + ' msec' );
          }
        }, {
          key: 'isStartOrEnd',
          value: function isStartOrEnd(system) {
            if (!(system instanceof StarSystem)) {
              return false;
            }

            return system === this.start || system === this.end;
          }
        }, {
          key: 'firstNode',
          value: function firstNode() {
            var routeArray = this.routeArray();
            return routeArray[0];
          }
        }, {
          key: 'lastNode',
          value: function lastNode() {
            var routeArray = this.routeArray();
            return routeArray[routeArray.length - 1];
          }
        }, {
          key: 'source',
          value: function source() {
            if (this.start instanceof StarSystem) {
              return this.start;
            }
          }
        }, {
          key: 'destination',
          value: function destination() {
            if (this.end instanceof StarSystem) {
              return this.end;
            }
          }
        }, {
          key: 'rebuildGraph',
          value: function rebuildGraph() {
            //console.log( 'rebuildGraph from', source, 'to', destination );
            this.destroyGraph();

            if (this.start instanceof StarSystem) {
              this.buildGraph('time', true);
              return true;
            }
          }
        }, {
          key: 'destroyGraph',
          value: function destroyGraph() {
            this._result = {};
          }
        }, {
          key: 'routeArray',
          value: function routeArray(destination) {
            if (!(destination instanceof StarSystem)) {
              if (!(this._result.destination instanceof StarSystem)) {
                console.error('No or invalid destination specified.');
                return;
              }
              destination = this._result.destination;
            }

            if (this._result.nodes.length > 0) {
              // Get path and print it out, we're traversing backwards
              // through the optimal path for the destination
              var visited = [];
              var x = this._mapping[destination.id];
              var seen = {};
              while (x !== null) {
                seen[x.system.name] = true;
                visited.push(x);
                x = x.previous;
              }
              visited.reverse();
              return visited;
            }
          }
        }], [{
          key: 'quickSort',
          value: function quickSort(nodes) {
            // makes a copy, prevents overwriting
            var array = [];
            var i = nodes.length;
            while (i--) {
              array[i] = nodes[i];
            }

            if (array.length <= 1) {
              return array;
            }

            var lhs = [];
            var rhs = [];
            var pivot = Math.ceil(array.length / 2) - 1;

            pivot = array.splice(pivot, 1)[0];

            for (i = 0; i < array.length; i++) {
              if (array[i].distance <= pivot.distance) {
                lhs.push(array[i]);
              } else {
                rhs.push(array[i]);
              }
            }

            var t1 = Dijkstra.quickSort(lhs);
            var t2 = Dijkstra.quickSort(rhs);

            t1.push(pivot);
            return t1.concat(t2);
          }
        }, {
          key: 'isInfinite',
          value: function isInfinite(num) {
            return !isFinite(num);
          }
        }]);

        return Dijkstra;
      })();

      _export('default', Dijkstra);
    }
  };
});
$__System.register('a', ['3', '6', '7', '8', '9', 'b'], function (_export) {
  var THREE, StarSystem, settings, _createClass, _classCallCheck, config, startColour, endColour, JumpRouteGeometry;

  return {
    setters: [function (_5) {
      THREE = _5['default'];
    }, function (_4) {
      StarSystem = _4['default'];
    }, function (_3) {
      settings = _3['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_b) {
      config = _b['default'];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      'use strict';

      startColour = new THREE.Color(0xEEEE66);
      endColour = new THREE.Color(0xFF3322);

      JumpRouteGeometry = (function () {
        function JumpRouteGeometry(_ref) {
          var map = _ref.map;
          var route = _ref.route;
          var initialScale = _ref.initialScale;

          _classCallCheck(this, JumpRouteGeometry);

          this.map = map;
          this.route = route;
          this.initialScale = initialScale;
        }

        _createClass(JumpRouteGeometry, [{
          key: 'mesh',
          get: function get() {
            if (this._mesh) {
              return this._mesh;
            }

            var group = new THREE.Object3D();
            group.name = 'Jump Route Geometry';
            group.matrixAutoUpdate = false;
            group.dynamic = false;
            this._mesh = group;

            try {

              var entireRoute = this.route.currentRoute();

              for (var i = 0, entireRouteLength = entireRoute.length - 1; i < entireRouteLength; i += 1) {
                var from = entireRoute[i + 0].system.position;
                var to = entireRoute[i + 1].system.position;

                var geometry = JumpRouteGeometry.createSegmentGeometry(from, to);

                if (geometry) {
                  var alpha = this.route.alphaOfSystem(entireRoute[i + 1].system);
                  var material = new THREE.MeshBasicMaterial({ color: startColour.clone().lerp(endColour, alpha) });
                  var segment = new THREE.Mesh(geometry, material);
                  segment.position.copy(from);
                  segment.lookAt(to);
                  group.add(segment);
                }
              }

              if (this.route.start instanceof StarSystem) {
                var startIndicator = this.map._createSelectorObject(startColour);
                startIndicator.scale.set(3.8 * config.renderScale, 3.8 * config.renderScale, 3.8 * config.renderScale);
                startIndicator.position.copy(this.route.start.position);
                startIndicator.visible = true;
                group.add(startIndicator);

                for (var i = 0, waypointsLength = this.route.waypoints.length; i < waypointsLength; i += 1) {
                  var waypoint = this.route.waypoints[i];

                  if (waypoint instanceof StarSystem) {
                    var waypointIndicator = this.map._createSelectorObject(startColour.clone().lerp(endColour, this.route.alphaOfSystem(waypoint)));
                    waypointIndicator.scale.set(3.8 * config.renderScale, 3.8 * config.renderScale, 3.8 * config.renderScale);
                    waypointIndicator.position.copy(waypoint.position);
                    waypointIndicator.visible = true;
                    group.add(waypointIndicator);
                  }
                }
              }
            } catch (e) {
              console.error('Problem creating route geometry:', e);
              throw e;
            }

            // Set the 2d/3d tween callback
            group.userData.scaleY = JumpRouteGeometry.scaleY;
            JumpRouteGeometry.scaleY(group, this.initialScale);

            return group;
          }
        }], [{
          key: 'createSegmentGeometry',
          value: function createSegmentGeometry(source, destination) {
            var distance = source.distanceTo(destination);
            var geometry = new THREE.CylinderGeometry(0.6 * config.renderScale, 0.6 * config.renderScale, distance, 8, 1, true);
            geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, distance / 2, 0));
            geometry.applyMatrix(new THREE.Matrix4().makeRotationX(THREE.Math.degToRad(90)));
            return geometry;
          }
        }, {
          key: 'scaleY',
          value: function scaleY(mesh, _scaleY) {
            mesh.scale.y = _scaleY;
            mesh.updateMatrix();
          }
        }]);

        return JumpRouteGeometry;
      })();

      _export('default', JumpRouteGeometry);
    }
  };
});
$__System.register('c', ['1', '4', '5', '6', '8', '9', 'f', 'd', 'a', 'e'], function (_export) {
  var SCMAP, Dijkstra, hasSessionStorage, StarSystem, _createClass, _classCallCheck, _slicedToArray, scene, map, JumpRouteGeometry, RouteUI, Route;

  function RouteSegmentFailed(message) {
    this.message = message;
    this.name = 'RouteSegmentFailed';
  }
  return {
    setters: [function (_3) {
      SCMAP = _3['default'];
    }, function (_5) {
      Dijkstra = _5['default'];
    }, function (_6) {
      hasSessionStorage = _6.hasSessionStorage;
    }, function (_4) {
      StarSystem = _4['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_f) {
      _slicedToArray = _f['default'];
    }, function (_d) {
      scene = _d.scene;
      map = _d.map;
    }, function (_a) {
      JumpRouteGeometry = _a['default'];
    }, function (_e) {
      RouteUI = _e['default'];
    }],
    execute: function () {
      /**
        * @author Lianna Eeftinck / https://github.com/Leeft
        */

      'use strict';

      Route = (function () {
        function Route(start, waypoints) {
          var _this = this;

          _classCallCheck(this, Route);

          this.start = start instanceof StarSystem ? start : null;
          this.waypoints = [];
          this._graphs = [];
          this._routeObject = undefined;
          this._error = undefined;

          if (waypoints instanceof StarSystem) {
            waypoints = [waypoints];
          }

          if (Array.isArray(waypoints)) {
            waypoints.forEach(function (waypoint) {
              if (waypoint instanceof StarSystem) {
                _this.waypoints.push(waypoint);
              }
            });
          }

          this.__syncGraphs();
        }

        // Find the first matching graph or pair of graphs for the given
        // waypoint. Returns two graphs if the waypoint lies on the end
        // of one and the start of another

        _createClass(Route, [{
          key: '__findGraphs',
          value: function __findGraphs(system) {
            var _this2 = this;

            var graphs = [];
            var seen = {};

            var _loop = function (i, graphsLength) {
              var graph = _this2._graphs[i];

              var routeArray = [];
              try {
                routeArray = graph.routeArray();
              } catch (e) {
                console.error('Error getting route array: ' + e.message);
              }

              if (graphs.length) {
                if (routeArray[0].system.id === system.id) {
                  graphs.push(graph);
                  return {
                    v: graphs
                  };
                }
              }

              routeArray.forEach(function (waypoint) {
                if (waypoint.system === system && !seen[waypoint.system.id]) {
                  seen[waypoint.system.id] = true;
                  graphs.push(graph);
                }
              });
            };

            for (var i = 0, graphsLength = this._graphs.length; i < graphsLength; i += 1) {
              var _ret = _loop(i, graphsLength);

              if (typeof _ret === 'object') return _ret.v;
            }

            return graphs;
          }
        }, {
          key: 'splitAt',
          value: function splitAt(waypoint) {
            var graphs = this.__findGraphs(waypoint);

            if (graphs.length > 1) {
              console.error('Can\'t split at \'' + waypoint.name + '\', graphs are already split');
              return false;
            }

            if (graphs.length !== 1) {
              console.error('Couldn\'t find graph for waypoint \'' + waypoint.name + '\'');
              return false;
            }

            var graph = graphs[0];
            var oldEnd = graph.lastNode().system;

            graph.end = waypoint; // set end of graph to wp

            for (var i = 0, graphsLength = this._graphs.length; i < graphsLength; i += 1) {
              if (this._graphs[i] === graph) {
                // insert new graph at wp, starting at wp, ending at oldEnd
                this._graphs.splice(i + 1, 0, new Dijkstra(SCMAP.allSystems, waypoint, oldEnd));

                for (var j = 0; j < this.waypoints.length; j += 1) {
                  if (this.waypoints[j] === oldEnd) {
                    this.waypoints.splice(j, 0, waypoint);
                    break;
                  }
                }

                this.__syncGraphs();
                this.storeToSession();
                return true;
              }
            }

            console.error('Couldn\'t match graph to split');
          }
        }, {
          key: 'toString',
          value: function toString() {
            var result = [];

            if (this.start instanceof StarSystem) {
              result.push(this.start.toString());
            }

            this.waypoints.forEach(function (system) {
              if (system instanceof StarSystem) {
                result.push(system);
              }
            });

            return result.join(' > ');
          }
        }, {
          key: 'removeWaypoint',
          value: function removeWaypoint(toRemove) {
            var _this3 = this;

            var graphs = this.__findGraphs(toRemove);

            if (graphs.length !== 2) {
              console.error('Can\'t remove waypoint \'' + toRemove.name + '\', it is not a waypoint');
              return false;
            }

            var _graphs = _slicedToArray(graphs, 2);

            var graphOne = _graphs[0];
            var graphTwo = _graphs[1];

            graphOne.end = graphTwo.start;

            // And now delete graphTwo
            this._graphs.forEach(function (graph, graphIndex) {
              if (graph === graphTwo) {
                console.log('Removing', graphTwo, 'at index ' + graphIndex);
                // remove the graph
                _this3._graphs.splice(graphIndex, 1);

                _this3.waypoints.forEach(function (waypoint, waypointIndex) {
                  if (toRemove === waypoint) {
                    console.log('Removing', waypoint, 'at index ' + waypointIndex);
                    // remove the waypoint
                    _this3.waypoints.splice(waypointIndex, 1);
                  }
                });

                _this3.__syncGraphs();
                _this3.storeToSession();
                return true;
              }
            });
          }
        }, {
          key: 'moveWaypoint',
          value: function moveWaypoint(waypoint, destination) {
            if (waypoint === destination) {
              return false;
            }

            if (destination === this.start || this.waypoints.indexOf(destination) >= 0) {
              return false;
            }

            // Easy case, moving start: update start and sync
            if (waypoint === this.start) {
              if (this.waypoints.length !== 1 || destination !== this.waypoints[0]) {
                this.start = destination;
                this.__syncGraphs();
                this.storeToSession();
                return true;
              } else {
                return false;
              }
            }

            // Slightly more difficult, moving any waypoint: update waypoint and sync
            var index = this.waypoints.indexOf(waypoint);
            if (index > -1) {
              this.waypoints[index] = destination;
              this.__syncGraphs();
              this.storeToSession();
              return true;
            }

            // Advanced case: split graphs at waypoint, then update waypoint and sync
            if (this.splitAt(waypoint)) {
              index = this.waypoints.indexOf(waypoint);
              if (index > -1) {
                this.waypoints[index] = destination;
                this.__syncGraphs();
                this.storeToSession();
                return true;
              }
            }

            //console.error( `Couldn't find waypoint '${ waypoint.name }'` );
            return false;
          }
        }, {
          key: 'setRoute',
          value: function setRoute() {
            var _this4 = this;

            var args = Array.prototype.slice.call(arguments);

            this.start = args.shift();
            this.start = this.start instanceof StarSystem ? this.start : null;
            this.waypoints = [];

            if (this.start) {
              args.forEach(function (system) {
                if (system instanceof StarSystem) {
                  _this4.waypoints.push(system);
                }
              });

              this.waypoints = this.waypoints.filter(function (system) {
                return system instanceof StarSystem;
              });
            }

            this.storeToSession();
          }

          // Updates the graphs to match the current waypoints, and recalculates
          // the graphs where needed
        }, {
          key: '__syncGraphs',
          value: function __syncGraphs() {
            var newGraphs = [];

            this._graphs = newGraphs;
            this._error = undefined;

            try {

              for (var i = 0, waypointsLength = this.waypoints.length; i < waypointsLength; i += 1) {
                var start = i === 0 ? this.start : this.waypoints[i - 1];
                var end = this.waypoints[i];
                var graph = undefined;

                if (this._graphs[i] instanceof Dijkstra) {
                  graph = this._graphs[i];
                  this._graphs[i].start = start;
                  this._graphs[i].end = end;
                } else {
                  graph = new Dijkstra(SCMAP.allSystems, start, end);
                }

                graph.buildGraph('time', true);
                newGraphs.push(graph);

                if (graph.routeArray().length <= 1) {
                  console.warn('No route from ' + start.name + ' to ' + end.name + ' possible');
                  throw new RouteSegmentFailed('No route from ' + start.name + ' to ' + end.name + ' available');
                  // TODO: could retry with fewer restrictions to indicate the user can change things
                  // to make the route possible, and indicate so in the error message
                }
              }

              this._graphs = newGraphs;
              //if ( newGraphs.length > 0 ) {
              //  console.log( `Synced and built ${ newGraphs.length } graphs` );
              //}
            } catch (e) {
              this._error = e;
              if (!(e instanceof RouteSegmentFailed)) {
                console.error('Error building route: ' + e.message);
              }
            }
          }
        }, {
          key: 'lastError',
          value: function lastError() {
            return this._error;
          }
        }, {
          key: 'isSet',
          value: function isSet() {
            return this.currentRoute().length > 1;
          }
        }, {
          key: 'currentRoute',
          value: function currentRoute() {
            var route = [];

            for (var i = 0, graphsLength = this._graphs.length; i < graphsLength; i += 1) {
              // TODO: Check whether this is correct or not, looks kaput
              if (this.waypoints[i] instanceof StarSystem) {
                this._graphs[i].rebuildGraph();
                var routePart = this._graphs[i].routeArray(this.waypoints[i]);
                for (var j = 0; j < routePart.length; j += 1) {
                  route.push(routePart[j]);
                }
              }
            }

            return route;
          }

          // Returns a float 0.0 to 1.0 to indicate where we are in
          // the route; we can use this to establish the approximate
          // colour of the given point
        }, {
          key: 'alphaOfSystem',
          value: function alphaOfSystem(system) {
            var currentStep = this.indexOfCurrentRoute(system);

            if (currentStep) {
              return currentStep / this.currentRoute().length;
            }

            return 0;
          }
        }, {
          key: 'indexOfCurrentRoute',
          value: function indexOfCurrentRoute(system) {
            if (!system instanceof StarSystem) {
              return;
            }

            var currentStep = 0;

            this.currentRoute().forEach(function (waypoint, index) {
              if (waypoint.system === system) {
                currentStep = index;
              }
            });

            return currentStep;
          }
        }, {
          key: 'rebuildCurrentRoute',
          value: function rebuildCurrentRoute() {
            var _this5 = this;

            this.removeFromScene();
            this._graphs.forEach(function (graph) {
              if (graph.rebuildGraph()) {
                var destination = graph.destination();
                if (destination) {
                  //console.log( `Have existing destination, updating route` );
                  _this5.update(destination);
                }
              }
            });
          }
        }, {
          key: 'destroy',
          value: function destroy() {
            this.start = null;
            this.waypoints = [];
            this.update();
          }
        }, {
          key: 'removeFromScene',
          value: function removeFromScene() {
            if (this._routeObject) {
              scene.remove(this._routeObject);
            }
          }
        }, {
          key: 'update',
          value: function update() {
            var before = this.toString();

            this.__syncGraphs();
            this.removeFromScene();

            var entireRoute = this.currentRoute();

            if (entireRoute.length) {
              // Exception can be thrown and caught to signal the route isn't possible
              if (this.lastError()) {
                return;
              }

              // Build all the parts of the route together in a single geometry group
              var routeObject = new JumpRouteGeometry({
                map: map,
                route: this,
                initialScale: map.displayState.currentScale
              });
              this._routeObject = routeObject.mesh;
              scene.add(routeObject.mesh);
            }

            RouteUI.update(this);
          }
        }, {
          key: 'storeToSession',
          value: function storeToSession() {
            if (hasSessionStorage) {
              if (this.start && this.waypoints.length) {
                window.sessionStorage.currentRoute = JSON.stringify({
                  start: this.start.id,
                  waypoints: this.waypoints.map(function (waypoint) {
                    return waypoint.id;
                  })
                });
              } else {
                delete window.sessionStorage.currentRoute;
              }
            }
          }
        }, {
          key: 'restoreFromSession',
          value: function restoreFromSession() {
            if (hasSessionStorage && 'currentRoute' in window.sessionStorage) {
              var data = JSON.parse(window.sessionStorage.currentRoute);
              this.start = StarSystem.getById(data.start);
              this.waypoints = data.waypoints.map(function (waypoint) {
                return StarSystem.getById(waypoint);
              });
            }
          }
        }]);

        return Route;
      })();

      RouteSegmentFailed.prototype = new Error();
      RouteSegmentFailed.prototype.constructor = RouteSegmentFailed;

      _export('default', Route);
    }
  };
});
$__System.register('10', ['11'], function (_export) {
  'use strict';

  var RSVP;
  return {
    setters: [function (_) {
      RSVP = _['default'];
    }],
    execute: function () {
      _export('default', function (url) {
        return new RSVP.Promise(function (resolve, reject) {

          var request = new XMLHttpRequest();

          request.onreadystatechange = function () {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                // Success
                resolve(this.response);
              } else {
                // Something went wrong (404 etc.)
                reject(new Error(this.statusText));
              }
            }
          };

          request.onerror = function () {
            reject(new Error('XMLHttpRequest Error: ' + this.statusText));
          };

          request.open('GET', url);
          request.send();
        }, url);
      });
    }
  };
});
$__System.register('12', ['8', '9', '13', '14'], function (_export) {
  var _createClass, _classCallCheck, TWEEN, StateMachine, MIN, MAX, DisplayState;

  return {
    setters: [function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_3) {
      TWEEN = _3['default'];
    }, function (_4) {
      StateMachine = _4['default'];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      'use strict';

      MIN = 0.001;
      // 0 causes issues for three.js scaling
      MAX = 1.0;

      DisplayState = (function () {
        function DisplayState(_ref) {
          var _this = this;

          var mode = _ref.mode;
          var map = _ref.map;
          var _ref$time = _ref.time;
          var time = _ref$time === undefined ? 1000 : _ref$time;

          _classCallCheck(this, DisplayState);

          this.mode = mode;
          this.map = map;

          this.position = { y: mode === '2d' ? MIN : MAX };

          this.tweenTo2d = new TWEEN.Tween(this.position).to({ y: MIN }, time).easing(TWEEN.Easing.Cubic.InOut);

          this.tweenTo3d = new TWEEN.Tween(this.position).to({ y: MAX }, time).easing(TWEEN.Easing.Cubic.InOut);

          var fsm = StateMachine.create({

            initial: mode || '3d',

            events: [{ name: 'to2d', from: '3d', to: '2d' }, { name: 'to3d', from: '2d', to: '3d' }],

            callbacks: {
              onleave2d: function onleave2d() {
                _this.tweenTo3d.onComplete(function () {
                  _this.fsm.transition();
                  _this.onComplete();
                });
                _this.tweenTo3d.start();
                return StateMachine.ASYNC;
              },

              onleave3d: function onleave3d() {
                _this.tweenTo2d.onComplete(function () {
                  _this.fsm.transition();
                  _this.onComplete();
                });
                _this.tweenTo2d.start();
                return StateMachine.ASYNC;
              }
            },

            error: function error(eventName, from, to, args, errorCode, errorMessage) {
              console.warn('DisplayState: ' + errorMessage);
            }
          });

          this.fsm = fsm;
        }

        _createClass(DisplayState, [{
          key: 'to2d',
          value: function to2d() {
            return this.fsm.to2d();
          }
        }, {
          key: 'to3d',
          value: function to3d() {
            return this.fsm.to3d();
          }
        }, {
          key: 'currentScale',
          get: function get() {
            return this.position.y;
          }
        }, {
          key: 'onUpdate',
          set: function set(func) {
            var updated = function updated() {
              func(this.y);
            };
            this.tweenTo2d.onUpdate(updated);
            this.tweenTo3d.onUpdate(updated);
          }
        }, {
          key: 'onComplete',
          get: function get() {
            return this._onComplete || function () {};
          },
          set: function set(func) {
            this._onComplete = func;
          }
        }, {
          key: 'onEnter2D',
          get: function get() {
            return this.fsm.onenter2d;
          },
          set: function set(value) {
            this.fsm.onenter2d = value;
          }
        }, {
          key: 'onEnter3D',
          get: function get() {
            return this.fsm.onenter3d;
          },
          set: function set(value) {
            this.fsm.onenter3d = value;
          }
        }]);

        return DisplayState;
      })();

      _export('default', DisplayState);
    }
  };
});
$__System.register('15', ['11'], function (_export) {
  'use strict';

  var RSVP, promise;

  function waitForFontAwesome() {
    var timeout = arguments.length <= 0 || arguments[0] === undefined ? 500 : arguments[0];
    var log = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
    var retries = arguments.length <= 2 || arguments[2] === undefined ? 10 : arguments[2];

    /* globals Promise */
    if (promise !== undefined) {
      return promise;
    }

    promise = new RSVP.Promise(function (resolve, reject) {
      var attempt = 0;
      var canvas = document.createElement('canvas');
      canvas.width = canvas.height = 20;
      var context = canvas.getContext('2d');

      var checkReady = function checkReady() {
        attempt += 1;
        context.fillStyle = 'rgba(0,0,0,1.0)';
        context.fillRect(0, 0, 20, 20);

        context.font = '16pt FontAwesome';
        context.textAlign = 'center';
        context.fillStyle = 'rgba(255,255,255,1.0)';
        context.fillText('', 10, 18);

        var data = context.getImageData(2, 10, 1, 1).data;

        if (data[0] !== 255 && data[1] !== 255 && data[2] !== 255) {

          if (log) {
            console.log('FontAwesome is not yet available (attempt# ' + attempt + ')');
          }

          if (attempt < retries) {

            window.setTimeout(checkReady, timeout);
          } else {

            if (log) {
              console.info('Could not detect FontAwesome after ' + retries + ' checks; some functionality may not be available');
            }

            reject(new Error('Could not load FontAwesome'));
          }
        } else {

          if (log) {
            console.info('FontAwesome is loaded');
          }

          resolve(true);
        }
      };

      // Start the ready-check
      checkReady();
    });

    return promise;
  }

  return {
    setters: [function (_) {
      RSVP = _['default'];
    }],
    execute: function () {
      promise = undefined;

      _export('default', waitForFontAwesome);
    }
  };
});
$__System.register('16', ['3'], function (_export) {
  'use strict';

  var THREE;

  function _build_selected_system_object() {
    var object = new THREE.JSONLoader().parse({
      'metadata': {
        'formatVersion': 3.1,
        'sourceFile': 'selected_system.obj',
        'generatedBy': 'OBJConverter',
        'vertices': 248,
        'faces': 248,
        'normals': 960,
        'colors': 0,
        'uvs': 0,
        'materials': 1
      },
      'scale': 1,
      'vertices': [-0.5, 0.5, 0.5, -0.52, 0.2, 0.5, -0.52, 0.2, 0.44, -0.52, 0.44, 0.44, -0.52, 0.5, 0.5, -0.5, 0.52, 0.5, -0.5, 0.5, 0.52, -0.52, 0.44, 0.2, -0.52, 0.5, 0.2, -0.5, 0.52, 0.2, -0.44, 0.52, 0.2, -0.44, 0.52, 0.44, -0.44, 0.44, 0.52, -0.5, 0.2, 0.52, -0.44, 0.2, 0.52, -0.2, 0.52, 0.44, -0.2, 0.52, 0.5, -0.2, 0.5, 0.52, -0.2, 0.44, 0.52, -0.5, 0.44, 0.2, -0.5, 0.5, 0.2, -0.44, 0.5, 0.2, -0.2, 0.44, 0.5, -0.2, 0.5, 0.44, -0.2, 0.5, 0.5, -0.5, 0.44, 0.44, -0.44, 0.44, 0.5, -0.44, 0.5, 0.44, -0.5, 0.2, 0.5, -0.5, 0.2, 0.44, -0.44, 0.2, 0.5, 0.5, 0.5, 0.5, 0.52, 0.2, 0.5, 0.52, 0.2, 0.44, 0.52, 0.44, 0.44, 0.52, 0.5, 0.5, 0.5, 0.52, 0.5, 0.5, 0.5, 0.52, 0.52, 0.44, 0.2, 0.52, 0.5, 0.2, 0.5, 0.52, 0.2, 0.44, 0.52, 0.2, 0.44, 0.52, 0.44, 0.44, 0.44, 0.52, 0.5, 0.2, 0.52, 0.44, 0.2, 0.52, 0.2, 0.52, 0.44, 0.2, 0.52, 0.5, 0.2, 0.5, 0.52, 0.2, 0.44, 0.52, 0.5, 0.44, 0.2, 0.5, 0.5, 0.2, 0.44, 0.5, 0.2, 0.2, 0.44, 0.5, 0.2, 0.5, 0.44, 0.2, 0.5, 0.5, 0.5, 0.44, 0.44, 0.44, 0.44, 0.5, 0.44, 0.5, 0.44, 0.5, 0.2, 0.5, 0.5, 0.2, 0.44, 0.44, 0.2, 0.5, -0.5, -0.5, 0.5, -0.52, -0.2, 0.5, -0.52, -0.2, 0.44, -0.52, -0.44, 0.44, -0.52, -0.5, 0.5, -0.5, -0.52, 0.5, -0.5, -0.5, 0.52, -0.52, -0.44, 0.2, -0.52, -0.5, 0.2, -0.5, -0.52, 0.2, -0.44, -0.52, 0.2, -0.44, -0.52, 0.44, -0.44, -0.44, 0.52, -0.5, -0.2, 0.52, -0.44, -0.2, 0.52, -0.2, -0.52, 0.44, -0.2, -0.52, 0.5, -0.2, -0.5, 0.52, -0.2, -0.44, 0.52, -0.5, -0.44, 0.2, -0.5, -0.5, 0.2, -0.44, -0.5, 0.2, -0.2, -0.44, 0.5, -0.2, -0.5, 0.44, -0.2, -0.5, 0.5, -0.5, -0.44, 0.44, -0.44, -0.44, 0.5, -0.44, -0.5, 0.44, -0.5, -0.2, 0.5, -0.5, -0.2, 0.44, -0.44, -0.2, 0.5, 0.5, -0.5, 0.5, 0.52, -0.2, 0.5, 0.52, -0.2, 0.44, 0.52, -0.44, 0.44, 0.52, -0.5, 0.5, 0.5, -0.52, 0.5, 0.5, -0.5, 0.52, 0.52, -0.44, 0.2, 0.52, -0.5, 0.2, 0.5, -0.52, 0.2, 0.44, -0.52, 0.2, 0.44, -0.52, 0.44, 0.44, -0.44, 0.52, 0.5, -0.2, 0.52, 0.44, -0.2, 0.52, 0.2, -0.52, 0.44, 0.2, -0.52, 0.5, 0.2, -0.5, 0.52, 0.2, -0.44, 0.52, 0.5, -0.44, 0.2, 0.5, -0.5, 0.2, 0.44, -0.5, 0.2, 0.2, -0.44, 0.5, 0.2, -0.5, 0.44, 0.2, -0.5, 0.5, 0.5, -0.44, 0.44, 0.44, -0.44, 0.5, 0.44, -0.5, 0.44, 0.5, -0.2, 0.5, 0.5, -0.2, 0.44, 0.44, -0.2, 0.5, -0.5, 0.5, -0.5, -0.52, 0.2, -0.5, -0.52, 0.2, -0.44, -0.52, 0.44, -0.44, -0.52, 0.5, -0.5, -0.5, 0.52, -0.5, -0.5, 0.5, -0.52, -0.52, 0.44, -0.2, -0.52, 0.5, -0.2, -0.5, 0.52, -0.2, -0.44, 0.52, -0.2, -0.44, 0.52, -0.44, -0.44, 0.44, -0.52, -0.5, 0.2, -0.52, -0.44, 0.2, -0.52, -0.2, 0.52, -0.44, -0.2, 0.52, -0.5, -0.2, 0.5, -0.52, -0.2, 0.44, -0.52, -0.5, 0.44, -0.2, -0.5, 0.5, -0.2, -0.44, 0.5, -0.2, -0.2, 0.44, -0.5, -0.2, 0.5, -0.44, -0.2, 0.5, -0.5, -0.5, 0.44, -0.44, -0.44, 0.44, -0.5, -0.44, 0.5, -0.44, -0.5, 0.2, -0.5, -0.5, 0.2, -0.44, -0.44, 0.2, -0.5, 0.5, 0.5, -0.5, 0.52, 0.2, -0.5, 0.52, 0.2, -0.44, 0.52, 0.44, -0.44, 0.52, 0.5, -0.5, 0.5, 0.52, -0.5, 0.5, 0.5, -0.52, 0.52, 0.44, -0.2, 0.52, 0.5, -0.2, 0.5, 0.52, -0.2, 0.44, 0.52, -0.2, 0.44, 0.52, -0.44, 0.44, 0.44, -0.52, 0.5, 0.2, -0.52, 0.44, 0.2, -0.52, 0.2, 0.52, -0.44, 0.2, 0.52, -0.5, 0.2, 0.5, -0.52, 0.2, 0.44, -0.52, 0.5, 0.44, -0.2, 0.5, 0.5, -0.2, 0.44, 0.5, -0.2, 0.2, 0.44, -0.5, 0.2, 0.5, -0.44, 0.2, 0.5, -0.5, 0.5, 0.44, -0.44, 0.44, 0.44, -0.5, 0.44, 0.5, -0.44, 0.5, 0.2, -0.5, 0.5, 0.2, -0.44, 0.44, 0.2, -0.5, -0.5, -0.5, -0.5, -0.52, -0.2, -0.5, -0.52, -0.2, -0.44, -0.52, -0.44, -0.44, -0.52, -0.5, -0.5, -0.5, -0.52, -0.5, -0.5, -0.5, -0.52, -0.52, -0.44, -0.2, -0.52, -0.5, -0.2, -0.5, -0.52, -0.2, -0.44, -0.52, -0.2, -0.44, -0.52, -0.44, -0.44, -0.44, -0.52, -0.5, -0.2, -0.52, -0.44, -0.2, -0.52, -0.2, -0.52, -0.44, -0.2, -0.52, -0.5, -0.2, -0.5, -0.52, -0.2, -0.44, -0.52, -0.5, -0.44, -0.2, -0.5, -0.5, -0.2, -0.44, -0.5, -0.2, -0.2, -0.44, -0.5, -0.2, -0.5, -0.44, -0.2, -0.5, -0.5, -0.5, -0.44, -0.44, -0.44, -0.44, -0.5, -0.44, -0.5, -0.44, -0.5, -0.2, -0.5, -0.5, -0.2, -0.44, -0.44, -0.2, -0.5, 0.5, -0.5, -0.5, 0.52, -0.2, -0.5, 0.52, -0.2, -0.44, 0.52, -0.44, -0.44, 0.52, -0.5, -0.5, 0.5, -0.52, -0.5, 0.5, -0.5, -0.52, 0.52, -0.44, -0.2, 0.52, -0.5, -0.2, 0.5, -0.52, -0.2, 0.44, -0.52, -0.2, 0.44, -0.52, -0.44, 0.44, -0.44, -0.52, 0.5, -0.2, -0.52, 0.44, -0.2, -0.52, 0.2, -0.52, -0.44, 0.2, -0.52, -0.5, 0.2, -0.5, -0.52, 0.2, -0.44, -0.52, 0.5, -0.44, -0.2, 0.5, -0.5, -0.2, 0.44, -0.5, -0.2, 0.2, -0.44, -0.5, 0.2, -0.5, -0.44, 0.2, -0.5, -0.5, 0.5, -0.44, -0.44, 0.44, -0.44, -0.5, 0.44, -0.5, -0.44, 0.5, -0.2, -0.5, 0.5, -0.2, -0.44, 0.44, -0.2, -0.5],
      'morphTargets': [],
      'morphColors': [],
      'normals': [-0.25969, 0.62694, -0.73451, -0.62694, 0.25969, -0.73451, -0.91018, 0.29289, 0.29289, -0.29289, 0.91018, 0.29289, -0.62694, -0.73451, 0.25969, -0.25969, -0.73451, 0.62694, -0.29289, 0.29289, 0.91018, -0.91018, 0.29289, 0.29289, 0.73451, 0.25969, 0.62694, 0.73451, 0.62694, 0.25969, -0.29289, 0.91018, 0.29289, -0.29289, 0.29289, 0.91018, -0.29289, 0.29289, 0.91018, -0.29289, 0.91018, 0.29289, -0.91018, 0.29289, 0.29289, 0.57735, -0.57735, -0.57735, 0.57735, -0.57735, 0.57735, 0.40825, -0.40825, 0.8165, 0.40825, -0.40825, -0.8165, 0.57735, -0.57735, 0.57735, 0.57735, -0.57735, -0.57735, 0.40825, -0.40825, -0.8165, 0.40825, -0.40825, 0.8165, 0.57735, 0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.40825, -0.8165, -0.40825, 0.40825, 0.8165, -0.40825, 0.57735, -0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.40825, 0.8165, -0.40825, 0.40825, -0.8165, -0.40825, -0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.8165, -0.40825, -0.40825, -0.8165, -0.40825, -0.40825, 0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.8165, -0.40825, -0.40825, 0.8165, -0.40825, -0.40825, 0.57735, -0.57735, 0.57735, 0.40825, -0.40825, 0.8165, -0.29289, 0.29289, 0.91018, -0.25969, -0.73451, 0.62694, 0.40825, -0.40825, 0.8165, 0.57735, -0.57735, 0.57735, 0.73451, 0.25969, 0.62694, -0.29289, 0.29289, 0.91018, -0.91018, 0.29289, 0.29289, -0.8165, -0.40825, -0.40825, -0.57735, -0.57735, -0.57735, -0.62694, -0.73451, 0.25969, -0.57735, -0.57735, -0.57735, -0.8165, -0.40825, -0.40825, -0.91018, 0.29289, 0.29289, -0.62694, 0.25969, -0.73451, 0.40825, 0.8165, -0.40825, 0.57735, 0.57735, -0.57735, -0.25969, 0.62694, -0.73451, -0.29289, 0.91018, 0.29289, 0.57735, 0.57735, -0.57735, 0.40825, 0.8165, -0.40825, -0.29289, 0.91018, 0.29289, 0.73451, 0.62694, 0.25969, 0.57735, -0.57735, -0.57735, 0.8165, -0.40825, -0.40825, 0.57735, -0.57735, -0.57735, 0.30151, -0.90453, -0.30151, 0.8165, -0.40825, -0.40825, 0.57735, -0.57735, -0.57735, 0.30151, -0.30151, -0.90453, 0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.40825, -0.8165, -0.40825, 0.57735, -0.57735, -0.57735, 0.30151, -0.30151, -0.90453, 0.57735, -0.57735, -0.57735, 0.40825, -0.8165, -0.40825, 0.57735, -0.57735, -0.57735, 0.90453, -0.30151, -0.30151, 0.40825, -0.40825, -0.8165, 0.57735, -0.57735, -0.57735, 0.30151, -0.90453, -0.30151, 0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.40825, -0.40825, -0.8165, 0.57735, -0.57735, -0.57735, 0.90453, -0.30151, -0.30151, 0.57735, -0.57735, -0.57735, 0.90453, -0.30151, -0.30151, 0.73451, 0.25969, 0.62694, 0.57735, -0.57735, 0.57735, 0.90453, -0.30151, -0.30151, 0.73451, 0.62694, 0.25969, 0.73451, 0.25969, 0.62694, 0.57735, -0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.73451, 0.62694, 0.25969, 0.90453, -0.30151, -0.30151, -0.62694, 0.25969, -0.73451, -0.25969, 0.62694, -0.73451, 0.30151, -0.30151, -0.90453, -0.62694, 0.25969, -0.73451, 0.30151, -0.30151, -0.90453, 0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.62694, -0.73451, 0.25969, -0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.30151, -0.90453, -0.30151, -0.62694, -0.73451, 0.25969, 0.30151, -0.90453, -0.30151, -0.25969, -0.73451, 0.62694, 0.30151, -0.30151, -0.90453, -0.25969, 0.62694, -0.73451, 0.57735, 0.57735, -0.57735, 0.57735, -0.57735, -0.57735, -0.25969, -0.73451, 0.62694, 0.30151, -0.90453, -0.30151, 0.57735, -0.57735, -0.57735, 0.57735, -0.57735, 0.57735, 0.91018, 0.29289, 0.29289, 0.62694, 0.25969, -0.73451, 0.25969, 0.62694, -0.73451, 0.29289, 0.91018, 0.29289, 0.29289, 0.29289, 0.91018, 0.25969, -0.73451, 0.62694, 0.62694, -0.73451, 0.25969, 0.91018, 0.29289, 0.29289, 0.29289, 0.91018, 0.29289, -0.73451, 0.62694, 0.25969, -0.73451, 0.25969, 0.62694, 0.29289, 0.29289, 0.91018, 0.29289, 0.91018, 0.29289, 0.29289, 0.29289, 0.91018, 0.91018, 0.29289, 0.29289, -0.40825, -0.40825, 0.8165, -0.57735, -0.57735, 0.57735, -0.57735, -0.57735, -0.57735, -0.40825, -0.40825, -0.8165, -0.40825, -0.40825, -0.8165, -0.57735, -0.57735, -0.57735, -0.57735, -0.57735, 0.57735, -0.40825, -0.40825, 0.8165, -0.40825, -0.8165, -0.40825, -0.57735, -0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.40825, 0.8165, -0.40825, -0.40825, 0.8165, -0.40825, -0.57735, 0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.40825, -0.8165, -0.40825, -0.8165, -0.40825, -0.40825, -0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.8165, -0.40825, -0.40825, 0.8165, -0.40825, -0.40825, 0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.8165, -0.40825, -0.40825, 0.29289, 0.29289, 0.91018, -0.40825, -0.40825, 0.8165, -0.57735, -0.57735, 0.57735, 0.25969, -0.73451, 0.62694, -0.73451, 0.25969, 0.62694, -0.57735, -0.57735, 0.57735, -0.40825, -0.40825, 0.8165, 0.29289, 0.29289, 0.91018, 0.57735, -0.57735, -0.57735, 0.8165, -0.40825, -0.40825, 0.91018, 0.29289, 0.29289, 0.62694, -0.73451, 0.25969, 0.91018, 0.29289, 0.29289, 0.8165, -0.40825, -0.40825, 0.57735, -0.57735, -0.57735, 0.62694, 0.25969, -0.73451, 0.25969, 0.62694, -0.73451, -0.57735, 0.57735, -0.57735, -0.40825, 0.8165, -0.40825, 0.29289, 0.91018, 0.29289, 0.29289, 0.91018, 0.29289, -0.40825, 0.8165, -0.40825, -0.57735, 0.57735, -0.57735, -0.73451, 0.62694, 0.25969, -0.57735, -0.57735, -0.57735, -0.8165, -0.40825, -0.40825, -0.57735, -0.57735, -0.57735, -0.30151, -0.90453, -0.30151, -0.30151, -0.30151, -0.90453, -0.57735, -0.57735, -0.57735, -0.8165, -0.40825, -0.40825, -0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.40825, -0.8165, -0.40825, -0.57735, -0.57735, -0.57735, -0.30151, -0.30151, -0.90453, -0.57735, -0.57735, -0.57735, -0.40825, -0.8165, -0.40825, -0.57735, -0.57735, -0.57735, -0.90453, -0.30151, -0.30151, -0.30151, -0.90453, -0.30151, -0.57735, -0.57735, -0.57735, -0.40825, -0.40825, -0.8165, -0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.40825, -0.40825, -0.8165, -0.57735, -0.57735, -0.57735, -0.90453, -0.30151, -0.30151, -0.73451, 0.25969, 0.62694, -0.90453, -0.30151, -0.30151, -0.57735, -0.57735, -0.57735, -0.57735, -0.57735, 0.57735, -0.73451, 0.62694, 0.25969, -0.90453, -0.30151, -0.30151, -0.73451, 0.25969, 0.62694, -0.73451, 0.62694, 0.25969, -0.57735, 0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.90453, -0.30151, -0.30151, 0.25969, 0.62694, -0.73451, 0.62694, 0.25969, -0.73451, -0.30151, -0.30151, -0.90453, -0.57735, -0.57735, -0.57735, -0.30151, -0.30151, -0.90453, 0.62694, 0.25969, -0.73451, 0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.62694, -0.73451, 0.25969, -0.30151, -0.90453, -0.30151, -0.30151, -0.90453, -0.30151, 0.62694, -0.73451, 0.25969, 0.25969, -0.73451, 0.62694, -0.57735, 0.57735, -0.57735, 0.25969, 0.62694, -0.73451, -0.30151, -0.30151, -0.90453, -0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.30151, -0.90453, -0.30151, 0.25969, -0.73451, 0.62694, -0.57735, -0.57735, 0.57735, -0.91018, -0.29289, 0.29289, -0.62694, -0.25969, -0.73451, -0.25969, -0.62694, -0.73451, -0.29289, -0.91018, 0.29289, -0.29289, -0.29289, 0.91018, -0.25969, 0.73451, 0.62694, -0.62694, 0.73451, 0.25969, -0.91018, -0.29289, 0.29289, -0.29289, -0.91018, 0.29289, 0.73451, -0.62694, 0.25969, 0.73451, -0.25969, 0.62694, -0.29289, -0.29289, 0.91018, -0.29289, -0.91018, 0.29289, -0.29289, -0.29289, 0.91018, -0.91018, -0.29289, 0.29289, 0.40825, 0.40825, 0.8165, 0.57735, 0.57735, 0.57735, 0.57735, 0.57735, -0.57735, 0.40825, 0.40825, -0.8165, 0.40825, 0.40825, -0.8165, 0.57735, 0.57735, -0.57735, 0.57735, 0.57735, 0.57735, 0.40825, 0.40825, 0.8165, 0.40825, 0.8165, -0.40825, 0.57735, 0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.40825, -0.8165, -0.40825, 0.40825, -0.8165, -0.40825, 0.57735, -0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.40825, 0.8165, -0.40825, 0.8165, 0.40825, -0.40825, 0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.8165, 0.40825, -0.40825, -0.8165, 0.40825, -0.40825, -0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.8165, 0.40825, -0.40825, -0.29289, -0.29289, 0.91018, 0.40825, 0.40825, 0.8165, 0.57735, 0.57735, 0.57735, -0.25969, 0.73451, 0.62694, 0.73451, -0.25969, 0.62694, 0.57735, 0.57735, 0.57735, 0.40825, 0.40825, 0.8165, -0.29289, -0.29289, 0.91018, -0.57735, 0.57735, -0.57735, -0.8165, 0.40825, -0.40825, -0.91018, -0.29289, 0.29289, -0.62694, 0.73451, 0.25969, -0.91018, -0.29289, 0.29289, -0.8165, 0.40825, -0.40825, -0.57735, 0.57735, -0.57735, -0.62694, -0.25969, -0.73451, -0.25969, -0.62694, -0.73451, 0.57735, -0.57735, -0.57735, 0.40825, -0.8165, -0.40825, -0.29289, -0.91018, 0.29289, -0.29289, -0.91018, 0.29289, 0.40825, -0.8165, -0.40825, 0.57735, -0.57735, -0.57735, 0.73451, -0.62694, 0.25969, 0.57735, 0.57735, -0.57735, 0.8165, 0.40825, -0.40825, 0.57735, 0.57735, -0.57735, 0.30151, 0.90453, -0.30151, 0.30151, 0.30151, -0.90453, 0.57735, 0.57735, -0.57735, 0.8165, 0.40825, -0.40825, 0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.40825, 0.8165, -0.40825, 0.57735, 0.57735, -0.57735, 0.30151, 0.30151, -0.90453, 0.57735, 0.57735, -0.57735, 0.40825, 0.8165, -0.40825, 0.57735, 0.57735, -0.57735, 0.90453, 0.30151, -0.30151, 0.30151, 0.90453, -0.30151, 0.57735, 0.57735, -0.57735, 0.40825, 0.40825, -0.8165, 0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.40825, 0.40825, -0.8165, 0.57735, 0.57735, -0.57735, 0.90453, 0.30151, -0.30151, 0.73451, -0.25969, 0.62694, 0.90453, 0.30151, -0.30151, 0.57735, 0.57735, -0.57735, 0.57735, 0.57735, 0.57735, 0.73451, -0.62694, 0.25969, 0.90453, 0.30151, -0.30151, 0.73451, -0.25969, 0.62694, 0.73451, -0.62694, 0.25969, 0.57735, -0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.90453, 0.30151, -0.30151, -0.25969, -0.62694, -0.73451, -0.62694, -0.25969, -0.73451, 0.30151, 0.30151, -0.90453, 0.57735, 0.57735, -0.57735, 0.30151, 0.30151, -0.90453, -0.62694, -0.25969, -0.73451, -0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.62694, 0.73451, 0.25969, 0.30151, 0.90453, -0.30151, 0.30151, 0.90453, -0.30151, -0.62694, 0.73451, 0.25969, -0.25969, 0.73451, 0.62694, 0.57735, -0.57735, -0.57735, -0.25969, -0.62694, -0.73451, 0.30151, 0.30151, -0.90453, 0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.30151, 0.90453, -0.30151, -0.25969, 0.73451, 0.62694, 0.57735, 0.57735, 0.57735, 0.25969, -0.62694, -0.73451, 0.62694, -0.25969, -0.73451, 0.91018, -0.29289, 0.29289, 0.29289, -0.91018, 0.29289, 0.62694, 0.73451, 0.25969, 0.25969, 0.73451, 0.62694, 0.29289, -0.29289, 0.91018, 0.91018, -0.29289, 0.29289, -0.73451, -0.25969, 0.62694, -0.73451, -0.62694, 0.25969, 0.29289, -0.91018, 0.29289, 0.29289, -0.29289, 0.91018, 0.29289, -0.29289, 0.91018, 0.29289, -0.91018, 0.29289, 0.91018, -0.29289, 0.29289, -0.57735, 0.57735, -0.57735, -0.57735, 0.57735, 0.57735, -0.40825, 0.40825, 0.8165, -0.40825, 0.40825, -0.8165, -0.57735, 0.57735, 0.57735, -0.57735, 0.57735, -0.57735, -0.40825, 0.40825, -0.8165, -0.40825, 0.40825, 0.8165, -0.57735, -0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.40825, 0.8165, -0.40825, -0.40825, -0.8165, -0.40825, -0.57735, 0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.40825, -0.8165, -0.40825, -0.40825, 0.8165, -0.40825, 0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.8165, 0.40825, -0.40825, 0.8165, 0.40825, -0.40825, -0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.8165, 0.40825, -0.40825, -0.8165, 0.40825, -0.40825, -0.57735, 0.57735, 0.57735, -0.40825, 0.40825, 0.8165, 0.29289, -0.29289, 0.91018, 0.25969, 0.73451, 0.62694, -0.40825, 0.40825, 0.8165, -0.57735, 0.57735, 0.57735, -0.73451, -0.25969, 0.62694, 0.29289, -0.29289, 0.91018, 0.91018, -0.29289, 0.29289, 0.8165, 0.40825, -0.40825, 0.57735, 0.57735, -0.57735, 0.62694, 0.73451, 0.25969, 0.57735, 0.57735, -0.57735, 0.8165, 0.40825, -0.40825, 0.91018, -0.29289, 0.29289, 0.62694, -0.25969, -0.73451, -0.40825, -0.8165, -0.40825, -0.57735, -0.57735, -0.57735, 0.25969, -0.62694, -0.73451, 0.29289, -0.91018, 0.29289, -0.57735, -0.57735, -0.57735, -0.40825, -0.8165, -0.40825, 0.29289, -0.91018, 0.29289, -0.73451, -0.62694, 0.25969, -0.57735, 0.57735, -0.57735, -0.8165, 0.40825, -0.40825, -0.57735, 0.57735, -0.57735, -0.30151, 0.90453, -0.30151, -0.8165, 0.40825, -0.40825, -0.57735, 0.57735, -0.57735, -0.30151, 0.30151, -0.90453, -0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.40825, 0.8165, -0.40825, -0.57735, 0.57735, -0.57735, -0.30151, 0.30151, -0.90453, -0.57735, 0.57735, -0.57735, -0.40825, 0.8165, -0.40825, -0.57735, 0.57735, -0.57735, -0.90453, 0.30151, -0.30151, -0.40825, 0.40825, -0.8165, -0.57735, 0.57735, -0.57735, -0.30151, 0.90453, -0.30151, -0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.40825, 0.40825, -0.8165, -0.57735, 0.57735, -0.57735, -0.90453, 0.30151, -0.30151, -0.57735, 0.57735, -0.57735, -0.90453, 0.30151, -0.30151, -0.73451, -0.25969, 0.62694, -0.57735, 0.57735, 0.57735, -0.90453, 0.30151, -0.30151, -0.73451, -0.62694, 0.25969, -0.73451, -0.25969, 0.62694, -0.57735, 0.57735, -0.57735, -0.57735, -0.57735, -0.57735, -0.73451, -0.62694, 0.25969, -0.90453, 0.30151, -0.30151, 0.62694, -0.25969, -0.73451, 0.25969, -0.62694, -0.73451, -0.30151, 0.30151, -0.90453, 0.62694, -0.25969, -0.73451, -0.30151, 0.30151, -0.90453, -0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.62694, 0.73451, 0.25969, 0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.57735, -0.30151, 0.90453, -0.30151, 0.62694, 0.73451, 0.25969, -0.30151, 0.90453, -0.30151, 0.25969, 0.73451, 0.62694, -0.30151, 0.30151, -0.90453, 0.25969, -0.62694, -0.73451, -0.57735, -0.57735, -0.57735, -0.57735, 0.57735, -0.57735, 0.25969, 0.73451, 0.62694, -0.30151, 0.90453, -0.30151, -0.57735, 0.57735, -0.57735, -0.57735, 0.57735, 0.57735, -0.91018, 0.29289, -0.29289, -0.62694, 0.25969, 0.73451, -0.25969, 0.62694, 0.73451, -0.29289, 0.91018, -0.29289, -0.29289, 0.29289, -0.91018, -0.25969, -0.73451, -0.62694, -0.62694, -0.73451, -0.25969, -0.91018, 0.29289, -0.29289, -0.29289, 0.91018, -0.29289, 0.73451, 0.62694, -0.25969, 0.73451, 0.25969, -0.62694, -0.29289, 0.29289, -0.91018, -0.29289, 0.91018, -0.29289, -0.29289, 0.29289, -0.91018, -0.91018, 0.29289, -0.29289, 0.40825, -0.40825, -0.8165, 0.57735, -0.57735, -0.57735, 0.57735, -0.57735, 0.57735, 0.40825, -0.40825, 0.8165, 0.40825, -0.40825, 0.8165, 0.57735, -0.57735, 0.57735, 0.57735, -0.57735, -0.57735, 0.40825, -0.40825, -0.8165, 0.40825, -0.8165, 0.40825, 0.57735, -0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.40825, 0.8165, 0.40825, 0.40825, 0.8165, 0.40825, 0.57735, 0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.40825, -0.8165, 0.40825, 0.8165, -0.40825, 0.40825, 0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.8165, -0.40825, 0.40825, -0.8165, -0.40825, 0.40825, -0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.8165, -0.40825, 0.40825, -0.29289, 0.29289, -0.91018, 0.40825, -0.40825, -0.8165, 0.57735, -0.57735, -0.57735, -0.25969, -0.73451, -0.62694, 0.73451, 0.25969, -0.62694, 0.57735, -0.57735, -0.57735, 0.40825, -0.40825, -0.8165, -0.29289, 0.29289, -0.91018, -0.57735, -0.57735, 0.57735, -0.8165, -0.40825, 0.40825, -0.91018, 0.29289, -0.29289, -0.62694, -0.73451, -0.25969, -0.91018, 0.29289, -0.29289, -0.8165, -0.40825, 0.40825, -0.57735, -0.57735, 0.57735, -0.62694, 0.25969, 0.73451, -0.25969, 0.62694, 0.73451, 0.57735, 0.57735, 0.57735, 0.40825, 0.8165, 0.40825, -0.29289, 0.91018, -0.29289, -0.29289, 0.91018, -0.29289, 0.40825, 0.8165, 0.40825, 0.57735, 0.57735, 0.57735, 0.73451, 0.62694, -0.25969, 0.57735, -0.57735, 0.57735, 0.8165, -0.40825, 0.40825, 0.57735, -0.57735, 0.57735, 0.30151, -0.90453, 0.30151, 0.30151, -0.30151, 0.90453, 0.57735, -0.57735, 0.57735, 0.8165, -0.40825, 0.40825, 0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.40825, -0.8165, 0.40825, 0.57735, -0.57735, 0.57735, 0.30151, -0.30151, 0.90453, 0.57735, -0.57735, 0.57735, 0.40825, -0.8165, 0.40825, 0.57735, -0.57735, 0.57735, 0.90453, -0.30151, 0.30151, 0.30151, -0.90453, 0.30151, 0.57735, -0.57735, 0.57735, 0.40825, -0.40825, 0.8165, 0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.40825, -0.40825, 0.8165, 0.57735, -0.57735, 0.57735, 0.90453, -0.30151, 0.30151, 0.73451, 0.25969, -0.62694, 0.90453, -0.30151, 0.30151, 0.57735, -0.57735, 0.57735, 0.57735, -0.57735, -0.57735, 0.73451, 0.62694, -0.25969, 0.90453, -0.30151, 0.30151, 0.73451, 0.25969, -0.62694, 0.73451, 0.62694, -0.25969, 0.57735, 0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.90453, -0.30151, 0.30151, -0.25969, 0.62694, 0.73451, -0.62694, 0.25969, 0.73451, 0.30151, -0.30151, 0.90453, 0.57735, -0.57735, 0.57735, 0.30151, -0.30151, 0.90453, -0.62694, 0.25969, 0.73451, -0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.62694, -0.73451, -0.25969, 0.30151, -0.90453, 0.30151, 0.30151, -0.90453, 0.30151, -0.62694, -0.73451, -0.25969, -0.25969, -0.73451, -0.62694, 0.57735, 0.57735, 0.57735, -0.25969, 0.62694, 0.73451, 0.30151, -0.30151, 0.90453, 0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.30151, -0.90453, 0.30151, -0.25969, -0.73451, -0.62694, 0.57735, -0.57735, -0.57735, 0.25969, 0.62694, 0.73451, 0.62694, 0.25969, 0.73451, 0.91018, 0.29289, -0.29289, 0.29289, 0.91018, -0.29289, 0.62694, -0.73451, -0.25969, 0.25969, -0.73451, -0.62694, 0.29289, 0.29289, -0.91018, 0.91018, 0.29289, -0.29289, -0.73451, 0.25969, -0.62694, -0.73451, 0.62694, -0.25969, 0.29289, 0.91018, -0.29289, 0.29289, 0.29289, -0.91018, 0.29289, 0.29289, -0.91018, 0.29289, 0.91018, -0.29289, 0.91018, 0.29289, -0.29289, -0.57735, -0.57735, 0.57735, -0.57735, -0.57735, -0.57735, -0.40825, -0.40825, -0.8165, -0.40825, -0.40825, 0.8165, -0.57735, -0.57735, -0.57735, -0.57735, -0.57735, 0.57735, -0.40825, -0.40825, 0.8165, -0.40825, -0.40825, -0.8165, -0.57735, 0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.40825, -0.8165, 0.40825, -0.40825, 0.8165, 0.40825, -0.57735, -0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.40825, 0.8165, 0.40825, -0.40825, -0.8165, 0.40825, 0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.8165, -0.40825, 0.40825, 0.8165, -0.40825, 0.40825, -0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.8165, -0.40825, 0.40825, -0.8165, -0.40825, 0.40825, -0.57735, -0.57735, -0.57735, -0.40825, -0.40825, -0.8165, 0.29289, 0.29289, -0.91018, 0.25969, -0.73451, -0.62694, -0.40825, -0.40825, -0.8165, -0.57735, -0.57735, -0.57735, -0.73451, 0.25969, -0.62694, 0.29289, 0.29289, -0.91018, 0.91018, 0.29289, -0.29289, 0.8165, -0.40825, 0.40825, 0.57735, -0.57735, 0.57735, 0.62694, -0.73451, -0.25969, 0.57735, -0.57735, 0.57735, 0.8165, -0.40825, 0.40825, 0.91018, 0.29289, -0.29289, 0.62694, 0.25969, 0.73451, -0.40825, 0.8165, 0.40825, -0.57735, 0.57735, 0.57735, 0.25969, 0.62694, 0.73451, 0.29289, 0.91018, -0.29289, -0.57735, 0.57735, 0.57735, -0.40825, 0.8165, 0.40825, 0.29289, 0.91018, -0.29289, -0.73451, 0.62694, -0.25969, -0.57735, -0.57735, 0.57735, -0.8165, -0.40825, 0.40825, -0.57735, -0.57735, 0.57735, -0.30151, -0.90453, 0.30151, -0.8165, -0.40825, 0.40825, -0.57735, -0.57735, 0.57735, -0.30151, -0.30151, 0.90453, -0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.40825, -0.8165, 0.40825, -0.57735, -0.57735, 0.57735, -0.30151, -0.30151, 0.90453, -0.57735, -0.57735, 0.57735, -0.40825, -0.8165, 0.40825, -0.57735, -0.57735, 0.57735, -0.90453, -0.30151, 0.30151, -0.40825, -0.40825, 0.8165, -0.57735, -0.57735, 0.57735, -0.30151, -0.90453, 0.30151, -0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.40825, -0.40825, 0.8165, -0.57735, -0.57735, 0.57735, -0.90453, -0.30151, 0.30151, -0.57735, -0.57735, 0.57735, -0.90453, -0.30151, 0.30151, -0.73451, 0.25969, -0.62694, -0.57735, -0.57735, -0.57735, -0.90453, -0.30151, 0.30151, -0.73451, 0.62694, -0.25969, -0.73451, 0.25969, -0.62694, -0.57735, -0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.73451, 0.62694, -0.25969, -0.90453, -0.30151, 0.30151, 0.62694, 0.25969, 0.73451, 0.25969, 0.62694, 0.73451, -0.30151, -0.30151, 0.90453, 0.62694, 0.25969, 0.73451, -0.30151, -0.30151, 0.90453, -0.57735, -0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.62694, -0.73451, -0.25969, 0.57735, -0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.30151, -0.90453, 0.30151, 0.62694, -0.73451, -0.25969, -0.30151, -0.90453, 0.30151, 0.25969, -0.73451, -0.62694, -0.30151, -0.30151, 0.90453, 0.25969, 0.62694, 0.73451, -0.57735, 0.57735, 0.57735, -0.57735, -0.57735, 0.57735, 0.25969, -0.73451, -0.62694, -0.30151, -0.90453, 0.30151, -0.57735, -0.57735, 0.57735, -0.57735, -0.57735, -0.57735, -0.25969, -0.62694, 0.73451, -0.62694, -0.25969, 0.73451, -0.91018, -0.29289, -0.29289, -0.29289, -0.91018, -0.29289, -0.62694, 0.73451, -0.25969, -0.25969, 0.73451, -0.62694, -0.29289, -0.29289, -0.91018, -0.91018, -0.29289, -0.29289, 0.73451, -0.25969, -0.62694, 0.73451, -0.62694, -0.25969, -0.29289, -0.91018, -0.29289, -0.29289, -0.29289, -0.91018, -0.29289, -0.29289, -0.91018, -0.29289, -0.91018, -0.29289, -0.91018, -0.29289, -0.29289, 0.57735, 0.57735, 0.57735, 0.57735, 0.57735, -0.57735, 0.40825, 0.40825, -0.8165, 0.40825, 0.40825, 0.8165, 0.57735, 0.57735, -0.57735, 0.57735, 0.57735, 0.57735, 0.40825, 0.40825, 0.8165, 0.40825, 0.40825, -0.8165, 0.57735, -0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.40825, 0.8165, 0.40825, 0.40825, -0.8165, 0.40825, 0.57735, 0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.40825, -0.8165, 0.40825, 0.40825, 0.8165, 0.40825, -0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.8165, 0.40825, 0.40825, -0.8165, 0.40825, 0.40825, 0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.8165, 0.40825, 0.40825, 0.8165, 0.40825, 0.40825, 0.57735, 0.57735, -0.57735, 0.40825, 0.40825, -0.8165, -0.29289, -0.29289, -0.91018, -0.25969, 0.73451, -0.62694, 0.40825, 0.40825, -0.8165, 0.57735, 0.57735, -0.57735, 0.73451, -0.25969, -0.62694, -0.29289, -0.29289, -0.91018, -0.91018, -0.29289, -0.29289, -0.8165, 0.40825, 0.40825, -0.57735, 0.57735, 0.57735, -0.62694, 0.73451, -0.25969, -0.57735, 0.57735, 0.57735, -0.8165, 0.40825, 0.40825, -0.91018, -0.29289, -0.29289, -0.62694, -0.25969, 0.73451, 0.40825, -0.8165, 0.40825, 0.57735, -0.57735, 0.57735, -0.25969, -0.62694, 0.73451, -0.29289, -0.91018, -0.29289, 0.57735, -0.57735, 0.57735, 0.40825, -0.8165, 0.40825, -0.29289, -0.91018, -0.29289, 0.73451, -0.62694, -0.25969, 0.57735, 0.57735, 0.57735, 0.8165, 0.40825, 0.40825, 0.57735, 0.57735, 0.57735, 0.30151, 0.90453, 0.30151, 0.8165, 0.40825, 0.40825, 0.57735, 0.57735, 0.57735, 0.30151, 0.30151, 0.90453, 0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.40825, 0.8165, 0.40825, 0.57735, 0.57735, 0.57735, 0.30151, 0.30151, 0.90453, 0.57735, 0.57735, 0.57735, 0.40825, 0.8165, 0.40825, 0.57735, 0.57735, 0.57735, 0.90453, 0.30151, 0.30151, 0.40825, 0.40825, 0.8165, 0.57735, 0.57735, 0.57735, 0.30151, 0.90453, 0.30151, 0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.40825, 0.40825, 0.8165, 0.57735, 0.57735, 0.57735, 0.90453, 0.30151, 0.30151, 0.57735, 0.57735, 0.57735, 0.90453, 0.30151, 0.30151, 0.73451, -0.25969, -0.62694, 0.57735, 0.57735, -0.57735, 0.90453, 0.30151, 0.30151, 0.73451, -0.62694, -0.25969, 0.73451, -0.25969, -0.62694, 0.57735, 0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.73451, -0.62694, -0.25969, 0.90453, 0.30151, 0.30151, -0.62694, -0.25969, 0.73451, -0.25969, -0.62694, 0.73451, 0.30151, 0.30151, 0.90453, -0.62694, -0.25969, 0.73451, 0.30151, 0.30151, 0.90453, 0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.62694, 0.73451, -0.25969, -0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.30151, 0.90453, 0.30151, -0.62694, 0.73451, -0.25969, 0.30151, 0.90453, 0.30151, -0.25969, 0.73451, -0.62694, 0.30151, 0.30151, 0.90453, -0.25969, -0.62694, 0.73451, 0.57735, -0.57735, 0.57735, 0.57735, 0.57735, 0.57735, -0.25969, 0.73451, -0.62694, 0.30151, 0.90453, 0.30151, 0.57735, 0.57735, 0.57735, 0.57735, 0.57735, -0.57735, 0.91018, -0.29289, -0.29289, 0.62694, -0.25969, 0.73451, 0.25969, -0.62694, 0.73451, 0.29289, -0.91018, -0.29289, 0.29289, -0.29289, -0.91018, 0.25969, 0.73451, -0.62694, 0.62694, 0.73451, -0.25969, 0.91018, -0.29289, -0.29289, 0.29289, -0.91018, -0.29289, -0.73451, -0.62694, -0.25969, -0.73451, -0.25969, -0.62694, 0.29289, -0.29289, -0.91018, 0.29289, -0.91018, -0.29289, 0.29289, -0.29289, -0.91018, 0.91018, -0.29289, -0.29289, -0.40825, 0.40825, -0.8165, -0.57735, 0.57735, -0.57735, -0.57735, 0.57735, 0.57735, -0.40825, 0.40825, 0.8165, -0.40825, 0.40825, 0.8165, -0.57735, 0.57735, 0.57735, -0.57735, 0.57735, -0.57735, -0.40825, 0.40825, -0.8165, -0.40825, 0.8165, 0.40825, -0.57735, 0.57735, 0.57735, -0.57735, -0.57735, 0.57735, -0.40825, -0.8165, 0.40825, -0.40825, -0.8165, 0.40825, -0.57735, -0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.40825, 0.8165, 0.40825, -0.8165, 0.40825, 0.40825, -0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.8165, 0.40825, 0.40825, 0.8165, 0.40825, 0.40825, 0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.8165, 0.40825, 0.40825, 0.29289, -0.29289, -0.91018, -0.40825, 0.40825, -0.8165, -0.57735, 0.57735, -0.57735, 0.25969, 0.73451, -0.62694, -0.73451, -0.25969, -0.62694, -0.57735, 0.57735, -0.57735, -0.40825, 0.40825, -0.8165, 0.29289, -0.29289, -0.91018, 0.57735, 0.57735, 0.57735, 0.8165, 0.40825, 0.40825, 0.91018, -0.29289, -0.29289, 0.62694, 0.73451, -0.25969, 0.91018, -0.29289, -0.29289, 0.8165, 0.40825, 0.40825, 0.57735, 0.57735, 0.57735, 0.62694, -0.25969, 0.73451, 0.25969, -0.62694, 0.73451, -0.57735, -0.57735, 0.57735, -0.40825, -0.8165, 0.40825, 0.29289, -0.91018, -0.29289, 0.29289, -0.91018, -0.29289, -0.40825, -0.8165, 0.40825, -0.57735, -0.57735, 0.57735, -0.73451, -0.62694, -0.25969, -0.57735, 0.57735, 0.57735, -0.8165, 0.40825, 0.40825, -0.57735, 0.57735, 0.57735, -0.30151, 0.90453, 0.30151, -0.30151, 0.30151, 0.90453, -0.57735, 0.57735, 0.57735, -0.8165, 0.40825, 0.40825, -0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.40825, 0.8165, 0.40825, -0.57735, 0.57735, 0.57735, -0.30151, 0.30151, 0.90453, -0.57735, 0.57735, 0.57735, -0.40825, 0.8165, 0.40825, -0.57735, 0.57735, 0.57735, -0.90453, 0.30151, 0.30151, -0.30151, 0.90453, 0.30151, -0.57735, 0.57735, 0.57735, -0.40825, 0.40825, 0.8165, -0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.40825, 0.40825, 0.8165, -0.57735, 0.57735, 0.57735, -0.90453, 0.30151, 0.30151, -0.73451, -0.25969, -0.62694, -0.90453, 0.30151, 0.30151, -0.57735, 0.57735, 0.57735, -0.57735, 0.57735, -0.57735, -0.73451, -0.62694, -0.25969, -0.90453, 0.30151, 0.30151, -0.73451, -0.25969, -0.62694, -0.73451, -0.62694, -0.25969, -0.57735, -0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.90453, 0.30151, 0.30151, 0.25969, -0.62694, 0.73451, 0.62694, -0.25969, 0.73451, -0.30151, 0.30151, 0.90453, -0.57735, 0.57735, 0.57735, -0.30151, 0.30151, 0.90453, 0.62694, -0.25969, 0.73451, 0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.57735, 0.62694, 0.73451, -0.25969, -0.30151, 0.90453, 0.30151, -0.30151, 0.90453, 0.30151, 0.62694, 0.73451, -0.25969, 0.25969, 0.73451, -0.62694, -0.57735, -0.57735, 0.57735, 0.25969, -0.62694, 0.73451, -0.30151, 0.30151, 0.90453, -0.57735, 0.57735, 0.57735, -0.57735, 0.57735, 0.57735, -0.30151, 0.90453, 0.30151, 0.25969, 0.73451, -0.62694, -0.57735, 0.57735, -0.57735],
      'colors': [],
      'uvs': [[]],
      'faces': [35, 9, 8, 4, 5, 0, 0, 1, 2, 3, 35, 1, 13, 6, 4, 0, 4, 5, 6, 7, 35, 17, 16, 5, 6, 0, 8, 9, 10, 11, 34, 6, 5, 4, 0, 12, 13, 14, 35, 22, 18, 12, 26, 0, 15, 16, 17, 18, 35, 14, 30, 26, 12, 0, 19, 20, 21, 22, 35, 15, 23, 27, 11, 0, 23, 24, 25, 26, 35, 21, 10, 11, 27, 0, 27, 28, 29, 30, 35, 7, 19, 25, 3, 0, 31, 32, 33, 34, 35, 29, 2, 3, 25, 0, 35, 36, 37, 38, 35, 14, 12, 6, 13, 0, 39, 40, 41, 42, 35, 12, 18, 17, 6, 0, 43, 44, 45, 46, 35, 4, 3, 2, 1, 0, 47, 48, 49, 50, 35, 7, 3, 4, 8, 0, 51, 52, 53, 54, 35, 11, 10, 9, 5, 0, 55, 56, 57, 58, 35, 15, 11, 5, 16, 0, 59, 60, 61, 62, 35, 29, 25, 0, 28, 0, 63, 64, 65, 66, 35, 25, 19, 20, 0, 0, 67, 68, 69, 70, 35, 21, 27, 0, 20, 0, 71, 72, 73, 74, 35, 0, 27, 23, 24, 0, 75, 76, 77, 78, 35, 26, 30, 28, 0, 0, 79, 80, 81, 82, 35, 22, 26, 0, 24, 0, 83, 84, 85, 86, 35, 22, 24, 17, 18, 0, 87, 88, 89, 90, 34, 24, 16, 17, 0, 91, 92, 93, 35, 23, 15, 16, 24, 0, 94, 95, 96, 97, 34, 8, 9, 20, 0, 98, 99, 100, 35, 8, 20, 19, 7, 0, 101, 102, 103, 104, 35, 1, 2, 29, 28, 0, 105, 106, 107, 108, 34, 1, 28, 13, 0, 109, 110, 111, 35, 20, 9, 10, 21, 0, 112, 113, 114, 115, 35, 13, 28, 30, 14, 0, 116, 117, 118, 119, 35, 35, 39, 40, 36, 0, 120, 121, 122, 123, 35, 37, 44, 32, 35, 0, 124, 125, 126, 127, 35, 36, 47, 48, 37, 0, 128, 129, 130, 131, 34, 36, 37, 35, 0, 132, 133, 134, 35, 43, 49, 53, 57, 0, 135, 136, 137, 138, 35, 57, 61, 45, 43, 0, 139, 140, 141, 142, 35, 58, 54, 46, 42, 0, 143, 144, 145, 146, 35, 42, 41, 52, 58, 0, 147, 148, 149, 150, 35, 56, 50, 38, 34, 0, 151, 152, 153, 154, 35, 34, 33, 60, 56, 0, 155, 156, 157, 158, 35, 37, 43, 45, 44, 0, 159, 160, 161, 162, 35, 48, 49, 43, 37, 0, 163, 164, 165, 166, 35, 33, 34, 35, 32, 0, 167, 168, 169, 170, 35, 35, 34, 38, 39, 0, 171, 172, 173, 174, 35, 40, 41, 42, 36, 0, 175, 176, 177, 178, 35, 36, 42, 46, 47, 0, 179, 180, 181, 182, 35, 31, 56, 60, 59, 0, 183, 184, 185, 186, 35, 51, 50, 56, 31, 0, 187, 188, 189, 190, 35, 31, 58, 52, 51, 0, 191, 192, 193, 194, 35, 54, 58, 31, 55, 0, 195, 196, 197, 198, 35, 59, 61, 57, 31, 0, 199, 200, 201, 202, 35, 31, 57, 53, 55, 0, 203, 204, 205, 206, 35, 48, 55, 53, 49, 0, 207, 208, 209, 210, 34, 47, 55, 48, 0, 211, 212, 213, 35, 47, 46, 54, 55, 0, 214, 215, 216, 217, 34, 40, 39, 51, 0, 218, 219, 220, 35, 50, 51, 39, 38, 0, 221, 222, 223, 224, 35, 60, 33, 32, 59, 0, 225, 226, 227, 228, 34, 59, 32, 44, 0, 229, 230, 231, 35, 41, 40, 51, 52, 0, 232, 233, 234, 235, 35, 61, 59, 44, 45, 0, 236, 237, 238, 239, 35, 66, 70, 71, 67, 0, 240, 241, 242, 243, 35, 68, 75, 63, 66, 0, 244, 245, 246, 247, 35, 67, 78, 79, 68, 0, 248, 249, 250, 251, 34, 67, 68, 66, 0, 252, 253, 254, 35, 74, 80, 84, 88, 0, 255, 256, 257, 258, 35, 88, 92, 76, 74, 0, 259, 260, 261, 262, 35, 89, 85, 77, 73, 0, 263, 264, 265, 266, 35, 73, 72, 83, 89, 0, 267, 268, 269, 270, 35, 87, 81, 69, 65, 0, 271, 272, 273, 274, 35, 65, 64, 91, 87, 0, 275, 276, 277, 278, 35, 68, 74, 76, 75, 0, 279, 280, 281, 282, 35, 79, 80, 74, 68, 0, 283, 284, 285, 286, 35, 64, 65, 66, 63, 0, 287, 288, 289, 290, 35, 66, 65, 69, 70, 0, 291, 292, 293, 294, 35, 71, 72, 73, 67, 0, 295, 296, 297, 298, 35, 67, 73, 77, 78, 0, 299, 300, 301, 302, 35, 62, 87, 91, 90, 0, 303, 304, 305, 306, 35, 82, 81, 87, 62, 0, 307, 308, 309, 310, 35, 62, 89, 83, 82, 0, 311, 312, 313, 314, 35, 85, 89, 62, 86, 0, 315, 316, 317, 318, 35, 90, 92, 88, 62, 0, 319, 320, 321, 322, 35, 62, 88, 84, 86, 0, 323, 324, 325, 326, 35, 79, 86, 84, 80, 0, 327, 328, 329, 330, 34, 78, 86, 79, 0, 331, 332, 333, 35, 78, 77, 85, 86, 0, 334, 335, 336, 337, 34, 71, 70, 82, 0, 338, 339, 340, 35, 81, 82, 70, 69, 0, 341, 342, 343, 344, 35, 91, 64, 63, 90, 0, 345, 346, 347, 348, 34, 90, 63, 75, 0, 349, 350, 351, 35, 72, 71, 82, 83, 0, 352, 353, 354, 355, 35, 92, 90, 75, 76, 0, 356, 357, 358, 359, 35, 102, 101, 97, 98, 0, 360, 361, 362, 363, 35, 94, 106, 99, 97, 0, 364, 365, 366, 367, 35, 110, 109, 98, 99, 0, 368, 369, 370, 371, 34, 99, 98, 97, 0, 372, 373, 374, 35, 115, 111, 105, 119, 0, 375, 376, 377, 378, 35, 107, 123, 119, 105, 0, 379, 380, 381, 382, 35, 108, 116, 120, 104, 0, 383, 384, 385, 386, 35, 114, 103, 104, 120, 0, 387, 388, 389, 390, 35, 100, 112, 118, 96, 0, 391, 392, 393, 394, 35, 122, 95, 96, 118, 0, 395, 396, 397, 398, 35, 107, 105, 99, 106, 0, 399, 400, 401, 402, 35, 105, 111, 110, 99, 0, 403, 404, 405, 406, 35, 97, 96, 95, 94, 0, 407, 408, 409, 410, 35, 100, 96, 97, 101, 0, 411, 412, 413, 414, 35, 104, 103, 102, 98, 0, 415, 416, 417, 418, 35, 108, 104, 98, 109, 0, 419, 420, 421, 422, 35, 122, 118, 93, 121, 0, 423, 424, 425, 426, 35, 118, 112, 113, 93, 0, 427, 428, 429, 430, 35, 114, 120, 93, 113, 0, 431, 432, 433, 434, 35, 93, 120, 116, 117, 0, 435, 436, 437, 438, 35, 119, 123, 121, 93, 0, 439, 440, 441, 442, 35, 115, 119, 93, 117, 0, 443, 444, 445, 446, 35, 115, 117, 110, 111, 0, 447, 448, 449, 450, 34, 117, 109, 110, 0, 451, 452, 453, 35, 116, 108, 109, 117, 0, 454, 455, 456, 457, 34, 101, 102, 113, 0, 458, 459, 460, 35, 101, 113, 112, 100, 0, 461, 462, 463, 464, 35, 94, 95, 122, 121, 0, 465, 466, 467, 468, 34, 94, 121, 106, 0, 469, 470, 471, 35, 113, 102, 103, 114, 0, 472, 473, 474, 475, 35, 106, 121, 123, 107, 0, 476, 477, 478, 479, 35, 128, 132, 133, 129, 0, 480, 481, 482, 483, 35, 130, 137, 125, 128, 0, 484, 485, 486, 487, 35, 129, 140, 141, 130, 0, 488, 489, 490, 491, 34, 129, 130, 128, 0, 492, 493, 494, 35, 136, 142, 146, 150, 0, 495, 496, 497, 498, 35, 150, 154, 138, 136, 0, 499, 500, 501, 502, 35, 151, 147, 139, 135, 0, 503, 504, 505, 506, 35, 135, 134, 145, 151, 0, 507, 508, 509, 510, 35, 149, 143, 131, 127, 0, 511, 512, 513, 514, 35, 127, 126, 153, 149, 0, 515, 516, 517, 518, 35, 130, 136, 138, 137, 0, 519, 520, 521, 522, 35, 141, 142, 136, 130, 0, 523, 524, 525, 526, 35, 126, 127, 128, 125, 0, 527, 528, 529, 530, 35, 128, 127, 131, 132, 0, 531, 532, 533, 534, 35, 133, 134, 135, 129, 0, 535, 536, 537, 538, 35, 129, 135, 139, 140, 0, 539, 540, 541, 542, 35, 124, 149, 153, 152, 0, 543, 544, 545, 546, 35, 144, 143, 149, 124, 0, 547, 548, 549, 550, 35, 124, 151, 145, 144, 0, 551, 552, 553, 554, 35, 147, 151, 124, 148, 0, 555, 556, 557, 558, 35, 152, 154, 150, 124, 0, 559, 560, 561, 562, 35, 124, 150, 146, 148, 0, 563, 564, 565, 566, 35, 141, 148, 146, 142, 0, 567, 568, 569, 570, 34, 140, 148, 141, 0, 571, 572, 573, 35, 140, 139, 147, 148, 0, 574, 575, 576, 577, 34, 133, 132, 144, 0, 578, 579, 580, 35, 143, 144, 132, 131, 0, 581, 582, 583, 584, 35, 153, 126, 125, 152, 0, 585, 586, 587, 588, 34, 152, 125, 137, 0, 589, 590, 591, 35, 134, 133, 144, 145, 0, 592, 593, 594, 595, 35, 154, 152, 137, 138, 0, 596, 597, 598, 599, 35, 164, 163, 159, 160, 0, 600, 601, 602, 603, 35, 156, 168, 161, 159, 0, 604, 605, 606, 607, 35, 172, 171, 160, 161, 0, 608, 609, 610, 611, 34, 161, 160, 159, 0, 612, 613, 614, 35, 177, 173, 167, 181, 0, 615, 616, 617, 618, 35, 169, 185, 181, 167, 0, 619, 620, 621, 622, 35, 170, 178, 182, 166, 0, 623, 624, 625, 626, 35, 176, 165, 166, 182, 0, 627, 628, 629, 630, 35, 162, 174, 180, 158, 0, 631, 632, 633, 634, 35, 184, 157, 158, 180, 0, 635, 636, 637, 638, 35, 169, 167, 161, 168, 0, 639, 640, 641, 642, 35, 167, 173, 172, 161, 0, 643, 644, 645, 646, 35, 159, 158, 157, 156, 0, 647, 648, 649, 650, 35, 162, 158, 159, 163, 0, 651, 652, 653, 654, 35, 166, 165, 164, 160, 0, 655, 656, 657, 658, 35, 170, 166, 160, 171, 0, 659, 660, 661, 662, 35, 184, 180, 155, 183, 0, 663, 664, 665, 666, 35, 180, 174, 175, 155, 0, 667, 668, 669, 670, 35, 176, 182, 155, 175, 0, 671, 672, 673, 674, 35, 155, 182, 178, 179, 0, 675, 676, 677, 678, 35, 181, 185, 183, 155, 0, 679, 680, 681, 682, 35, 177, 181, 155, 179, 0, 683, 684, 685, 686, 35, 177, 179, 172, 173, 0, 687, 688, 689, 690, 34, 179, 171, 172, 0, 691, 692, 693, 35, 178, 170, 171, 179, 0, 694, 695, 696, 697, 34, 163, 164, 175, 0, 698, 699, 700, 35, 163, 175, 174, 162, 0, 701, 702, 703, 704, 35, 156, 157, 184, 183, 0, 705, 706, 707, 708, 34, 156, 183, 168, 0, 709, 710, 711, 35, 175, 164, 165, 176, 0, 712, 713, 714, 715, 35, 168, 183, 185, 169, 0, 716, 717, 718, 719, 35, 195, 194, 190, 191, 0, 720, 721, 722, 723, 35, 187, 199, 192, 190, 0, 724, 725, 726, 727, 35, 203, 202, 191, 192, 0, 728, 729, 730, 731, 34, 192, 191, 190, 0, 732, 733, 734, 35, 208, 204, 198, 212, 0, 735, 736, 737, 738, 35, 200, 216, 212, 198, 0, 739, 740, 741, 742, 35, 201, 209, 213, 197, 0, 743, 744, 745, 746, 35, 207, 196, 197, 213, 0, 747, 748, 749, 750, 35, 193, 205, 211, 189, 0, 751, 752, 753, 754, 35, 215, 188, 189, 211, 0, 755, 756, 757, 758, 35, 200, 198, 192, 199, 0, 759, 760, 761, 762, 35, 198, 204, 203, 192, 0, 763, 764, 765, 766, 35, 190, 189, 188, 187, 0, 767, 768, 769, 770, 35, 193, 189, 190, 194, 0, 771, 772, 773, 774, 35, 197, 196, 195, 191, 0, 775, 776, 777, 778, 35, 201, 197, 191, 202, 0, 779, 780, 781, 782, 35, 215, 211, 186, 214, 0, 783, 784, 785, 786, 35, 211, 205, 206, 186, 0, 787, 788, 789, 790, 35, 207, 213, 186, 206, 0, 791, 792, 793, 794, 35, 186, 213, 209, 210, 0, 795, 796, 797, 798, 35, 212, 216, 214, 186, 0, 799, 800, 801, 802, 35, 208, 212, 186, 210, 0, 803, 804, 805, 806, 35, 208, 210, 203, 204, 0, 807, 808, 809, 810, 34, 210, 202, 203, 0, 811, 812, 813, 35, 209, 201, 202, 210, 0, 814, 815, 816, 817, 34, 194, 195, 206, 0, 818, 819, 820, 35, 194, 206, 205, 193, 0, 821, 822, 823, 824, 35, 187, 188, 215, 214, 0, 825, 826, 827, 828, 34, 187, 214, 199, 0, 829, 830, 831, 35, 206, 195, 196, 207, 0, 832, 833, 834, 835, 35, 199, 214, 216, 200, 0, 836, 837, 838, 839, 35, 221, 225, 226, 222, 0, 840, 841, 842, 843, 35, 223, 230, 218, 221, 0, 844, 845, 846, 847, 35, 222, 233, 234, 223, 0, 848, 849, 850, 851, 34, 222, 223, 221, 0, 852, 853, 854, 35, 229, 235, 239, 243, 0, 855, 856, 857, 858, 35, 243, 247, 231, 229, 0, 859, 860, 861, 862, 35, 244, 240, 232, 228, 0, 863, 864, 865, 866, 35, 228, 227, 238, 244, 0, 867, 868, 869, 870, 35, 242, 236, 224, 220, 0, 871, 872, 873, 874, 35, 220, 219, 246, 242, 0, 875, 876, 877, 878, 35, 223, 229, 231, 230, 0, 879, 880, 881, 882, 35, 234, 235, 229, 223, 0, 883, 884, 885, 886, 35, 219, 220, 221, 218, 0, 887, 888, 889, 890, 35, 221, 220, 224, 225, 0, 891, 892, 893, 894, 35, 226, 227, 228, 222, 0, 895, 896, 897, 898, 35, 222, 228, 232, 233, 0, 899, 900, 901, 902, 35, 217, 242, 246, 245, 0, 903, 904, 905, 906, 35, 237, 236, 242, 217, 0, 907, 908, 909, 910, 35, 217, 244, 238, 237, 0, 911, 912, 913, 914, 35, 240, 244, 217, 241, 0, 915, 916, 917, 918, 35, 245, 247, 243, 217, 0, 919, 920, 921, 922, 35, 217, 243, 239, 241, 0, 923, 924, 925, 926, 35, 234, 241, 239, 235, 0, 927, 928, 929, 930, 34, 233, 241, 234, 0, 931, 932, 933, 35, 233, 232, 240, 241, 0, 934, 935, 936, 937, 34, 226, 225, 237, 0, 938, 939, 940, 35, 236, 237, 225, 224, 0, 941, 942, 943, 944, 35, 246, 219, 218, 245, 0, 945, 946, 947, 948, 34, 245, 218, 230, 0, 949, 950, 951, 35, 227, 226, 237, 238, 0, 952, 953, 954, 955, 35, 247, 245, 230, 231, 0, 956, 957, 958, 959]
    });
    return object.geometry;
  }

  return {
    setters: [function (_) {
      THREE = _['default'];
    }],
    execute: function () {
      _export('default', _build_selected_system_object());
    }
  };
});
$__System.register('17', ['1', '3', '18', 'f', 'b'], function (_export) {
  var SCMAP, THREE, LineSegments, _slicedToArray, config, SEGMENT_SIZE, BLACK;

  function furthestPOI(vector) {
    var furthest = 0,
        POI = undefined;

    SCMAP.allSystems.forEach(function (system) {
      var xd = vector.x - system.position.x;
      var zd = vector.z - system.position.z;
      var distance = Math.sqrt(xd * xd + zd * zd);
      if (distance > furthest) {
        furthest = distance;
        POI = system;
      }
    });

    return [furthest, POI];
  }

  function closestPOI(vector) {
    var closest = Infinity;
    var POI = undefined;

    SCMAP.allSystems.forEach(function (system) {
      var xd = vector.x - system.position.x;
      var zd = vector.z - system.position.z;
      var distance = Math.sqrt(xd * xd + zd * zd);
      if (distance < closest) {
        closest = distance;
        POI = system;
      }
    });

    return [closest, POI];
  }

  function closestFromArray(vector, systems) {
    var closest = Infinity;
    var POI = undefined;

    systems.forEach(function (system) {
      var xd = vector.x - system.position.x;
      var zd = vector.z - system.position.z;
      var distance = Math.sqrt(xd * xd + zd * zd);
      if (distance < closest) {
        closest = distance;
        POI = system;
      }
    });

    return [closest, POI];
  }

  // Get a quick list of systems nearby (within a square) to speed
  // up further filtering a little bit.
  function withinApproxDistance(vector, distance) {
    var systems = [];

    SCMAP.allSystems.forEach(function (system) {
      if (system.position.x < vector.x - distance) {
        return;
      }
      if (system.position.x > vector.x + distance) {
        return;
      }
      if (system.position.z < vector.z - distance) {
        return;
      }
      if (system.position.z > vector.z + distance) {
        return;
      }
      systems.push(system);
    });

    return systems;
  }

  function colorForVector(vector, systems) {
    var color = BLACK;

    var _closestFromArray = closestFromArray(vector, systems);

    var _closestFromArray2 = _slicedToArray(_closestFromArray, 2);

    var distance = _closestFromArray2[0];
    var system = _closestFromArray2[1];

    if (system && distance <= 4.5 * SEGMENT_SIZE) {
      color = system.faction.planeColor.clone();

      if (distance >= 4.0 * SEGMENT_SIZE) {
        color.multiplyScalar(0.5);
      } else if (distance >= 3.0 * SEGMENT_SIZE) {
        color.multiplyScalar(0.8);
      }
    }

    return color;
  }

  function buildReferenceGrid() {
    var startTime = new Date().getTime();
    var geo = new THREE.BufferGeometry();
    var uniqueColours = {};
    var grid = [];

    var alongX = [];
    var minX = 0,
        minZ = 0,
        maxX = 0,
        maxZ = 0;

    // First we compute rough outer bounds based on all the systems on the map
    // (plus a bit extra because we want to fade to black as well)
    SCMAP.allSystems.forEach(function (system) {
      if (system.position.x < minX) {
        minX = system.position.x - 6 * 10;
      }
      if (system.position.x > maxX) {
        maxX = system.position.x + 8 * 10;
      }
      if (system.position.z < minZ) {
        minZ = system.position.z - 6 * 10;
      }
      if (system.position.z > maxZ) {
        maxZ = system.position.z + 10 * 10;
      }
    });

    // Now round those numbers to a multiple of SEGMENT_SIZE
    minX = Math.floor(minX / SEGMENT_SIZE) * SEGMENT_SIZE;
    minZ = Math.floor(minZ / SEGMENT_SIZE) * SEGMENT_SIZE;
    maxX = Math.floor(maxX / SEGMENT_SIZE) * SEGMENT_SIZE;
    maxZ = Math.floor(maxZ / SEGMENT_SIZE) * SEGMENT_SIZE;

    // With the boundaries established, go through each coordinate
    // on the map, and set the colour for each gridpoint on the
    // map with the nearest system's faction being used for that
    // colour. We also take note of each X coordinate visited.
    // There is a bit of room for optimisation left here; the
    // systems could be sorted by a X or Z coordinate, sort of like
    // in an octree, and could possibly be found quicker that way.
    for (var iz = minZ; iz <= maxZ; iz += SEGMENT_SIZE) {

      grid[iz] = [];

      for (var ix = minX; ix <= maxX; ix += SEGMENT_SIZE) {

        alongX[ix] = true;

        var vector = new THREE.Vector3(ix, 0, iz);
        var systems = withinApproxDistance(vector, 6.5 * SEGMENT_SIZE);
        var color = colorForVector(vector, systems);

        if (color !== BLACK) {
          grid[iz][ix] = color.getHexString();
          if (uniqueColours[grid[iz][ix]] === undefined) {
            uniqueColours[grid[iz][ix]] = color;
          }
        } else {
          grid[iz][ix] = null;
          uniqueColours[null] = BLACK;
        }
      }
    }

    // Now for both X and Z we build a sorted list of each of
    // those coordinates seen, allowing for quick iteration.
    var alongX2 = [];for (var j in alongX) {
      alongX2.push(j);
    }
    alongX = alongX2.sort(function (a, b) {
      return a - b;
    });

    var alongZ = [];for (var j in grid) {
      alongZ.push(j);
    }
    alongZ.sort(function (a, b) {
      return a - b;
    });

    var lines = new LineSegments();

    // Now we got most data worked out, and we can start drawing
    // the horizontal lines. We draw a line from start vertex to
    // end vertex for each section where the colour doesn't
    // change, which gives us the fewest number of lines drawn.
    for (var i = 1; i < alongZ.length; i += 1) {
      var z = alongZ[i];
      var vertices = [];
      var vertexColours = [];

      for (var j = 1; j < alongX.length; j += 1) {
        var x = alongX[j];
        var left = Math.floor(Number(x) - SEGMENT_SIZE);
        var right = Math.floor(Number(x) + SEGMENT_SIZE);

        var vertexColor = grid[z][x];

        if (vertexColor !== grid[z][left] && grid[z][left] || vertexColor !== grid[z][right] && grid[z][right]) {
          vertices.push(new THREE.Vector3(x, 0, z));
          vertexColours.push(uniqueColours[vertexColor]);
        }
      }

      for (var k = 0; k < vertices.length - 1; k += 1) {
        lines.addColoredLine(vertices[k], vertexColours[k], vertices[k + 1], vertexColours[k + 1]);
      }
    }

    // And do the same for the vertical lines in a separate pass
    for (var i = 1; i < alongX.length; i += 1) {
      var x = alongX[i];
      var vertices = [];
      var vertexColours = [];

      for (var j = 1; j < alongZ.length; j += 1) {
        var z = alongZ[j];
        var above = Math.floor(Number(z) - SEGMENT_SIZE);
        var below = Math.floor(Number(z) + SEGMENT_SIZE);

        var vertexColor = grid[z][x];

        if (grid[above] && grid[above][x] && vertexColor !== grid[above][x] || grid[below] && grid[below][x] && vertexColor !== grid[below][x]) {
          vertices.push(new THREE.Vector3(x, 0, z));
          vertexColours.push(uniqueColours[vertexColor]);
        }
      }

      for (var k = 0; k < vertices.length - 1; k += 1) {
        lines.addColoredLine(vertices[k], vertexColours[k], vertices[k + 1], vertexColours[k + 1]);
      }
    }

    var mesh = lines.mesh();

    console.log('Building the grid reference plane took ' + (new Date().getTime() - startTime) + ' msec');

    return mesh;
  }

  return {
    setters: [function (_) {
      SCMAP = _['default'];
    }, function (_3) {
      THREE = _3['default'];
    }, function (_2) {
      LineSegments = _2['default'];
    }, function (_f) {
      _slicedToArray = _f['default'];
    }, function (_b) {
      config = _b['default'];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      'use strict';

      SEGMENT_SIZE = 10 * config.renderScale;
      BLACK = new THREE.Color(0x000000);

      _export('buildReferenceGrid', buildReferenceGrid);
    }
  };
});
$__System.register('19', ['3', '7', '8', '9', '1b', '1c', '1a', 'b'], function (_export) {
  var THREE, settings, _createClass, _classCallCheck, _get, _inherits, MapGeometry, config, STAR_LOD_MESHES, SystemsGeometry;

  return {
    setters: [function (_4) {
      THREE = _4['default'];
    }, function (_3) {
      settings = _3['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_b) {
      _get = _b['default'];
    }, function (_c) {
      _inherits = _c['default'];
    }, function (_a) {
      MapGeometry = _a['default'];
    }, function (_b2) {
      config = _b2['default'];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      'use strict';

      STAR_LOD_MESHES = undefined;

      if (config.quality === 'low') {
        STAR_LOD_MESHES = [[new THREE.IcosahedronGeometry(1, 1), 20], [new THREE.IcosahedronGeometry(1, 0), 500]];
      } else {
        STAR_LOD_MESHES = [[new THREE.IcosahedronGeometry(1, 3), 20], [new THREE.IcosahedronGeometry(1, 2), 150], [new THREE.IcosahedronGeometry(1, 1), 250], [new THREE.IcosahedronGeometry(1, 0), 500]];
      }

      SystemsGeometry = (function (_MapGeometry) {
        _inherits(SystemsGeometry, _MapGeometry);

        function SystemsGeometry() {
          _classCallCheck(this, SystemsGeometry);

          _get(Object.getPrototypeOf(SystemsGeometry.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(SystemsGeometry, [{
          key: 'refreshLOD',
          value: function refreshLOD(camera) {
            this._mesh.traverse(function (obj) {
              if (obj.userData.isLOD) {
                obj.update(camera);
              }
            });
          }
        }, {
          key: 'refreshScale',
          value: function refreshScale() {
            this._mesh.traverse(function (obj) {
              if (obj.userData.isSystem) {
                obj.scale.set(settings.systemScale, settings.systemScale, settings.systemScale);
                obj.updateMatrix();
              }
            });
          }
        }, {
          key: 'mesh',
          get: function get() {
            if (this._mesh) {
              return this._mesh;
            }

            var group = new THREE.Object3D();
            group.name = 'Star Systems Geometry';
            this._mesh = group;

            var material = new THREE.MeshBasicMaterial({ name: 'Star material' });

            try {
              this.allSystems.forEach(function (system) {
                // Build a LOD mesh for the stars to make them properly rounded
                // when viewed up close yet low on geometry at a distance
                var starLOD = new THREE.LOD();

                for (var i = 0; i < STAR_LOD_MESHES.length; i++) {
                  var star = new THREE.Mesh(STAR_LOD_MESHES[i][0], material);
                  star.scale.set(system.scale * config.renderScale, system.scale * config.renderScale, system.scale * config.renderScale);
                  star.updateMatrix();
                  star.matrixAutoUpdate = false;
                  starLOD.addLevel(star, STAR_LOD_MESHES[i][1]);
                }

                starLOD.position.copy(system.position);
                starLOD.updateMatrix();
                starLOD.matrixAutoUpdate = false;
                starLOD.userData.isSystem = true;
                starLOD.userData.isLOD = true;

                group.add(starLOD);
              });

              group.dynamic = false;
            } catch (e) {
              console.error('Problem creating systems geometry:', e);
              throw e;
            }

            // Set the 2d/3d tween callback
            group.userData.scaleY = SystemsGeometry.scaleY;

            SystemsGeometry.scaleY(group, this.initialScale);
            this.refreshScale();

            return group;
          }
        }], [{
          key: 'scaleY',
          value: function scaleY(mesh, _scaleY) {
            mesh.scale.y = _scaleY;
            mesh.updateMatrix();
          }
        }]);

        return SystemsGeometry;
      })(MapGeometry);

      _export('default', SystemsGeometry);
    }
  };
});
$__System.register('1d', ['6', '8', '9', '1e'], function (_export) {
  var StarSystem, _createClass, _classCallCheck, Vector3, JumpPoint;

  return {
    setters: [function (_3) {
      StarSystem = _3['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_e) {
      Vector3 = _e.Vector3;
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      'use strict';

      JumpPoint = (function () {
        function JumpPoint(data) {
          _classCallCheck(this, JumpPoint);

          //this.id = data.jumpPointId;
          this.name = typeof data.name === 'string' && data.name.length > 1 ? data.name : undefined;
          this.source = data.source instanceof StarSystem ? data.source : undefined;
          this.destination = data.destination instanceof StarSystem ? data.destination : undefined;
          this.drawn = false;
          this.type = typeof data.type === 'string' ? data.type : 'UNDISC';
          this.size = typeof data.size === 'string' ? data.size : 'S';
          this.status = typeof data.status === 'string' ? data.status : 'P';
          this.direction = typeof data.direction === 'string' ? data.direction : 'S';

          this.entryAU = new Vector3();
          if (Array.isArray(data.entryAU)) {
            this.entryAU.fromArray(data.entryAU);
          }

          if (!this.isValid()) {
            console.warn('Invalid route created', this);
          } else {
            if (this.name === undefined || this.name === '') {
              this.name = '[' + this.source.name + ' to ' + this.destination.name + ']';
            }
          }
        }

        _createClass(JumpPoint, [{
          key: 'length',
          value: function length() {
            if (!this.isValid()) {
              return;
            }
            return this.source.position.distanceTo(this.destination.position);
          }
        }, {
          key: 'jumpTime',
          value: function jumpTime() {
            if (!this.isValid()) {
              return;
            }
            // TODO FIXME: This is a rough guesstimate on how long it will take
            // to travel a JP, and not based in any facts ... no word from devs
            // on this so far.
            return this.length() * 4; // 2 mins for 30LY, ~Sol to Vega (27LY)
          }
        }, {
          key: 'fuelConsumption',
          value: function fuelConsumption() {
            if (!this.isValid()) {
              return;
            }
            // TODO: Devs have stated that JP's don't consume fuel to traverse.
            // If that changes, this needs to be quantified and fixed.
            return 0;
          }
        }, {
          key: 'getOppositeJumppoint',
          value: function getOppositeJumppoint() {
            for (var i = 0; i < this.destination.jumpPoints.length; i++) {
              var jumppoint = this.destination.jumpPoints[i];
              if (jumppoint.destination == this.source) {
                return jumppoint;
              }
            }
          }
        }, {
          key: 'isValid',
          value: function isValid() {
            return this.source instanceof StarSystem && this.destination instanceof StarSystem && this.source !== this.destination;
          }
        }, {
          key: 'isUnconfirmed',
          value: function isUnconfirmed() {
            return this.type === 'UNCONF' || this.type === 'UNDISC';
          }
        }, {
          key: 'setDrawn',
          value: function setDrawn() {
            this.drawn = true;
          }
        }, {
          key: 'distanceInLY',
          get: function get() {
            if (!this.isValid()) {
              return;
            }
            return this.source.position.distanceTo(this.destination.position);
          }
        }]);

        return JumpPoint;
      })();

      _export('default', JumpPoint);
    }
  };
});
$__System.register('18', ['3', '8', '9'], function (_export) {
  var THREE, _createClass, _classCallCheck, LineSegments;

  return {
    setters: [function (_3) {
      THREE = _3['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      'use strict';

      LineSegments = (function () {
        function LineSegments() {
          _classCallCheck(this, LineSegments);

          this._positions = [];
          this._colors = [];
          this._indices = [];
          this.index = 0;
        }

        _createClass(LineSegments, [{
          key: 'addLine',
          value: function addLine(v1, v2) {
            if (this.index >= THREE.BufferGeometry.MaxIndex) {
              throw new Error('Too many points');
            }

            this._positions.push(v1.x, v1.y, v1.z);
            this._positions.push(v2.x, v2.y, v2.z);
            this._indices.push(this.index, this.index + 1);
            return this.index += 2;
          }
        }, {
          key: 'addColoredLine',
          value: function addColoredLine(v1, c1, v2, c2) {
            if (this.index >= THREE.BufferGeometry.MaxIndex) {
              throw new Error('Too many points');
            }

            this._positions.push(v1.x, v1.y, v1.z);
            this._colors.push(c1.r, c1.g, c1.b);

            this._positions.push(v2.x, v2.y, v2.z);
            this._colors.push(c2.r, c2.g, c2.b);

            this._indices.push(this.index, this.index + 1);

            return this.index += 2;
          }
        }, {
          key: 'geometry',
          value: function geometry() {
            this._geometry = new THREE.BufferGeometry();

            if (THREE.BufferGeometry.MaxIndex > 65535 && this._indices.length > 65535) {
              this._geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(this._indices), 1));
            } else {
              this._geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(this._indices), 1));
            }

            if (this._positions.length) {
              this._geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(this._positions), 3));
            }

            if (this._colors.length) {
              this._geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(this._colors), 3));
            }

            this._geometry.dynamic = false;
            this._geometry.computeBoundingBox();

            return this._geometry;
          }
        }, {
          key: 'mesh',
          value: function mesh(color) {
            if (!color) {
              color = 0xFFFFFF;
            }

            var vertexColors = THREE.NoColors;
            if (this._colors.length) {
              vertexColors = THREE.VertexColors;
            }

            var material = new THREE.LineBasicMaterial({ vertexColors: vertexColors, color: color });
            var mesh = new THREE.LineSegments(this.geometry(), material);
            mesh.matrixAutoUpdate = false;
            return mesh;
          }
        }]);

        return LineSegments;
      })();

      _export('default', LineSegments);
    }
  };
});
$__System.register('1f', ['3', '8', '9', '18', '1b', '1c', '1a', '1d', 'b'], function (_export) {
  var THREE, _createClass, _classCallCheck, LineSegments, _get, _inherits, MapGeometry, JumpPoint, config, JumpPoints;

  return {
    setters: [function (_4) {
      THREE = _4['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_3) {
      LineSegments = _3['default'];
    }, function (_b) {
      _get = _b['default'];
    }, function (_c) {
      _inherits = _c['default'];
    }, function (_a) {
      MapGeometry = _a['default'];
    }, function (_d) {
      JumpPoint = _d['default'];
    }, function (_b2) {
      config = _b2['default'];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      //const MATERIALS = {
      //  NORMAL: new THREE.LineBasicMaterial({
      //    color: 0xFFFFFF,
      //    linewidth: 2,
      //    vertexColors: true,
      //  }),
      //  UNDISC: new THREE.LineDashedMaterial({
      //    color: 0xFFFFFF,
      //    dashSize: 0.75,
      //    gapSize: 0.75,
      //    linewidth: 2,
      //    vertexColors: true,
      //  }),
      //  UNCONF: new THREE.LineDashedMaterial({
      //    color: 0xFFFFFF,
      //    dashSize: 2,
      //    gapSize: 2,
      //    linewidth: 2,
      //    vertexColors: true,
      //  }),
      //};
      //
      //const DEFAULT_MATERIAL = MATERIALS.UNCONF;

      'use strict';

      JumpPoints = (function (_MapGeometry) {
        _inherits(JumpPoints, _MapGeometry);

        function JumpPoints() {
          _classCallCheck(this, JumpPoints);

          _get(Object.getPrototypeOf(JumpPoints.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(JumpPoints, [{
          key: 'mesh',
          get: function get() {
            if (this._mesh) {
              return this._mesh;
            }

            var jumpLines = new LineSegments();

            this.allSystems.forEach(function (system) {

              system.jumpPoints.forEach(function (jumpPoint) {

                if (!jumpPoint.drawn) {
                  // TODO: Maybe this can be done more efficiently?
                  var sourceVec = jumpPoint.source.position.clone().sub(jumpPoint.destination.position);
                  sourceVec.setLength(sourceVec.length() - 3 * config.renderScale * jumpPoint.source.scale);
                  sourceVec.add(jumpPoint.destination.position);

                  // TODO: Maybe this can be done more efficiently?
                  var destVec = jumpPoint.destination.position.clone().sub(jumpPoint.source.position);
                  destVec.setLength(destVec.length() - 3 * config.renderScale * jumpPoint.destination.scale);
                  destVec.add(jumpPoint.source.position);

                  jumpLines.addColoredLine(sourceVec, jumpPoint.source.faction.lineColor, destVec, jumpPoint.destination.faction.lineColor);
                  jumpPoint.setDrawn();

                  var oppositeJumppoint = jumpPoint.getOppositeJumppoint();
                  if (oppositeJumppoint instanceof JumpPoint) {
                    oppositeJumppoint.setDrawn();
                  }
                }
              });
            });

            this._mesh = jumpLines.mesh();

            // Set the 2d/3d tween callback
            this._mesh.userData.scaleY = JumpPoints.scaleY;

            JumpPoints.scaleY(this._mesh, this.initialScale);

            return this._mesh;
          }
        }], [{
          key: 'scaleY',
          value: function scaleY(mesh, _scaleY) {
            mesh.scale.y = _scaleY;
            mesh.updateMatrix();
          }

          //getMaterial () {
          //  if ( this.type in MATERIALS ) {
          //    return MATERIALS[ this.type ];
          //  } else {
          //    return DEFAULT_MATERIAL;
          //  }
          //}
        }]);

        return JumpPoints;
      })(MapGeometry);

      _export('default', JumpPoints);
    }
  };
});
$__System.registerDynamic("20", ["21", "22", "23"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('21'),
      get = $__require('22');
  module.exports = $__require('23').getIterator = function(it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function')
      throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("24", ["25", "26", "20"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('25');
  $__require('26');
  module.exports = $__require('20');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("27", ["24"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('24'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("28", ["29", "2a", "2b", "23"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('29'),
      ITERATOR = $__require('2a')('iterator'),
      Iterators = $__require('2b');
  module.exports = $__require('23').isIterable = function(it) {
    var O = Object(it);
    return O[ITERATOR] !== undefined || '@@iterator' in O || Iterators.hasOwnProperty(classof(O));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2c", ["25", "26", "28"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('25');
  $__require('26');
  module.exports = $__require('28');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2d", ["2c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('2c'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f", ["27", "2d"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _getIterator = $__require('27')["default"];
  var _isIterable = $__require('2d')["default"];
  exports["default"] = (function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = _getIterator(arr),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (_isIterable(Object(arr))) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.register('2e', ['8', '9'], function (_export) {
  var _createClass, _classCallCheck, KnapsackRectangle;

  return {
    setters: [function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }],
    execute: function () {
      /**
      Describes a rectangular area witin the knapsack. Abstracts the basic math away from the {@link module:texture-manager/knapsack/node|`KnapsackNode`} module.
      
      @module texture-manager/knapsack/rectangle
      */

      /**
       * @constructor
       * @param {integer} left - Left most pixel index of this rectangle (0 to `right` - 1 )
       * @param {integer} top - Top most pixel index of this rectangle (0 to `bottom` - 1 )
       * @param {integer} right - Right most pixel index of this rectangle
       * @param {integer} bottom - Bottom most pixel index of this rectangle
      */

      'use strict';

      KnapsackRectangle = (function () {
        function KnapsackRectangle(left, top, right, bottom) {
          _classCallCheck(this, KnapsackRectangle);

          this.left = Math.floor(typeof left === 'number' && isFinite(left) ? left : 0);
          this.top = Math.floor(typeof top === 'number' && isFinite(top) ? top : 0);
          this.right = Math.floor(typeof right === 'number' && isFinite(right) ? right : 0);
          this.bottom = Math.floor(typeof bottom === 'number' && isFinite(bottom) ? bottom : 0);
        }

        /**
         * The center X coordinate of this rectangle.
         * @type {integer}
         * @readonly
         */

        _createClass(KnapsackRectangle, [{
          key: 'Xcentre',
          get: function get() {
            return Math.floor((this.right - this.left) / 2 + this.left) - 0.5;
          }

          /**
           * The center Y coordinate of this rectangle.
           * @type {integer}
           * @readonly
           */
        }, {
          key: 'Ycentre',
          get: function get() {
            return Math.floor((this.bottom - this.top) / 2 + this.top) - 0.5;
          }

          /**
           * The width of this rectangle in pixels.
           * @type {integer}
           * @readonly
           */
        }, {
          key: 'width',
          get: function get() {
            return this.right - this.left;
          }

          /**
           * The height of this rectangle in pixels.
           * @type {integer}
           * @readonly
           */
        }, {
          key: 'height',
          get: function get() {
            return this.bottom - this.top;
          }
        }]);

        return KnapsackRectangle;
      })();

      _export('default', KnapsackRectangle);
    }
  };
});
$__System.register('2f', ['8', '9', '2e'], function (_export) {
  var _createClass, _classCallCheck, KnapsackRectangle, KnapsackNode;

  return {
    setters: [function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_e) {
      KnapsackRectangle = _e['default'];
    }],
    execute: function () {
      /**
      Represents a single rectangular area "node" within a texture atlas canvas, which may have its own {@link external:Texture|`THREE.Texture`} with the UV coordinates managed for you. These nodes are created through {@link module:texture-manager#allocateNode|`allocateNode()`}.
      
      The implementation is based on [http://www.blackpawn.com/texts/lightmaps/default.html](http://www.blackpawn.com/texts/lightmaps/default.html). Visit that page for a good impression of what we're achieving here.
      
      See http://jsfiddle.net/Shiari/sbda72k9/ for a more complete and working example than the one below.
      
      @module texture-manager/knapsack/node
      @example
      tetureManager.allocateNode( 100, 20 ).then(
        function( node ) {
          // Do something with the node in this Promise, like create
          // a sprite.
        },
        function( error ) {
          // Promise was rejected
          console.error( "Could not allocate node:", error );
        }
      );
      */

      /**
       * Do not use this directly, it is managed for you.
       * @constructor
       * @param {Knapsack} - The {@link module:texture-manager/knapsack|`Knapsack`} this node is to become a part of.
       */
      'use strict';

      KnapsackNode = (function () {
        function KnapsackNode(knapsack) {
          _classCallCheck(this, KnapsackNode);

          /**
           * Reference to the {@link module:texture-manager/knapsack|`Knapsack`} this node is a part of
           * @type {Knapsack}
           * @private
           * @readonly
           * @category provider
           */
          this.knapsack = knapsack;

          /**
           * Optional reference to the "left" side {@link module:texture-manager/knapsack/node|`KnapsackNode`} branch of the tree of nodes.
           * @type {KnapsackNode}
           * @private
           * @readonly
           * @category provider
           */
          this.leftChild = null;

          /**
           * Optional reference to the "right" side {@link module:texture-manager/knapsack/node|`KnapsackNode`} branch of the tree of nodes.
           * @type {KnapsackNode}
           * @private
           * @readonly
           * @category provider
           */
          this.rightChild = null;

          /**
           * Describes the coordinates which are the boundaries of this node.
           * @type {KnapsackRectangle}
           * @private
           * @readonly
           * @category information
           */
          this.rectangle = null;
          // Overwritten when children are created, but done as a default here to keep
          // the code cleaner. Instantiating this object is pretty cheap anyway.
          this.rectangle = new KnapsackRectangle(0, 0, knapsack.textureSize, knapsack.textureSize);

          /**
           * Internal unique ID for the image this node represents.
           * @type {string}
           * @private
           * @readonly
           * @category information
           */
          this.imageID = null;

          this._texture = null;
        }

        /**
         * The HTML `<canvas>` element as supplied by the {@link module:texture-manager/knapsack|`Knapsack`} which this node is part of.
         * @type {external:canvas}
         * @readonly
         * @category provider
         */

        _createClass(KnapsackNode, [{
          key: 'hasChildren',

          /**
           * Returns true if this node has any children, which means it's not available to be drawn in. Its children may be suitable for this though.
           * @returns {boolean}
           * @category information
           * @private
           */
          value: function hasChildren() {
            return this.leftChild !== null || this.rightChild !== null;
          }

          /**
           * Returns true if this node is available to be used by a texture (i.e. it's not yet been claimed by {@link module:texture-manager/knapsack/node#claim|`claim()`}.
           * @returns {boolean} Indicates whether this node has been claimed or not.
           * @category information
           * @private
           */
        }, {
          key: 'isOccupied',
          value: function isOccupied() {
            return this.imageID !== null;
          }

          /**
           * The UV coordinates which describe where in the texture this node is located. This is probably not of any practical use to you as a user of this library; it is used internally to map the texture correctly to a sprite.
           * @returns {Array} Array with [ left, top, right, bottom ] coordinates.
           * @category information
           * @example
           * var uvs = node.uvCoordinates();
           * var left   = uvs[ 0 ];
           * var top    = uvs[ 1 ];
           * var right  = uvs[ 2 ];
           * var bottom = uvs[ 3 ];
           */
        }, {
          key: 'uvCoordinates',
          value: function uvCoordinates() {
            var size = this.knapsack.textureSize;
            return [this.rectangle.left / size, 1 - this.rectangle.bottom / size, this.rectangle.right / size, 1 - this.rectangle.top / size];
          }

          /**
           * Release this node back to the {@link module:texture-manager/knapsack|`Knapsack`} where it is contained. This makes it available to be used by new sprites. Only nodes without children can be released, but a user of this library will only get these leaf nodes returned. Branch nodes are used internally only.
           * @category allocation
           * @example
           * node.release();
           * // or, if you like typing:
           * textureManager.release( node );
           */
        }, {
          key: 'release',
          value: function release() {
            if (this.hasChildren()) {
              throw new Error('Can not release tree node, still has children');
            }

            if (this._texture !== null) {
              this._texture.dispose();
              this._texture = null;
            }

            this.clear();
            this.imageID = null;

            return;
          }

          /**
           * Clear the area of this node: it erases the context so that it is empty and transparent, and ready to be drawn to.
           * @category drawing
           * @example
           * // Erase the contents of the sprite
           * node.clear();
           */
        }, {
          key: 'clear',
          value: function clear() {
            this.context.clearRect(this.rectangle.left, this.rectangle.top, this.width - 1, this.height - 1);
          }

          /**
           * Set the drawing context tailored towards the area of the sprite, clipping anything outside of it. When done drawing, use {@link module:texture-manager/knapsack/node#restoreContext|`restoreContext()`} to restore the original drawing context.
           * @returns {CanvasRenderingContext2D} Render context configured exclusively for the sprite we're working on.
           * @category drawing
           * @example
           * var context = node.clipContext();
           * // Draw a 5px border along the edge of the sprite, some
           * // of it will fall outside the area, but it is clipped.
           * context.lineWidth = 5.0;
           * context.strokeStyle = 'rgba(255,0,0,1)';
           * context.strokeRect( 0, 0, node.width, node.height );
           * // other drawing commands
           * node.restoreContext();
           */
        }, {
          key: 'clipContext',
          value: function clipContext() {
            var ctx = this.context;
            ctx.save();
            ctx.beginPath();
            ctx.rect(this.rectangle.left + 1, this.rectangle.top + 1, this.width - 2, this.height - 2);
            ctx.clip();
            ctx.translate(this.rectangle.Xcentre, this.rectangle.Ycentre);
            return ctx;
          }

          /**
           * Restore the draw context of the {@link module:texture-manager/knapsack/node#canvas|`canvas`}. Call this when done drawing the sprite.
           * @category drawing
           * @example
           * var context = node.clipContext();
           * // Draw a 5px border along the edge of the sprite, some
           * // of it will fall outside the area, but it is clipped.
           * context.lineWidth = 5.0;
           * context.strokeStyle = 'rgba(255,0,0,1)';
           * context.strokeRect( 0, 0, node.width, node.height );
           * // other drawing commands
           * node.restoreContext();
           */
        }, {
          key: 'restoreContext',
          value: function restoreContext() {
            this.context.restore();
          }

          /**
           * Allocate a node in this {@link module:texture-manager/knapsack|`Knapsack`} for the given width and height. This is the main workhorse of this library.
           * @param {integer} width
           * @param {integer} height
           * @returns {KnapsackNode} A new node which describes a rectangular area in the knapsack.
           * @ignore
           * @category allocation
           */
        }, {
          key: 'allocate',
          value: function allocate(width, height) {
            // If we're not a leaf node
            if (this.hasChildren()) {
              // then try inserting into our first child
              var newNode = this.leftChild.allocate(width, height);
              if (newNode instanceof KnapsackNode) {
                newNode.claim();
                return newNode;
              }

              // There was no room: try to insert into second child
              return this.rightChild.allocate(width, height);
            } else {
              // if there's already an image here, return
              if (this.isOccupied()) {
                return null;
              }

              // if this node is too small, give up here
              if (width > this.width || height > this.height) {
                return null;
              }

              // if we're just the right size, accept
              if (width === this.width && height === this.height) {
                this.claim();
                return this;
              }

              // otherwise, got to split this node and create some kids
              this.leftChild = new KnapsackNode(this.knapsack);
              this.rightChild = new KnapsackNode(this.knapsack);

              // now decide which way to split
              var remainingWidth = this.width - width;
              var remainingHeight = this.height - height;

              if (remainingWidth > remainingHeight) {
                // horizontal split
                this.leftChild.rectangle = new KnapsackRectangle(this.rectangle.left, this.rectangle.top, this.rectangle.left + width, this.rectangle.bottom);

                this.rightChild.rectangle = new KnapsackRectangle(this.rectangle.left + width, this.rectangle.top, this.rectangle.right, this.rectangle.bottom);
              } else {
                // vertical split
                this.leftChild.rectangle = new KnapsackRectangle(this.rectangle.left, this.rectangle.top, this.rectangle.right, this.rectangle.top + height);

                this.rightChild.rectangle = new KnapsackRectangle(this.rectangle.left, this.rectangle.top + height, this.rectangle.right, this.rectangle.bottom);
              }

              // Some crude painting to help troubleshooting
              if (this.knapsack.textureManager.debug) {
                var context = this.context;
                context.lineWidth = 4.0;
                context.strokeStyle = 'rgba(255,0,0,1)';
                context.strokeRect(this.leftChild.rectangle.left, this.leftChild.rectangle.top, this.leftChild.width, this.leftChild.height);

                context.lineWidth = 4.0;
                context.strokeStyle = 'rgba(0,255,0,1)';
                context.strokeRect(this.rightChild.rectangle.left, this.rightChild.rectangle.top, this.rightChild.width, this.rightChild.height);
              }

              // Recurse into the first child to continue the allocation
              return this.leftChild.allocate(width, height);
            }
          }

          /**
           * Claim the node to be in use by giving it a (unique) ID for an image, this prevents it from being used for another image. After calling this method it is ready to be drawn.
           * @ignore
           * @category allocation
           */
        }, {
          key: 'claim',
          value: function claim() {
            this.imageID = THREE.Math.generateUUID();

            // Some crude painting to help troubleshooting
            if (this.knapsack.textureManager.debug) {
              var context = this.context;
              context.lineWidth = 2.0;
              context.strokeStyle = 'rgba( 0, 0, 255, 1 )';
              context.strokeRect(this.rectangle.left + 0.5, this.rectangle.top + 0.5, this.width - 1, this.height - 1);
            }
          }
        }, {
          key: 'canvas',
          get: function get() {
            return this.knapsack.canvas;
          }

          /**
           * Convenience accessor for the {@link external:CanvasRenderingContext2D} which is associated with the {@link module:texture-manager/knapsack/node#canvas}. You can use this context to draw on the entire canvas, but you'll probably want to use {@link module:texture-manager/knapsack/node#clipContext|`clipContext()`} instead.
           * @type {external:CanvasRenderingContext2D}
           * @readonly
           * @category provider
           */
        }, {
          key: 'context',
          get: function get() {
            return this.knapsack.canvas.getContext('2d');
          }

          /**
           * The width in pixels of this sprite's texture node.
           * @type {integer}
           * @readonly
           * @category information
           * @example
           * textureManager.allocateNode( 30, 10 ).then( function( node ) {
           *   console.log( node.width ); // => 30
           * });
           */
        }, {
          key: 'width',
          get: function get() {
            return this.rectangle.width;
          }

          /**
           * The height in pixels of this sprite's texture node.
           * @type {integer}
           * @readonly
           * @category information
           * @example
           * textureManager.allocateNode( 30, 10 ).then( function( node ) {
           *   console.log( node.height ); // => 10
           * });
           */
        }, {
          key: 'height',
          get: function get() {
            return this.rectangle.height;
          }

          /**
           * Lazily built {@link external:Texture|`THREE.Texture`}, with it's UV coordinates already set for you. You can pass this texture straight to your material, and the GPU memory it requires should be shared with all other texture nodes on the same texture.
           * @type {external:Texture}
           * @readonly
           * @category provider
           * @example
           * var material = new THREE.SpriteMaterial({
           *   map: node.texture,
           *   transparent: true,
           *   blending: THREE.AdditiveBlending
           * });
           * var sprite = new THREE.Sprite( material );
           * scene.add( sprite );
           */
        }, {
          key: 'texture',
          get: function get() {
            if (!this._texture) {
              this._texture = this.knapsack.rootTexture.clone();
              this._texture.uuid = this.knapsack.rootTexture.uuid;
              var uvs = this.uvCoordinates();
              this.texture.offset.x = uvs[0];
              this.texture.offset.y = uvs[1];
              this.texture.repeat.x = uvs[2] - uvs[0];
              this.texture.repeat.y = uvs[3] - uvs[1];
            }
            return this._texture;
          }
        }]);

        return KnapsackNode;
      })();

      _export('default', KnapsackNode);
    }
  };
});
$__System.register('30', ['8', '9', '2f'], function (_export) {
  var _createClass, _classCallCheck, KnapsackNode, Knapsack;

  return {
    setters: [function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_f) {
      KnapsackNode = _f['default'];
    }],
    execute: function () {
      /**
      Represents a single texture atlas with several sprites and its corresponding base {@link external:Texture|`THREE.Texture`}. You do not interact with this class directly, it is entirely managed for you by a {@link module:texture-manager|`TextureManager`} instance. Documented only to satisfy the curiosity of fellow developers stumbling upon this.
      
      @module texture-manager/knapsack
       */

      /**
        * @constructor
        * @param {TextureManager} textureManager - The {@link module:texture-manager|`TextureManager`} which created this `Knapsack`
        * @param {integer} size - The size of the texture
        */
      'use strict';

      Knapsack = (function () {
        function Knapsack(textureManager, size) {
          _classCallCheck(this, Knapsack);

          this.textureManager = textureManager;
          this.textureSize = size;
          this.textureLoaded = false;
          this.rootNode = new KnapsackNode(this);
          // Lazy initialising these:
          this._rootTexture = null;
          this._canvas = null;
        }

        /**
         * Lazily built HTML `<canvas>` element for this `Knapsack`.
         * @type {external:canvas}
         * @readonly
         */

        _createClass(Knapsack, [{
          key: 'allocateNode',

          /**
           * Proxy method, allocate a texture atlas node for a sprite image of `width` by `height` pixels.
           * @param {integer} width
           * @param {integer} height
           * @returns {external:Promise}
           */
          value: function allocateNode(width, height) {
            return this.rootNode.allocate(width, height);
          }
        }, {
          key: 'canvas',
          get: function get() {
            if (!this._canvas) {
              this._canvas = document.createElement('canvas');
              this._canvas.width = this.textureSize;
              this._canvas.height = this.textureSize;
            }
            return this._canvas;
          }

          /**
           * Lazily built {@link external:Texture|`THREE.Texture`}, this is created as a "master" texture. Each node will get its own `.clone()`, which should be shared in memory.
           * @type {external:Texture}
           * @readonly
           */
        }, {
          key: 'rootTexture',
          get: function get() {
            if (!this._rootTexture) {
              this._rootTexture = new THREE.Texture(this.canvas, THREE.UVMapping);
            }
            return this._rootTexture;
          }
        }]);

        return Knapsack;
      })();

      _export('default', Knapsack);
    }
  };
});
$__System.register('31', ['8', '9', '30', '32'], function (_export) {
  var _createClass, _classCallCheck, Knapsack, _Promise, TextureManager;

  return {
    setters: [function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_4) {
      Knapsack = _4['default'];
    }, function (_3) {
      _Promise = _3['default'];
    }],
    execute: function () {
      /**
      Build and destroy "nodes" in your texture atlas easily. It builds one or more {@link module:texture-manager/knapsack|`Knapsack`} objects for you, each of which represent a separate square texture atlas with one or more sprite textures of a size defined by you.
      
      @module texture-manager
      
      @example
      // From github:
      // $ npm install --save-dev leeft/three-sprite-texture-atlas-manager
      // from npm:
      // $ npm install --save-dev three-sprite-texture-atlas-manager
      //
      // Through ES2015 (ES6) modules (highly recommended):
      import TextureManager from 'three-sprite-texture-atlas-manager';
      var textureManager = new TextureManager();
      
      // Node.js or CommonJS require():
      // then:
      var TextureManager = require('three-sprite-texture-atlas-manager');
      var textureManager = new TextureManager();
      
      // global namespace
      var textureManager = new window.threeSpriteAtlasTextureManager();
       *
       */

      /**
        * @constructor
        * @param {integer} [size=1024] Optional size for the textures. Must be a power of two.
        * @example
        * // We want 512x512 pixel textures
        * var textureManager = new TextureManager( 512 );
        * ...
        * textureManager.allocateNode( ... );
        */
      'use strict';

      TextureManager = (function () {
        function TextureManager(size) {
          _classCallCheck(this, TextureManager);

          /**
           * The size of the textures as was validated when constructing the object.
           * @namespace module:texture-manager~TextureManager#size
           * @type {integer}
           * @ignore
           * @category readonly
           */
          this.size = typeof size === 'number' && /^(128|256|512|1024|2048|4096|8192|16384)$/.test(size) ? size : 1024;

          /**
           * As the texture manager allocates nodes, it creates a new {@link module:texture-manager/knapsack|`Knapsack`} when it needs to provide space for nodes. This is an array with all the knapsacks which have been created.
           * @namespace module:texture-manager~TextureManager#knapsacks
           * @type {Knapsack[]}
           * @readonly
           * @category readonly
           * @example
           * // Show the canvases in the DOM element with id="canvases"
           * // (you'd normally do this from the browser console)
           * textureManager.knapsacks.forEach( function( knapsack ) {
           *   document.getElementById('canvases').appendChild( knapsack.canvas );
           * });
           */
          this.knapsacks = [];

          /**
           * The debug property can be set to `true` after instantiating the object, which will make the {@link module:texture-manager/knapsack/node|`KnapsackNode`} class draw outlines as it allocates nodes. This can make it much more obvious what is going on, such as whether your text is properly sized and centered.
           * @namespace module:texture-manager~TextureManager#debug
           * @type {boolean}
           * @example
           * textureManager.debug = true;
           */
          this.debug = false;
        }

        /**
         * Add a new knapsack to the texture manager.
         * @param {integer} size
         * @returns {Knapsack}
         * @ignore
         */

        _createClass(TextureManager, [{
          key: '_addKnapsack',
          value: function _addKnapsack(size) {
            var knapsack = new Knapsack(this, size);
            this.knapsacks.push(knapsack);
            if (this.debug) {
              console.log('TextureManager: allocated ' + this.textureSize + 'px texture map #' + this.knapsacks.length);
            }
            return knapsack;
          }

          /**
           * The actual used size of the texture.
           * @type {integer}
           * @readonly
           * @category readonly
           */
        }, {
          key: 'allocate',

          /**
           * Allocate a texture atlas node for a sprite image of `width` by `height` pixels. Unlike allocateNode, it does not return a {external:Promise} and it works synchronously.
           * @param {integer} width
           * @param {integer} height
           * @returns {KnapsackNode}
           * @category allocation
           * @throws {Error} The given with and height must fit in the texture.
           * @example
           * let node = textureManager.allocate( 100, 20 );
           */
          value: function allocate(width, height) {
            var node = null;

            // Prevent allocating knapsacks when there's no chance to fit the node
            // FIXME TODO: try a bigger texture size if it doesn't fit?
            this._validateSize(width, height);
            return this._allocate(width, height);
          }

          /**
           * {external:Promise} based version of {@link allocate}.
           *
           * This method will require you to use a {external:Promise} polyfill if you want to support IE11 or older, as that browser doesn't support promises natively.
           * @param {integer} width
           * @param {integer} height
           * @returns {external:Promise}
           * @category allocation
           * @example
           * textureManager.allocateNode( 100, 20 ).then(
           *   function( node ) {
           *     // Do something with the node in this Promise, such as
           *     // creating a sprite and adding it to the scene.
           *   },
           *   function( error ) {
           *     // Promise was rejected
           *     console.error( "Could not allocate node:", error );
           *   }
           * );
           */
        }, {
          key: 'allocateNode',
          value: function allocateNode(width, height) {
            var _this = this;

            return new _Promise(function (resolve, reject) {
              try {
                // Prevent allocating knapsacks when there's no chance to fit the node
                // FIXME TODO: try a bigger texture size if it doesn't fit?
                _this._validateSize(width, height);
                resolve(_this._allocate(width, height));
              } catch (error) {
                reject(error);
              };
            });
          }

          /**
           * Asynchronously allocate a texture atlas node for a sprite image of `width` by `height` pixels. Returns a result through resolving the promise. The asynchronous approach will potentially allow for better optimisation of packing nodes in the texture space.
           *
           * When done adding nodes, you should call {@link solveASync}. Your queued promises will then be settled. But note that the {external:Promise} will still be rejected straight away if the given width or height don't fit.
           * @param {integer} width
           * @param {integer} height
           * @returns {external:Promise}
           * @category allocation
           * @example
           * // First prepare all your node allocations:
           * [ 1, 2, 3 ].forEach( function() {
           *   textureManager.allocateASync( 100, 20 ).then(
           *     function( node ) {
           *       // Do something with the node in this Promise, such as
           *       // creating a sprite and adding it to the scene.
           *       // Note: this promise won't succesfully settle until
           *       // after you also called solveASync!
           *     },
           *     function( error ) {
           *       // Promise was rejected
           *       console.error( "Could not allocate node:", error );
           *     }
           *   );
           * });
           * // Then resolve all the outstanding allocations:
           * textureManager.solveASync().then( function( result ) {
           *   console.log( `${ result.length } allocations have resolved` );
           * });
           */
        }, {
          key: 'allocateASync',
          value: function allocateASync(width, height) {
            var _this2 = this;

            if (!Array.isArray(this._queue)) {
              this._queue = [];
            }

            var queueEntry = undefined;

            var promise = new _Promise(function (resolve, reject) {
              try {
                // Prevent allocating knapsacks when there's no chance to fit the node
                // FIXME TODO: try a bigger texture size if it doesn't fit?
                _this2._validateSize(width, height);
                // Queue our resolution, which will be settled with .solveASync()
                queueEntry = {
                  resolve: resolve,
                  reject: reject,
                  width: width,
                  height: height
                };
              } catch (error) {
                reject(error);
              };
            });

            if (queueEntry) {
              queueEntry.promise = promise;
              this._queue.push(queueEntry);
            }

            return promise;
          }

          /**
           * Trigger resolution of any outstanding node allocation promises, i.e. those that have been created with {@link allocateASync}. Call this when you've added nodes, or their promises will not settle.
           *
           * This is by design, as postponing of the node allocation makes it possible for the texture manager to optimise packing of the texture space in the most efficient manner possible.
           * @returns {external:Promise}
           * @category allocation
           * @throws {Error} You're trying to resolve a queue which hasn't been set up. Call {@link allocateASync} at least once before calling this.
           * @example
           * textureManager.solveASync().then( function( count ) {
           *   console.log( `${ count } node allocations have been resolved` );
           * });
           */
        }, {
          key: 'solveASync',
          value: function solveASync() {
            var _this3 = this;

            if (!Array.isArray(this._queue)) {
              throw new Error('You\'re trying to resolve a queue which hasn\'t been set up. Call allocateASync before using this.');
            }

            var promises = [];

            this._queue.forEach(function (entry) {
              var promise = entry.promise;
              var resolve = entry.resolve;
              var reject = entry.reject;
              var width = entry.width;
              var height = entry.height;

              var node = _this3._allocate(width, height);
              resolve(node);
              promises.push(promise);
            });

            this._queue = [];

            return _Promise.all(promises);
          }

          /**
           * Low level helper to assert whether the given width and height will fit.
           * @param {integer} width
           * @param {integer} height
           * @category allocation
           * @throws {Error} Width of <number> is too large for these textures.
           * @throws {Error} Height of <number> is too large for these textures.
           * @private
           * @ignore
           */
        }, {
          key: '_validateSize',
          value: function _validateSize(width, height) {
            if (width > this.textureSize) {
              throw new Error('Width of ' + width + ' is too large for these textures');
            }

            if (height > this.textureSize) {
              throw new Error('Height of ' + height + ' is too large for these textures');
            }
          }

          /**
           * Low level helper to allocate a texture atlas node for a sprite image of `width` by `height` pixels.
           * @param {integer} width
           * @param {integer} height
           * @returns {KnapsackNode}
           * @category allocation
           * @private
           * @ignore
           */
        }, {
          key: '_allocate',
          value: function _allocate(width, height) {
            var node = null;

            // First try to get a node from the existing knapsacks
            this.knapsacks.forEach(function (knapsack) {
              if (node === null || node === undefined) {
                node = knapsack.allocateNode(width, height);
              }
            });

            // Didn't get a node yet but it *should* fit, so make a new texture atlas with the same size
            if (node === null) {
              var knapsack = this._addKnapsack(this.textureSize);
              node = knapsack.allocateNode(width, height);
            }

            return node;
          }

          /**
           * Release the given node.
           * @param {KnapsackNode} node
           * @category allocation
           * @example
           * textureManager.release( node );
           */
        }, {
          key: 'release',
          value: function release(node) {
            if (node) {
              node.release();
            }
          }
        }, {
          key: 'textureSize',
          get: function get() {
            return this.size;
          }
        }]);

        return TextureManager;
      })();

      _export('default', TextureManager);
    }
  };
});
$__System.register('33', ['8', '9', '31', '34', 'f'], function (_export) {
  var _createClass, _classCallCheck, TextureManager, _Object$assign, _slicedToArray, DEFAULTS, Label;

  return {
    setters: [function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_4) {
      TextureManager = _4['default'];
    }, function (_3) {
      _Object$assign = _3['default'];
    }, function (_f) {
      _slicedToArray = _f['default'];
    }],
    execute: function () {
      'use strict';

      DEFAULTS = {
        fontFamily: '\'Segoe UI\', \'Lucida Grande\', \'Tahoma\', \'Calibri\', \'Roboto\', sans-serif',
        scale: 1.0, // Overall scale, this affects all the other values as well
        bold: false,
        textHeight: 64, // in px
        textVerticalOffset: 8.5, // number of 'scale' units the text is shifted by
        textAlign: 'center',
        textBaseline: 'middle',
        fillStyle: 'rgb(255,255,128)',
        strokeStyle: 'rgb(0,0,0)',
        paddingX: 6, // number of 'scale' units to add to the width
        paddingY: 36.5, // number of 'scale' units to add to the height
        outline: 2.4,
        opacity: 0.75
      };

      Label = (function () {
        function Label() {
          var _this = this;

          _classCallCheck(this, Label);

          _Object$assign(this, DEFAULTS, arguments[0]);

          // Force a check for these important properties
          ['textureManager', 'text'].forEach(function (prop) {
            _this[prop] = _this[prop];
          });
        }

        _createClass(Label, [{
          key: 'measureSprite',
          value: function measureSprite() {
            var canvas = document.createElement('canvas');
            canvas.width = canvas.height = 1;

            var context = canvas.getContext('2d');
            context.font = this.fontStyle;

            return [Math.ceil(context.measureText(this.text).width + this.paddingX * this.scale), Math.ceil((this.textHeight + this.paddingY) * this.scale)];
          }
        }, {
          key: 'redraw',
          value: function redraw() {
            this.isDirty = true;
            return this.buildSprite();
          }
        }, {
          key: 'buildSprite',
          value: function buildSprite() {
            if (this.isDirty) {
              var node = this.node;
              try {
                node.clear();
                var context = node.clipContext();
                this.drawSprite(context, node);
                node.restoreContext();
                node.texture.needsUpdate = true;
                this.isDirty = false;
              } catch (e) {
                node.restoreContext();
                throw e;
              }
            }

            return this.sprite;
          }
        }, {
          key: 'destroy',
          value: function destroy() {
            if (this.hasSprite) {
              if (this._sprite.parent) {
                this._sprite.parent.remove(this._sprite);
              }
              this._sprite = null;
            }

            if (this.hasNode) {
              this.textureManager.release(this.node);
              this._node = null;
            }

            if (this.hasMaterial) {
              this._material = null;
            }
          }
        }, {
          key: 'drawSprite',
          value: function drawSprite(context, node) {
            context.font = this.fontStyle;
            context.textAlign = this.textAlign;
            context.textBaseline = this.textBaseline;
            context.fillStyle = this.fillStyle;
            context.lineCap = 'round';
            context.lineJoin = 'round';
            context.lineWidth = this.outline * this.scale;
            context.miterLimit = 2;
            context.fillText(this.text, 0, this.textVerticalOffset * this.scale);
            context.strokeStyle = this.strokeStyle;
            context.strokeText(this.text, 0, this.textVerticalOffset * this.scale);
          }
        }, {
          key: 'textureManager',
          get: function get() {
            return this._textureManager;
          },
          set: function set(tm) {
            if (this._textureManager && tm !== this._textureManager) {
              throw new Error('Create new label instead of resetting the texture-manager');
            }
            // FIXME: This check doesn't work well in practice
            //if ( ! ( tm instanceof TextureManager ) ) {
            //  throw new TypeError('No texture-manager instance supplied');
            //}
            this._textureManager = tm;
          }
        }, {
          key: 'fontStyle',
          get: function get() {
            if (this.bold) {
              return 'Bold ' + (this.textHeight * this.scale).toFixed(0) + 'px ' + this.fontFamily;
            } else {
              return (this.textHeight * this.scale).toFixed(0) + 'px ' + this.fontFamily;
            }
          }
        }, {
          key: 'text',
          set: function set(text) {
            if (!(typeof text === 'string') || !text.trim().length > 0) {
              throw new Error('No text supplied for the label');
            }

            text = text.trim();

            if (text === this._text) {
              return;
            }

            this.isDirty = true;
            this._text = text;
          },
          get: function get() {
            return this._text;
          }
        }, {
          key: 'hasNode',
          get: function get() {
            return this._node !== undefined && this._node !== null;
          }
        }, {
          key: 'node',
          get: function get() {
            if (this.hasNode && !this.isDirty) {
              return this._node;
            }

            var _measureSprite = this.measureSprite();

            var _measureSprite2 = _slicedToArray(_measureSprite, 2);

            var width = _measureSprite2[0];
            var height = _measureSprite2[1];

            var node = this._node;

            if (this.hasNode) {
              // Check whether the current rendering still fits in the node
              if (width <= node.width && height <= node.height) {
                // If it does, the existing node should be somewhat similarly
                // sized, or we'll just have to get a new one
                //
                // TODO: These numbers may require further tweaking!
                if (width / node.width > 0.9 && height / node.height > 0.9) {
                  return node;
                }
              }

              node.release();
            }

            this._node = node = this.textureManager.allocate(width, height);
            this.isDirty = true;

            // Trigger a refresh of the SpriteMaterial, builds it if needed
            this.material;

            return node;
          }
        }, {
          key: 'hasMaterial',
          get: function get() {
            return this._material !== null && this._material !== undefined;
          }
        }, {
          key: 'material',
          get: function get() {
            if (this.hasMaterial) {
              if (!this.isDirty) {
                return this._material;
              }

              this._material.map = this.node.texture;
              this._material.needsUpdate = true;
            } else {
              this._material = new THREE.SpriteMaterial({
                map: this.node.texture,
                transparent: true,
                opacity: this.opacity
              });
            }

            return this._material;
          }
        }, {
          key: 'hasSprite',
          get: function get() {
            return this._sprite !== null && this._sprite !== undefined;
          }
        }, {
          key: 'sprite',
          get: function get() {
            if (this.hasSprite) {
              return this._sprite;
            }

            this._sprite = new THREE.Sprite(this.material);
            return this._sprite;
          }
        }]);

        return Label;
      })();

      _export('default', Label);
    }
  };
});
$__System.register('35', ['8', '9', '33', '1b', '1c', 'f'], function (_export) {
  var _createClass, _classCallCheck, Label, _get, _inherits, _slicedToArray, IconLabel;

  return {
    setters: [function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_3) {
      Label = _3['default'];
    }, function (_b) {
      _get = _b['default'];
    }, function (_c) {
      _inherits = _c['default'];
    }, function (_f) {
      _slicedToArray = _f['default'];
    }],
    execute: function () {
      'use strict';

      IconLabel = (function (_Label) {
        _inherits(IconLabel, _Label);

        function IconLabel() {
          var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

          var _ref$icons = _ref.icons;
          var icons = _ref$icons === undefined ? [] : _ref$icons;
          var _ref$iconSize = _ref.iconSize;
          var iconSize = _ref$iconSize === undefined ? 24 : _ref$iconSize;
          var _ref$iconSpacing = _ref.iconSpacing;
          var iconSpacing = _ref$iconSpacing === undefined ? 2 : _ref$iconSpacing;
          var _ref$iconVerticalOffset = _ref.iconVerticalOffset;
          var iconVerticalOffset = _ref$iconVerticalOffset === undefined ? -32 : _ref$iconVerticalOffset;
          var _ref$lineWidth = _ref.lineWidth;
          var lineWidth = _ref$lineWidth === undefined ? 4 : _ref$lineWidth;
          var _ref$debugIconDrawing = _ref.debugIconDrawing;
          var debugIconDrawing = _ref$debugIconDrawing === undefined ? false : _ref$debugIconDrawing;

          _classCallCheck(this, IconLabel);

          _get(Object.getPrototypeOf(IconLabel.prototype), 'constructor', this).apply(this, arguments);
          this.icons = icons;
          this.iconSize = iconSize;
          this.iconSpacing = iconSpacing;
          this.iconVerticalOffset = iconVerticalOffset; // number of scale 1.0 units the icons are shifted by
          this.lineWidth = lineWidth;
          this.debugIconDrawing = debugIconDrawing;
        }

        _createClass(IconLabel, [{
          key: 'measureSprite',
          value: function measureSprite() {
            var _get$call = _get(Object.getPrototypeOf(IconLabel.prototype), 'measureSprite', this).call(this);

            var _get$call2 = _slicedToArray(_get$call, 2);

            var width = _get$call2[0];
            var height = _get$call2[1];

            var calculatedWidth = 0,
                calculatedHeight = 0;
            if (this.icons.length) {
              // Take a little extra to compensate for possible overflow on the edges:
              // (note that width and height here are already corrected for scale by the parent)
              calculatedWidth = this.iconsWidth() + this.iconSize / 2 * this.scale;
              calculatedHeight = this.iconsHeight();
            }

            return [Math.ceil(Math.max(calculatedWidth, width)), Math.ceil(Math.max(calculatedHeight, height))];
          }
        }, {
          key: 'iconsWidth',
          value: function iconsWidth() {
            // 3 x icons gives 2 x spacing, so that yields "[X].[X].[X]"
            return Math.ceil((this.iconSize * this.icons.length + this.iconSpacing * (this.icons.length - 1)) * this.scale // and correct for scale
            );
          }
        }, {
          key: 'iconsHeight',
          value: function iconsHeight() {
            return Math.ceil(this.iconSize * this.scale);
          }
        }, {
          key: 'drawSprite',
          value: function drawSprite(context, node) {
            var _this = this;

            _get(Object.getPrototypeOf(IconLabel.prototype), 'drawSprite', this).apply(this, arguments);

            if (!this.icons.length) {
              return;
            }

            // Note: the code calling drawSprite puts us at the centre of the sprite.
            // Drawing must be offset accordingly!

            // All these values are .scale corrected
            var iconsWidth = this.iconsWidth();
            var iconsHeight = this.iconsHeight();
            var iconSize = this.iconSize * this.scale;
            var iconSpacing = this.iconSpacing * this.scale;
            var halfIcon = iconSize / 2;
            var verticalOffset = this.iconVerticalOffset * this.scale;
            var x = -(iconsWidth / 2);

            if (this.debugIconDrawing) {
              context.beginPath();
              context.rect(x, verticalOffset - iconSize / 2, // x, y
              iconsWidth, iconsHeight);
              context.lineWidth = 4 * this.scale;
              context.strokeStyle = 'rgba(255,255,0,0.7)';
              context.stroke();
              context.closePath();
            }

            this.icons.forEach(function (symbol) {

              var offX = 0,
                  offY = 0;
              if (typeof symbol.offset === 'object' && 'x' in symbol.offset && 'y' in symbol.offset) {
                offX = symbol.offset.x * _this.scale;
                offY = symbol.offset.y * _this.scale;
              }

              context.font = (_this.iconSize * symbol.scale * _this.scale).toFixed(2) + 'px ' + symbol.fontFamily;
              context.strokeStyle = _this.strokeStyle;
              context.textAlign = 'center'; // TODO: more user control?
              context.lineWidth = _this.lineWidth * _this.scale;
              context.textBaseline = 'middle'; // TODO: more user control?
              context.strokeText(symbol.code, x + offX + halfIcon, verticalOffset + offY);
              context.fillStyle = symbol.color;
              context.fillText(symbol.code, x + offX + halfIcon, verticalOffset + offY);

              if (_this.debugIconDrawing) {
                context.beginPath();
                context.rect(offX + x, verticalOffset + offY - halfIcon, // x, y
                iconSize - 1.5, iconSize - 1.5);
                // w, h
                context.lineWidth = 3 * _this.scale;
                context.strokeStyle = 'rgba(255,0,0,0.7)';
                context.stroke();
                context.closePath();
              }

              x += iconSize + iconSpacing;
            });
          }
        }, {
          key: 'icons',
          get: function get() {
            return this._icons;
          },
          set: function set(array) {
            this._icons = array;
            this.isDirty = true;

            if (this.hasSprite) {
              this.buildSprite();
            }
          }
        }]);

        return IconLabel;
      })(Label);

      _export('default', IconLabel);
    }
  };
});
$__System.register('36', ['3', '7', '8', '9', '35', '1b', '1c', '1a', 'b'], function (_export) {
  var THREE, settings, _createClass, _classCallCheck, IconLabel, _get, _inherits, MapGeometry, config, SystemLabels;

  return {
    setters: [function (_5) {
      THREE = _5['default'];
    }, function (_3) {
      settings = _3['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_4) {
      IconLabel = _4['default'];
    }, function (_b) {
      _get = _b['default'];
    }, function (_c) {
      _inherits = _c['default'];
    }, function (_a) {
      MapGeometry = _a['default'];
    }, function (_b2) {
      config = _b2['default'];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      'use strict';

      SystemLabels = (function (_MapGeometry) {
        _inherits(SystemLabels, _MapGeometry);

        function SystemLabels() {
          _classCallCheck(this, SystemLabels);

          _get(Object.getPrototypeOf(SystemLabels.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(SystemLabels, [{
          key: 'refreshIcons',
          value: function refreshIcons() {
            this.allSystems.forEach(function (system) {
              system.refreshIcons();
            });
          }
        }, {
          key: 'matchRotation',
          value: function matchRotation(rotationMatrix) {
            var vector = new THREE.Vector3(0, -(settings.labelOffset * config.renderScale), -0.1);
            this._mesh.position.copy(vector.applyMatrix4(rotationMatrix));
          }
        }, {
          key: 'refreshVisibility',
          value: function refreshVisibility() {
            this._mesh.traverse(function (obj) {
              if (obj.userData.isLabel && obj.userData.system) {
                obj.visible = settings.labels;
              }
            });
          }
        }, {
          key: 'refreshScale',
          value: function refreshScale() {
            this._mesh.traverse(function (obj) {
              if (obj.userData.system && obj.userData.isLabel) {
                obj.userData.system.refreshScale(obj.userData.system.labelScale);
              }
            });
          }
        }, {
          key: 'mesh',
          get: function get() {
            var _this = this;

            if (this._mesh) {
              return this._mesh;
            }

            var group = new THREE.Group();
            this._mesh = group;

            try {
              this.allSystems.forEach(function (system) {
                var icons = settings.labelIcons ? system.getIcons() : [];

                system.label = new IconLabel({
                  textureManager: _this.renderer.textureManager,
                  text: system.name,
                  fillStyle: system.factionStyle(),
                  bold: true,
                  icons: icons
                });

                if (config.quality === 'low') {
                  system.label.scale = 0.75;
                  system.label.opacity = 1.0;
                }

                if (system.isUnknown()) {
                  system.label.scale *= 0.5;
                }

                system.label.sprite.position.copy(system.position);
                system.label.sprite.userData.system = system;
                system.label.sprite.userData.isLabel = true;
                system.label.sprite.userData.position = system.position.clone();
                system.label.redraw();

                group.add(system.label.sprite);
              });
            } catch (e) {
              console.error('Problem creating glow sprites:', e);
              throw e;
            }

            // Set the 2d/3d tween callback
            group.userData.scaleY = SystemLabels.scaleY;

            group.userData.isLabelGroup = true;
            group.dynamic = false;
            group.updateMatrix();

            this.refreshVisibility();
            this.refreshScale();

            // Compensate the position of the labels so it's shown straight above
            // the star system irrespective of camera rotation.
            this.matchRotation(this.renderer.cameraRotationMatrix());

            SystemLabels.scaleY(group, this.initialScale);

            return group;
          }
        }], [{
          key: 'scaleY',
          value: function scaleY(mesh, _scaleY) {
            mesh.traverse(function (obj) {
              if (obj.userData.system && obj.userData.isLabel) {
                obj.position.setY(obj.userData.position.y * _scaleY);
              }
            });
          }
        }]);

        return SystemLabels;
      })(MapGeometry);

      _export('default', SystemLabels);
    }
  };
});
$__System.register('37', ['3', '8', '9', '1b', '1c', '1a', 'b'], function (_export) {
  var THREE, _createClass, _classCallCheck, _get, _inherits, MapGeometry, config, INTERACTABLE_DEBUG_MATERIAL, Interactables;

  return {
    setters: [function (_3) {
      THREE = _3['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_b) {
      _get = _b['default'];
    }, function (_c) {
      _inherits = _c['default'];
    }, function (_a) {
      MapGeometry = _a['default'];
    }, function (_b2) {
      config = _b2['default'];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      // Change to SpriteMaterial to visualise
      'use strict';

      INTERACTABLE_DEBUG_MATERIAL = new THREE.MeshBasicMaterial({
        color: 0xFFFF00,
        depthWrite: false,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      });

      Interactables = (function (_MapGeometry) {
        _inherits(Interactables, _MapGeometry);

        function Interactables() {
          _classCallCheck(this, Interactables);

          _get(Object.getPrototypeOf(Interactables.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(Interactables, [{
          key: 'getIntersect',
          value: function getIntersect(event) {
            var x = undefined,
                y = undefined;
            if (event.touches && event.touches.length > 0) {
              x = event.touches[0].pageX;
              y = event.touches[0].pageY;
            } else {
              x = event.clientX;
              y = event.clientY;
            }

            var vector = new THREE.Vector3(x / window.innerWidth * 2 - 1, -(y / window.innerHeight) * 2 + 1, 0.5);
            vector.unproject(this.renderer.controls.object);

            var raycaster = new THREE.Raycaster(this.renderer.controls.object.position, vector.sub(this.renderer.controls.object.position).normalize());

            var intersects = raycaster.intersectObjects(this.mesh.children);
            return intersects[0];
          }
        }, {
          key: 'mesh',
          get: function get() {
            if (this._mesh) {
              return this._mesh;
            }

            var group = new THREE.Group();
            this._mesh = group;

            try {
              this.allSystems.forEach(function (system) {

                // To make systems easier to click, we add an invisible sprite to them
                // (perhaps also easier for the raycaster) and use that as the object
                // to interact with rather than the other objects. The interactable
                // is a bit larger than the system itself.
                var interactable = new THREE.Sprite(INTERACTABLE_DEBUG_MATERIAL);
                var interactableSize = Math.min(6.5, Math.max(5.5, 7 * system.scale));
                interactable.position.copy(system.position);
                interactable.scale.set(interactableSize * config.renderScale, interactableSize * config.renderScale, interactableSize * config.renderScale);
                interactable.userData.system = system;
                interactable.userData.isInteractable = true;
                interactable.userData.position = system.position.clone();

                group.add(interactable);
              });
            } catch (e) {
              console.error('Problem creating interactable sprites:', e);
              throw e;
            }

            // Set the 2d/3d tween callback
            group.userData.scaleY = Interactables.scaleY;

            group.dynamic = false;
            group.updateMatrix();

            Interactables.scaleY(group, this.initialScale);

            return group;
          }
        }], [{
          key: 'scaleY',
          value: function scaleY(mesh, _scaleY) {
            mesh.traverse(function (obj) {
              if (obj.userData.system && obj.userData.isInteractable) {
                obj.position.setY(obj.userData.position.y * _scaleY);
              }
            });
          }
        }]);

        return Interactables;
      })(MapGeometry);

      _export('default', Interactables);
    }
  };
});
$__System.registerDynamic("38", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("39", ["3a", "3b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('3a'),
      defined = $__require('3b');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("26", ["39", "3c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $at = $__require('39')(true);
  $__require('3c')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3d", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function() {};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3e", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3f", ["40", "41", "42", "43", "2a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('40'),
      descriptor = $__require('41'),
      setToStringTag = $__require('42'),
      IteratorPrototype = {};
  $__require('43')(IteratorPrototype, $__require('2a')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3c", ["44", "45", "46", "43", "47", "2b", "3f", "42", "40", "2a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var LIBRARY = $__require('44'),
      $export = $__require('45'),
      redefine = $__require('46'),
      hide = $__require('43'),
      has = $__require('47'),
      Iterators = $__require('2b'),
      $iterCreate = $__require('3f'),
      setToStringTag = $__require('42'),
      getProto = $__require('40').getProto,
      ITERATOR = $__require('2a')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY && kind in proto)
        return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED)
        for (key in methods) {
          if (!(key in proto))
            redefine(proto, key, methods[key]);
        }
      else
        $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("48", ["3d", "3e", "2b", "49", "3c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var addToUnscopables = $__require('3d'),
      step = $__require('3e'),
      Iterators = $__require('2b'),
      toIObject = $__require('49');
  module.exports = $__require('3c')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("25", ["48", "2b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('48');
  var Iterators = $__require('2b');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("44", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4a", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4b", ["21"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('21');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4c", ["2b", "2a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Iterators = $__require('2b'),
      ITERATOR = $__require('2a')('iterator'),
      ArrayProto = Array.prototype;
  module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3a", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4d", ["3a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('3a'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("29", ["4e", "2a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('4e'),
      TAG = $__require('2a')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2b", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("22", ["29", "2a", "2b", "23"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('29'),
      ITERATOR = $__require('2a')('iterator'),
      Iterators = $__require('2b');
  module.exports = $__require('23').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4f", ["50", "4b", "4c", "21", "4d", "22"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('50'),
      call = $__require('4b'),
      isArrayIter = $__require('4c'),
      anObject = $__require('21'),
      toLength = $__require('4d'),
      getIterFn = $__require('22');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("51", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("52", ["21", "53", "2a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('21'),
      aFunction = $__require('53'),
      SPECIES = $__require('2a')('species');
  module.exports = function(O, D) {
    var C = anObject(O).constructor,
        S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("54", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("55", ["56"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('56').document && document.documentElement;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("57", ["58", "56"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('58'),
      document = $__require('56').document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("59", ["50", "54", "55", "57", "56", "4e", "5a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ctx = $__require('50'),
        invoke = $__require('54'),
        html = $__require('55'),
        cel = $__require('57'),
        global = $__require('56'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('4e')(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('5a'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5b", ["56", "59", "4e", "5a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var global = $__require('56'),
        macrotask = $__require('59').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        Promise = global.Promise,
        isNode = $__require('4e')(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain,
          fn;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        fn = head.fn;
        if (domain)
          domain.enter();
        fn();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else if (Promise && Promise.resolve) {
      notify = function() {
        Promise.resolve().then(flush);
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })($__require('5a'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("41", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("43", ["40", "41", "5c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('40'),
      createDesc = $__require('41');
  module.exports = $__require('5c') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("46", ["43"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('43');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5d", ["46"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var redefine = $__require('46');
  module.exports = function(target, src) {
    for (var key in src)
      redefine(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("47", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("42", ["40", "47", "2a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var def = $__require('40').setDesc,
      has = $__require('47'),
      TAG = $__require('2a')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5c", ["5e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !$__require('5e')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5f", ["23", "40", "5c", "2a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = $__require('23'),
      $ = $__require('40'),
      DESCRIPTORS = $__require('5c'),
      SPECIES = $__require('2a')('species');
  module.exports = function(KEY) {
    var C = core[KEY];
    if (DESCRIPTORS && C && !C[SPECIES])
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("60", ["56"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('56'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("61", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2a", ["60", "61", "56"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = $__require('60')('wks'),
      uid = $__require('61'),
      Symbol = $__require('56').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("62", ["2a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ITERATOR = $__require('2a')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("63", ["40", "44", "56", "50", "29", "45", "58", "21", "53", "4a", "4f", "64", "51", "2a", "52", "5b", "5c", "5d", "42", "5f", "23", "62", "5a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = $__require('40'),
        LIBRARY = $__require('44'),
        global = $__require('56'),
        ctx = $__require('50'),
        classof = $__require('29'),
        $export = $__require('45'),
        isObject = $__require('58'),
        anObject = $__require('21'),
        aFunction = $__require('53'),
        strictNew = $__require('4a'),
        forOf = $__require('4f'),
        setProto = $__require('64').set,
        same = $__require('51'),
        SPECIES = $__require('2a')('species'),
        speciesConstructor = $__require('52'),
        asap = $__require('5b'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var USE_NATIVE = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && $__require('5c')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var PromiseCapability = function(C) {
      var resolve,
          reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined)
          throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve), this.reject = aFunction(reject);
    };
    var perform = function(exec) {
      try {
        exec();
      } catch (e) {
        return {error: e};
      }
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(reaction) {
          var handler = ok ? reaction.ok : reaction.fail,
              resolve = reaction.resolve,
              reject = reaction.reject,
              result,
              then;
          try {
            if (handler) {
              if (!ok)
                record.h = true;
              result = handler === true ? value : handler(value);
              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else
                resolve(result);
            } else
              reject(value);
          } catch (e) {
            reject(e);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            var promise = record.p,
                handler,
                console;
            if (isUnhandled(promise)) {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise._d,
          chain = record.a || record.c,
          i = 0,
          reaction;
      if (record.h)
        return false;
      while (chain.length > i) {
        reaction = chain[i++];
        if (reaction.fail || !isUnhandled(reaction.promise))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (record.p === value)
          throw TypeError("Promise can't be resolved itself");
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!USE_NATIVE) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = this._d = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      $__require('5d')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var reaction = new PromiseCapability(speciesConstructor(this, P)),
              promise = reaction.promise,
              record = this._d;
          reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
          reaction.fail = typeof onRejected == 'function' && onRejected;
          record.c.push(reaction);
          if (record.a)
            record.a.push(reaction);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
    $__require('42')(P, PROMISE);
    $__require('5f')(PROMISE);
    Wrapper = $__require('23')[PROMISE];
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, {reject: function reject(r) {
        var capability = new PromiseCapability(this),
            $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
      }});
    $export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        if (x instanceof P && sameConstructor(x.constructor, this))
          return x;
        var capability = new PromiseCapability(this),
            $$resolve = capability.resolve;
        $$resolve(x);
        return capability.promise;
      }});
    $export($export.S + $export.F * !(USE_NATIVE && $__require('62')(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            resolve = capability.resolve,
            reject = capability.reject,
            values = [];
        var abrupt = perform(function() {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              var alreadyCalled = false;
              C.resolve(promise).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                results[index] = value;
                --remaining || resolve(results);
              }, reject);
            });
          else
            resolve(results);
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            reject = capability.reject;
        var abrupt = perform(function() {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      }
    });
  })($__require('5a'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("65", ["38", "26", "25", "63", "23"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('38');
  $__require('26');
  $__require('25');
  $__require('63');
  module.exports = $__require('23').Promise;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("32", ["65"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('65'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.register("1a", ["9"], function (_export) {
  var _classCallCheck, MapGeometry;

  return {
    setters: [function (_) {
      _classCallCheck = _["default"];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      "use strict";

      MapGeometry = function MapGeometry(_ref) {
        var allSystems = _ref.allSystems;
        var renderer = _ref.renderer;
        var initialScale = _ref.initialScale;

        _classCallCheck(this, MapGeometry);

        this.allSystems = allSystems;
        this.renderer = renderer;
        this.initialScale = initialScale;
      };

      _export("default", MapGeometry);
    }
  };
});
$__System.register('66', ['3', '7', '8', '9', '32', '1b', '1c', '1a', 'b'], function (_export) {
  var THREE, settings, _createClass, _classCallCheck, _Promise, _get, _inherits, MapGeometry, config, GLOW_SCALE, BLACK, UNSET, GLOW_MATERIAL_PROMISE, SystemGlow;

  return {
    setters: [function (_5) {
      THREE = _5['default'];
    }, function (_4) {
      settings = _4['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_3) {
      _Promise = _3['default'];
    }, function (_b) {
      _get = _b['default'];
    }, function (_c) {
      _inherits = _c['default'];
    }, function (_a) {
      MapGeometry = _a['default'];
    }, function (_b2) {
      config = _b2['default'];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      'use strict';

      GLOW_SCALE = 3.75;
      BLACK = new THREE.Color('black');
      UNSET = new THREE.Color(0x80A0CC);
      GLOW_MATERIAL_PROMISE = new _Promise(function (resolve, reject) {
        var loader = new THREE.TextureLoader();
        loader.load(config.glowImage, function (texture) {
          resolve(new THREE.SpriteMaterial({
            map: texture,
            blending: THREE.AdditiveBlending,
            opacity: 0.65
          }));
        }, function () /* progress */{}, function (failure) {
          reject(new Error('Could not load texture ' + config.glowImage + ': ' + failure));
        });
      });

      SystemGlow = (function (_MapGeometry) {
        _inherits(SystemGlow, _MapGeometry);

        function SystemGlow(_ref) {
          var material = _ref.material;

          _classCallCheck(this, SystemGlow);

          _get(Object.getPrototypeOf(SystemGlow.prototype), 'constructor', this).apply(this, arguments);
          this.material = material;
        }

        _createClass(SystemGlow, [{
          key: 'refreshVisibility',
          value: function refreshVisibility() {
            this._mesh.traverse(function (obj) {
              if (obj.userData.isGlow && obj.userData.system) {
                obj.visible = settings.glow;
              }
            });
          }
        }, {
          key: 'refreshScale',
          value: function refreshScale() {
            this._mesh.traverse(function (obj) {
              if (obj.userData.isGlow && obj.userData.system) {
                var scale = obj.userData.system.scale * settings.systemScale * GLOW_SCALE;
                obj.scale.set(scale, scale, 1.0);
              }
            });
          }
        }, {
          key: 'mesh',
          get: function get() {
            var _this = this;

            if (this._mesh) {
              return this._mesh;
            }

            var group = new THREE.Group();
            this._mesh = group;

            try {
              this.allSystems.forEach(function (system) {
                var color = system.color;
                if (color.equals(BLACK)) {
                  color.copy(UNSET);
                }

                var material = _this.material.clone();
                material.color = color;

                var glow = new THREE.Sprite(material);
                glow.position.set(system.position.x, system.position.y, system.position.z);
                glow.userData.isGlow = true;
                glow.userData.system = system;
                glow.userData.y = system.position.y;
                glow.sortParticles = true;

                group.add(glow);
              });
            } catch (e) {
              console.error('Problem creating glow sprites:', e);
              throw e;
            }

            group.userData.y = 0;
            group.dynamic = false;
            group.userData.scaleY = SystemGlow.scaleY;
            group.updateMatrix();
            group.name = 'Star System Glow';

            this.refreshVisibility();
            this.refreshScale();

            SystemGlow.scaleY(group, this.initialScale);

            return group;
          }
        }], [{
          key: 'scaleY',
          value: function scaleY(mesh, _scaleY) {
            mesh.traverse(function (obj) {
              if (obj.userData.isGlow && obj.userData.system) {
                obj.position.setY(obj.userData.y * _scaleY);
              }
            });
          }
        }]);

        return SystemGlow;
      })(MapGeometry);

      _export('default', SystemGlow);

      _export('GLOW_MATERIAL_PROMISE', GLOW_MATERIAL_PROMISE);
    }
  };
});
$__System.registerDynamic("67", ["5a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    (function() {
      "use strict";
      function lib$rsvp$utils$$objectOrFunction(x) {
        return typeof x === 'function' || (typeof x === 'object' && x !== null);
      }
      function lib$rsvp$utils$$isFunction(x) {
        return typeof x === 'function';
      }
      function lib$rsvp$utils$$isMaybeThenable(x) {
        return typeof x === 'object' && x !== null;
      }
      var lib$rsvp$utils$$_isArray;
      if (!Array.isArray) {
        lib$rsvp$utils$$_isArray = function(x) {
          return Object.prototype.toString.call(x) === '[object Array]';
        };
      } else {
        lib$rsvp$utils$$_isArray = Array.isArray;
      }
      var lib$rsvp$utils$$isArray = lib$rsvp$utils$$_isArray;
      var lib$rsvp$utils$$now = Date.now || function() {
        return new Date().getTime();
      };
      function lib$rsvp$utils$$F() {}
      var lib$rsvp$utils$$o_create = (Object.create || function(o) {
        if (arguments.length > 1) {
          throw new Error('Second argument not supported');
        }
        if (typeof o !== 'object') {
          throw new TypeError('Argument must be an object');
        }
        lib$rsvp$utils$$F.prototype = o;
        return new lib$rsvp$utils$$F();
      });
      function lib$rsvp$events$$indexOf(callbacks, callback) {
        for (var i = 0,
            l = callbacks.length; i < l; i++) {
          if (callbacks[i] === callback) {
            return i;
          }
        }
        return -1;
      }
      function lib$rsvp$events$$callbacksFor(object) {
        var callbacks = object._promiseCallbacks;
        if (!callbacks) {
          callbacks = object._promiseCallbacks = {};
        }
        return callbacks;
      }
      var lib$rsvp$events$$default = {
        'mixin': function(object) {
          object['on'] = this['on'];
          object['off'] = this['off'];
          object['trigger'] = this['trigger'];
          object._promiseCallbacks = undefined;
          return object;
        },
        'on': function(eventName, callback) {
          if (typeof callback !== 'function') {
            throw new TypeError('Callback must be a function');
          }
          var allCallbacks = lib$rsvp$events$$callbacksFor(this),
              callbacks;
          callbacks = allCallbacks[eventName];
          if (!callbacks) {
            callbacks = allCallbacks[eventName] = [];
          }
          if (lib$rsvp$events$$indexOf(callbacks, callback) === -1) {
            callbacks.push(callback);
          }
        },
        'off': function(eventName, callback) {
          var allCallbacks = lib$rsvp$events$$callbacksFor(this),
              callbacks,
              index;
          if (!callback) {
            allCallbacks[eventName] = [];
            return;
          }
          callbacks = allCallbacks[eventName];
          index = lib$rsvp$events$$indexOf(callbacks, callback);
          if (index !== -1) {
            callbacks.splice(index, 1);
          }
        },
        'trigger': function(eventName, options, label) {
          var allCallbacks = lib$rsvp$events$$callbacksFor(this),
              callbacks,
              callback;
          if (callbacks = allCallbacks[eventName]) {
            for (var i = 0; i < callbacks.length; i++) {
              callback = callbacks[i];
              callback(options, label);
            }
          }
        }
      };
      var lib$rsvp$config$$config = {instrument: false};
      lib$rsvp$events$$default['mixin'](lib$rsvp$config$$config);
      function lib$rsvp$config$$configure(name, value) {
        if (name === 'onerror') {
          lib$rsvp$config$$config['on']('error', value);
          return;
        }
        if (arguments.length === 2) {
          lib$rsvp$config$$config[name] = value;
        } else {
          return lib$rsvp$config$$config[name];
        }
      }
      var lib$rsvp$instrument$$queue = [];
      function lib$rsvp$instrument$$scheduleFlush() {
        setTimeout(function() {
          var entry;
          for (var i = 0; i < lib$rsvp$instrument$$queue.length; i++) {
            entry = lib$rsvp$instrument$$queue[i];
            var payload = entry.payload;
            payload.guid = payload.key + payload.id;
            payload.childGuid = payload.key + payload.childId;
            if (payload.error) {
              payload.stack = payload.error.stack;
            }
            lib$rsvp$config$$config['trigger'](entry.name, entry.payload);
          }
          lib$rsvp$instrument$$queue.length = 0;
        }, 50);
      }
      function lib$rsvp$instrument$$instrument(eventName, promise, child) {
        if (1 === lib$rsvp$instrument$$queue.push({
          name: eventName,
          payload: {
            key: promise._guidKey,
            id: promise._id,
            eventName: eventName,
            detail: promise._result,
            childId: child && child._id,
            label: promise._label,
            timeStamp: lib$rsvp$utils$$now(),
            error: lib$rsvp$config$$config["instrument-with-stack"] ? new Error(promise._label) : null
          }
        })) {
          lib$rsvp$instrument$$scheduleFlush();
        }
      }
      var lib$rsvp$instrument$$default = lib$rsvp$instrument$$instrument;
      function lib$rsvp$$internal$$withOwnPromise() {
        return new TypeError('A promises callback cannot return that same promise.');
      }
      function lib$rsvp$$internal$$noop() {}
      var lib$rsvp$$internal$$PENDING = void 0;
      var lib$rsvp$$internal$$FULFILLED = 1;
      var lib$rsvp$$internal$$REJECTED = 2;
      var lib$rsvp$$internal$$GET_THEN_ERROR = new lib$rsvp$$internal$$ErrorObject();
      function lib$rsvp$$internal$$getThen(promise) {
        try {
          return promise.then;
        } catch (error) {
          lib$rsvp$$internal$$GET_THEN_ERROR.error = error;
          return lib$rsvp$$internal$$GET_THEN_ERROR;
        }
      }
      function lib$rsvp$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
        try {
          then.call(value, fulfillmentHandler, rejectionHandler);
        } catch (e) {
          return e;
        }
      }
      function lib$rsvp$$internal$$handleForeignThenable(promise, thenable, then) {
        lib$rsvp$config$$config.async(function(promise) {
          var sealed = false;
          var error = lib$rsvp$$internal$$tryThen(then, thenable, function(value) {
            if (sealed) {
              return;
            }
            sealed = true;
            if (thenable !== value) {
              lib$rsvp$$internal$$resolve(promise, value);
            } else {
              lib$rsvp$$internal$$fulfill(promise, value);
            }
          }, function(reason) {
            if (sealed) {
              return;
            }
            sealed = true;
            lib$rsvp$$internal$$reject(promise, reason);
          }, 'Settle: ' + (promise._label || ' unknown promise'));
          if (!sealed && error) {
            sealed = true;
            lib$rsvp$$internal$$reject(promise, error);
          }
        }, promise);
      }
      function lib$rsvp$$internal$$handleOwnThenable(promise, thenable) {
        if (thenable._state === lib$rsvp$$internal$$FULFILLED) {
          lib$rsvp$$internal$$fulfill(promise, thenable._result);
        } else if (thenable._state === lib$rsvp$$internal$$REJECTED) {
          thenable._onError = null;
          lib$rsvp$$internal$$reject(promise, thenable._result);
        } else {
          lib$rsvp$$internal$$subscribe(thenable, undefined, function(value) {
            if (thenable !== value) {
              lib$rsvp$$internal$$resolve(promise, value);
            } else {
              lib$rsvp$$internal$$fulfill(promise, value);
            }
          }, function(reason) {
            lib$rsvp$$internal$$reject(promise, reason);
          });
        }
      }
      function lib$rsvp$$internal$$handleMaybeThenable(promise, maybeThenable) {
        if (maybeThenable.constructor === promise.constructor) {
          lib$rsvp$$internal$$handleOwnThenable(promise, maybeThenable);
        } else {
          var then = lib$rsvp$$internal$$getThen(maybeThenable);
          if (then === lib$rsvp$$internal$$GET_THEN_ERROR) {
            lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$GET_THEN_ERROR.error);
          } else if (then === undefined) {
            lib$rsvp$$internal$$fulfill(promise, maybeThenable);
          } else if (lib$rsvp$utils$$isFunction(then)) {
            lib$rsvp$$internal$$handleForeignThenable(promise, maybeThenable, then);
          } else {
            lib$rsvp$$internal$$fulfill(promise, maybeThenable);
          }
        }
      }
      function lib$rsvp$$internal$$resolve(promise, value) {
        if (promise === value) {
          lib$rsvp$$internal$$fulfill(promise, value);
        } else if (lib$rsvp$utils$$objectOrFunction(value)) {
          lib$rsvp$$internal$$handleMaybeThenable(promise, value);
        } else {
          lib$rsvp$$internal$$fulfill(promise, value);
        }
      }
      function lib$rsvp$$internal$$publishRejection(promise) {
        if (promise._onError) {
          promise._onError(promise._result);
        }
        lib$rsvp$$internal$$publish(promise);
      }
      function lib$rsvp$$internal$$fulfill(promise, value) {
        if (promise._state !== lib$rsvp$$internal$$PENDING) {
          return;
        }
        promise._result = value;
        promise._state = lib$rsvp$$internal$$FULFILLED;
        if (promise._subscribers.length === 0) {
          if (lib$rsvp$config$$config.instrument) {
            lib$rsvp$instrument$$default('fulfilled', promise);
          }
        } else {
          lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, promise);
        }
      }
      function lib$rsvp$$internal$$reject(promise, reason) {
        if (promise._state !== lib$rsvp$$internal$$PENDING) {
          return;
        }
        promise._state = lib$rsvp$$internal$$REJECTED;
        promise._result = reason;
        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publishRejection, promise);
      }
      function lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
        var subscribers = parent._subscribers;
        var length = subscribers.length;
        parent._onError = null;
        subscribers[length] = child;
        subscribers[length + lib$rsvp$$internal$$FULFILLED] = onFulfillment;
        subscribers[length + lib$rsvp$$internal$$REJECTED] = onRejection;
        if (length === 0 && parent._state) {
          lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, parent);
        }
      }
      function lib$rsvp$$internal$$publish(promise) {
        var subscribers = promise._subscribers;
        var settled = promise._state;
        if (lib$rsvp$config$$config.instrument) {
          lib$rsvp$instrument$$default(settled === lib$rsvp$$internal$$FULFILLED ? 'fulfilled' : 'rejected', promise);
        }
        if (subscribers.length === 0) {
          return;
        }
        var child,
            callback,
            detail = promise._result;
        for (var i = 0; i < subscribers.length; i += 3) {
          child = subscribers[i];
          callback = subscribers[i + settled];
          if (child) {
            lib$rsvp$$internal$$invokeCallback(settled, child, callback, detail);
          } else {
            callback(detail);
          }
        }
        promise._subscribers.length = 0;
      }
      function lib$rsvp$$internal$$ErrorObject() {
        this.error = null;
      }
      var lib$rsvp$$internal$$TRY_CATCH_ERROR = new lib$rsvp$$internal$$ErrorObject();
      function lib$rsvp$$internal$$tryCatch(callback, detail) {
        try {
          return callback(detail);
        } catch (e) {
          lib$rsvp$$internal$$TRY_CATCH_ERROR.error = e;
          return lib$rsvp$$internal$$TRY_CATCH_ERROR;
        }
      }
      function lib$rsvp$$internal$$invokeCallback(settled, promise, callback, detail) {
        var hasCallback = lib$rsvp$utils$$isFunction(callback),
            value,
            error,
            succeeded,
            failed;
        if (hasCallback) {
          value = lib$rsvp$$internal$$tryCatch(callback, detail);
          if (value === lib$rsvp$$internal$$TRY_CATCH_ERROR) {
            failed = true;
            error = value.error;
            value = null;
          } else {
            succeeded = true;
          }
          if (promise === value) {
            lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$withOwnPromise());
            return;
          }
        } else {
          value = detail;
          succeeded = true;
        }
        if (promise._state !== lib$rsvp$$internal$$PENDING) {} else if (hasCallback && succeeded) {
          lib$rsvp$$internal$$resolve(promise, value);
        } else if (failed) {
          lib$rsvp$$internal$$reject(promise, error);
        } else if (settled === lib$rsvp$$internal$$FULFILLED) {
          lib$rsvp$$internal$$fulfill(promise, value);
        } else if (settled === lib$rsvp$$internal$$REJECTED) {
          lib$rsvp$$internal$$reject(promise, value);
        }
      }
      function lib$rsvp$$internal$$initializePromise(promise, resolver) {
        var resolved = false;
        try {
          resolver(function resolvePromise(value) {
            if (resolved) {
              return;
            }
            resolved = true;
            lib$rsvp$$internal$$resolve(promise, value);
          }, function rejectPromise(reason) {
            if (resolved) {
              return;
            }
            resolved = true;
            lib$rsvp$$internal$$reject(promise, reason);
          });
        } catch (e) {
          lib$rsvp$$internal$$reject(promise, e);
        }
      }
      function lib$rsvp$enumerator$$makeSettledResult(state, position, value) {
        if (state === lib$rsvp$$internal$$FULFILLED) {
          return {
            state: 'fulfilled',
            value: value
          };
        } else {
          return {
            state: 'rejected',
            reason: value
          };
        }
      }
      function lib$rsvp$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {
        var enumerator = this;
        enumerator._instanceConstructor = Constructor;
        enumerator.promise = new Constructor(lib$rsvp$$internal$$noop, label);
        enumerator._abortOnReject = abortOnReject;
        if (enumerator._validateInput(input)) {
          enumerator._input = input;
          enumerator.length = input.length;
          enumerator._remaining = input.length;
          enumerator._init();
          if (enumerator.length === 0) {
            lib$rsvp$$internal$$fulfill(enumerator.promise, enumerator._result);
          } else {
            enumerator.length = enumerator.length || 0;
            enumerator._enumerate();
            if (enumerator._remaining === 0) {
              lib$rsvp$$internal$$fulfill(enumerator.promise, enumerator._result);
            }
          }
        } else {
          lib$rsvp$$internal$$reject(enumerator.promise, enumerator._validationError());
        }
      }
      var lib$rsvp$enumerator$$default = lib$rsvp$enumerator$$Enumerator;
      lib$rsvp$enumerator$$Enumerator.prototype._validateInput = function(input) {
        return lib$rsvp$utils$$isArray(input);
      };
      lib$rsvp$enumerator$$Enumerator.prototype._validationError = function() {
        return new Error('Array Methods must be provided an Array');
      };
      lib$rsvp$enumerator$$Enumerator.prototype._init = function() {
        this._result = new Array(this.length);
      };
      lib$rsvp$enumerator$$Enumerator.prototype._enumerate = function() {
        var enumerator = this;
        var length = enumerator.length;
        var promise = enumerator.promise;
        var input = enumerator._input;
        for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
          enumerator._eachEntry(input[i], i);
        }
      };
      lib$rsvp$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
        var enumerator = this;
        var c = enumerator._instanceConstructor;
        if (lib$rsvp$utils$$isMaybeThenable(entry)) {
          if (entry.constructor === c && entry._state !== lib$rsvp$$internal$$PENDING) {
            entry._onError = null;
            enumerator._settledAt(entry._state, i, entry._result);
          } else {
            enumerator._willSettleAt(c.resolve(entry), i);
          }
        } else {
          enumerator._remaining--;
          enumerator._result[i] = enumerator._makeResult(lib$rsvp$$internal$$FULFILLED, i, entry);
        }
      };
      lib$rsvp$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
        var enumerator = this;
        var promise = enumerator.promise;
        if (promise._state === lib$rsvp$$internal$$PENDING) {
          enumerator._remaining--;
          if (enumerator._abortOnReject && state === lib$rsvp$$internal$$REJECTED) {
            lib$rsvp$$internal$$reject(promise, value);
          } else {
            enumerator._result[i] = enumerator._makeResult(state, i, value);
          }
        }
        if (enumerator._remaining === 0) {
          lib$rsvp$$internal$$fulfill(promise, enumerator._result);
        }
      };
      lib$rsvp$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
        return value;
      };
      lib$rsvp$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
        var enumerator = this;
        lib$rsvp$$internal$$subscribe(promise, undefined, function(value) {
          enumerator._settledAt(lib$rsvp$$internal$$FULFILLED, i, value);
        }, function(reason) {
          enumerator._settledAt(lib$rsvp$$internal$$REJECTED, i, reason);
        });
      };
      function lib$rsvp$promise$all$$all(entries, label) {
        return new lib$rsvp$enumerator$$default(this, entries, true, label).promise;
      }
      var lib$rsvp$promise$all$$default = lib$rsvp$promise$all$$all;
      function lib$rsvp$promise$race$$race(entries, label) {
        var Constructor = this;
        var promise = new Constructor(lib$rsvp$$internal$$noop, label);
        if (!lib$rsvp$utils$$isArray(entries)) {
          lib$rsvp$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
          return promise;
        }
        var length = entries.length;
        function onFulfillment(value) {
          lib$rsvp$$internal$$resolve(promise, value);
        }
        function onRejection(reason) {
          lib$rsvp$$internal$$reject(promise, reason);
        }
        for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
          lib$rsvp$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
        }
        return promise;
      }
      var lib$rsvp$promise$race$$default = lib$rsvp$promise$race$$race;
      function lib$rsvp$promise$resolve$$resolve(object, label) {
        var Constructor = this;
        if (object && typeof object === 'object' && object.constructor === Constructor) {
          return object;
        }
        var promise = new Constructor(lib$rsvp$$internal$$noop, label);
        lib$rsvp$$internal$$resolve(promise, object);
        return promise;
      }
      var lib$rsvp$promise$resolve$$default = lib$rsvp$promise$resolve$$resolve;
      function lib$rsvp$promise$reject$$reject(reason, label) {
        var Constructor = this;
        var promise = new Constructor(lib$rsvp$$internal$$noop, label);
        lib$rsvp$$internal$$reject(promise, reason);
        return promise;
      }
      var lib$rsvp$promise$reject$$default = lib$rsvp$promise$reject$$reject;
      var lib$rsvp$promise$$guidKey = 'rsvp_' + lib$rsvp$utils$$now() + '-';
      var lib$rsvp$promise$$counter = 0;
      function lib$rsvp$promise$$needsResolver() {
        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
      }
      function lib$rsvp$promise$$needsNew() {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }
      function lib$rsvp$promise$$Promise(resolver, label) {
        var promise = this;
        promise._id = lib$rsvp$promise$$counter++;
        promise._label = label;
        promise._state = undefined;
        promise._result = undefined;
        promise._subscribers = [];
        if (lib$rsvp$config$$config.instrument) {
          lib$rsvp$instrument$$default('created', promise);
        }
        if (lib$rsvp$$internal$$noop !== resolver) {
          if (!lib$rsvp$utils$$isFunction(resolver)) {
            lib$rsvp$promise$$needsResolver();
          }
          if (!(promise instanceof lib$rsvp$promise$$Promise)) {
            lib$rsvp$promise$$needsNew();
          }
          lib$rsvp$$internal$$initializePromise(promise, resolver);
        }
      }
      var lib$rsvp$promise$$default = lib$rsvp$promise$$Promise;
      lib$rsvp$promise$$Promise.cast = lib$rsvp$promise$resolve$$default;
      lib$rsvp$promise$$Promise.all = lib$rsvp$promise$all$$default;
      lib$rsvp$promise$$Promise.race = lib$rsvp$promise$race$$default;
      lib$rsvp$promise$$Promise.resolve = lib$rsvp$promise$resolve$$default;
      lib$rsvp$promise$$Promise.reject = lib$rsvp$promise$reject$$default;
      lib$rsvp$promise$$Promise.prototype = {
        constructor: lib$rsvp$promise$$Promise,
        _guidKey: lib$rsvp$promise$$guidKey,
        _onError: function(reason) {
          var promise = this;
          lib$rsvp$config$$config.after(function() {
            if (promise._onError) {
              lib$rsvp$config$$config['trigger']('error', reason, promise._label);
            }
          });
        },
        then: function(onFulfillment, onRejection, label) {
          var parent = this;
          var state = parent._state;
          if (state === lib$rsvp$$internal$$FULFILLED && !onFulfillment || state === lib$rsvp$$internal$$REJECTED && !onRejection) {
            if (lib$rsvp$config$$config.instrument) {
              lib$rsvp$instrument$$default('chained', parent, parent);
            }
            return parent;
          }
          parent._onError = null;
          var child = new parent.constructor(lib$rsvp$$internal$$noop, label);
          var result = parent._result;
          if (lib$rsvp$config$$config.instrument) {
            lib$rsvp$instrument$$default('chained', parent, child);
          }
          if (state) {
            var callback = arguments[state - 1];
            lib$rsvp$config$$config.async(function() {
              lib$rsvp$$internal$$invokeCallback(state, child, callback, result);
            });
          } else {
            lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection);
          }
          return child;
        },
        'catch': function(onRejection, label) {
          return this.then(undefined, onRejection, label);
        },
        'finally': function(callback, label) {
          var promise = this;
          var constructor = promise.constructor;
          return promise.then(function(value) {
            return constructor.resolve(callback()).then(function() {
              return value;
            });
          }, function(reason) {
            return constructor.resolve(callback()).then(function() {
              throw reason;
            });
          }, label);
        }
      };
      function lib$rsvp$all$settled$$AllSettled(Constructor, entries, label) {
        this._superConstructor(Constructor, entries, false, label);
      }
      lib$rsvp$all$settled$$AllSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
      lib$rsvp$all$settled$$AllSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
      lib$rsvp$all$settled$$AllSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;
      lib$rsvp$all$settled$$AllSettled.prototype._validationError = function() {
        return new Error('allSettled must be called with an array');
      };
      function lib$rsvp$all$settled$$allSettled(entries, label) {
        return new lib$rsvp$all$settled$$AllSettled(lib$rsvp$promise$$default, entries, label).promise;
      }
      var lib$rsvp$all$settled$$default = lib$rsvp$all$settled$$allSettled;
      function lib$rsvp$all$$all(array, label) {
        return lib$rsvp$promise$$default.all(array, label);
      }
      var lib$rsvp$all$$default = lib$rsvp$all$$all;
      var lib$rsvp$asap$$len = 0;
      var lib$rsvp$asap$$toString = {}.toString;
      var lib$rsvp$asap$$vertxNext;
      function lib$rsvp$asap$$asap(callback, arg) {
        lib$rsvp$asap$$queue[lib$rsvp$asap$$len] = callback;
        lib$rsvp$asap$$queue[lib$rsvp$asap$$len + 1] = arg;
        lib$rsvp$asap$$len += 2;
        if (lib$rsvp$asap$$len === 2) {
          lib$rsvp$asap$$scheduleFlush();
        }
      }
      var lib$rsvp$asap$$default = lib$rsvp$asap$$asap;
      var lib$rsvp$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
      var lib$rsvp$asap$$browserGlobal = lib$rsvp$asap$$browserWindow || {};
      var lib$rsvp$asap$$BrowserMutationObserver = lib$rsvp$asap$$browserGlobal.MutationObserver || lib$rsvp$asap$$browserGlobal.WebKitMutationObserver;
      var lib$rsvp$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
      var lib$rsvp$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
      function lib$rsvp$asap$$useNextTick() {
        var nextTick = process.nextTick;
        var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
        if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
          nextTick = setImmediate;
        }
        return function() {
          nextTick(lib$rsvp$asap$$flush);
        };
      }
      function lib$rsvp$asap$$useVertxTimer() {
        return function() {
          lib$rsvp$asap$$vertxNext(lib$rsvp$asap$$flush);
        };
      }
      function lib$rsvp$asap$$useMutationObserver() {
        var iterations = 0;
        var observer = new lib$rsvp$asap$$BrowserMutationObserver(lib$rsvp$asap$$flush);
        var node = document.createTextNode('');
        observer.observe(node, {characterData: true});
        return function() {
          node.data = (iterations = ++iterations % 2);
        };
      }
      function lib$rsvp$asap$$useMessageChannel() {
        var channel = new MessageChannel();
        channel.port1.onmessage = lib$rsvp$asap$$flush;
        return function() {
          channel.port2.postMessage(0);
        };
      }
      function lib$rsvp$asap$$useSetTimeout() {
        return function() {
          setTimeout(lib$rsvp$asap$$flush, 1);
        };
      }
      var lib$rsvp$asap$$queue = new Array(1000);
      function lib$rsvp$asap$$flush() {
        for (var i = 0; i < lib$rsvp$asap$$len; i += 2) {
          var callback = lib$rsvp$asap$$queue[i];
          var arg = lib$rsvp$asap$$queue[i + 1];
          callback(arg);
          lib$rsvp$asap$$queue[i] = undefined;
          lib$rsvp$asap$$queue[i + 1] = undefined;
        }
        lib$rsvp$asap$$len = 0;
      }
      function lib$rsvp$asap$$attemptVertex() {
        try {
          var r = $__require;
          var vertx = r('vertx');
          lib$rsvp$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
          return lib$rsvp$asap$$useVertxTimer();
        } catch (e) {
          return lib$rsvp$asap$$useSetTimeout();
        }
      }
      var lib$rsvp$asap$$scheduleFlush;
      if (lib$rsvp$asap$$isNode) {
        lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useNextTick();
      } else if (lib$rsvp$asap$$BrowserMutationObserver) {
        lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMutationObserver();
      } else if (lib$rsvp$asap$$isWorker) {
        lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMessageChannel();
      } else if (lib$rsvp$asap$$browserWindow === undefined && typeof $__require === 'function') {
        lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$attemptVertex();
      } else {
        lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useSetTimeout();
      }
      function lib$rsvp$defer$$defer(label) {
        var deferred = {};
        deferred['promise'] = new lib$rsvp$promise$$default(function(resolve, reject) {
          deferred['resolve'] = resolve;
          deferred['reject'] = reject;
        }, label);
        return deferred;
      }
      var lib$rsvp$defer$$default = lib$rsvp$defer$$defer;
      function lib$rsvp$filter$$filter(promises, filterFn, label) {
        return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
          if (!lib$rsvp$utils$$isFunction(filterFn)) {
            throw new TypeError("You must pass a function as filter's second argument.");
          }
          var length = values.length;
          var filtered = new Array(length);
          for (var i = 0; i < length; i++) {
            filtered[i] = filterFn(values[i]);
          }
          return lib$rsvp$promise$$default.all(filtered, label).then(function(filtered) {
            var results = new Array(length);
            var newLength = 0;
            for (var i = 0; i < length; i++) {
              if (filtered[i]) {
                results[newLength] = values[i];
                newLength++;
              }
            }
            results.length = newLength;
            return results;
          });
        });
      }
      var lib$rsvp$filter$$default = lib$rsvp$filter$$filter;
      function lib$rsvp$promise$hash$$PromiseHash(Constructor, object, label) {
        this._superConstructor(Constructor, object, true, label);
      }
      var lib$rsvp$promise$hash$$default = lib$rsvp$promise$hash$$PromiseHash;
      lib$rsvp$promise$hash$$PromiseHash.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
      lib$rsvp$promise$hash$$PromiseHash.prototype._superConstructor = lib$rsvp$enumerator$$default;
      lib$rsvp$promise$hash$$PromiseHash.prototype._init = function() {
        this._result = {};
      };
      lib$rsvp$promise$hash$$PromiseHash.prototype._validateInput = function(input) {
        return input && typeof input === 'object';
      };
      lib$rsvp$promise$hash$$PromiseHash.prototype._validationError = function() {
        return new Error('Promise.hash must be called with an object');
      };
      lib$rsvp$promise$hash$$PromiseHash.prototype._enumerate = function() {
        var enumerator = this;
        var promise = enumerator.promise;
        var input = enumerator._input;
        var results = [];
        for (var key in input) {
          if (promise._state === lib$rsvp$$internal$$PENDING && Object.prototype.hasOwnProperty.call(input, key)) {
            results.push({
              position: key,
              entry: input[key]
            });
          }
        }
        var length = results.length;
        enumerator._remaining = length;
        var result;
        for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
          result = results[i];
          enumerator._eachEntry(result.entry, result.position);
        }
      };
      function lib$rsvp$hash$settled$$HashSettled(Constructor, object, label) {
        this._superConstructor(Constructor, object, false, label);
      }
      lib$rsvp$hash$settled$$HashSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$promise$hash$$default.prototype);
      lib$rsvp$hash$settled$$HashSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
      lib$rsvp$hash$settled$$HashSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;
      lib$rsvp$hash$settled$$HashSettled.prototype._validationError = function() {
        return new Error('hashSettled must be called with an object');
      };
      function lib$rsvp$hash$settled$$hashSettled(object, label) {
        return new lib$rsvp$hash$settled$$HashSettled(lib$rsvp$promise$$default, object, label).promise;
      }
      var lib$rsvp$hash$settled$$default = lib$rsvp$hash$settled$$hashSettled;
      function lib$rsvp$hash$$hash(object, label) {
        return new lib$rsvp$promise$hash$$default(lib$rsvp$promise$$default, object, label).promise;
      }
      var lib$rsvp$hash$$default = lib$rsvp$hash$$hash;
      function lib$rsvp$map$$map(promises, mapFn, label) {
        return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
          if (!lib$rsvp$utils$$isFunction(mapFn)) {
            throw new TypeError("You must pass a function as map's second argument.");
          }
          var length = values.length;
          var results = new Array(length);
          for (var i = 0; i < length; i++) {
            results[i] = mapFn(values[i]);
          }
          return lib$rsvp$promise$$default.all(results, label);
        });
      }
      var lib$rsvp$map$$default = lib$rsvp$map$$map;
      function lib$rsvp$node$$Result() {
        this.value = undefined;
      }
      var lib$rsvp$node$$ERROR = new lib$rsvp$node$$Result();
      var lib$rsvp$node$$GET_THEN_ERROR = new lib$rsvp$node$$Result();
      function lib$rsvp$node$$getThen(obj) {
        try {
          return obj.then;
        } catch (error) {
          lib$rsvp$node$$ERROR.value = error;
          return lib$rsvp$node$$ERROR;
        }
      }
      function lib$rsvp$node$$tryApply(f, s, a) {
        try {
          f.apply(s, a);
        } catch (error) {
          lib$rsvp$node$$ERROR.value = error;
          return lib$rsvp$node$$ERROR;
        }
      }
      function lib$rsvp$node$$makeObject(_, argumentNames) {
        var obj = {};
        var name;
        var i;
        var length = _.length;
        var args = new Array(length);
        for (var x = 0; x < length; x++) {
          args[x] = _[x];
        }
        for (i = 0; i < argumentNames.length; i++) {
          name = argumentNames[i];
          obj[name] = args[i + 1];
        }
        return obj;
      }
      function lib$rsvp$node$$arrayResult(_) {
        var length = _.length;
        var args = new Array(length - 1);
        for (var i = 1; i < length; i++) {
          args[i - 1] = _[i];
        }
        return args;
      }
      function lib$rsvp$node$$wrapThenable(then, promise) {
        return {then: function(onFulFillment, onRejection) {
            return then.call(promise, onFulFillment, onRejection);
          }};
      }
      function lib$rsvp$node$$denodeify(nodeFunc, options) {
        var fn = function() {
          var self = this;
          var l = arguments.length;
          var args = new Array(l + 1);
          var arg;
          var promiseInput = false;
          for (var i = 0; i < l; ++i) {
            arg = arguments[i];
            if (!promiseInput) {
              promiseInput = lib$rsvp$node$$needsPromiseInput(arg);
              if (promiseInput === lib$rsvp$node$$GET_THEN_ERROR) {
                var p = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);
                lib$rsvp$$internal$$reject(p, lib$rsvp$node$$GET_THEN_ERROR.value);
                return p;
              } else if (promiseInput && promiseInput !== true) {
                arg = lib$rsvp$node$$wrapThenable(promiseInput, arg);
              }
            }
            args[i] = arg;
          }
          var promise = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);
          args[l] = function(err, val) {
            if (err)
              lib$rsvp$$internal$$reject(promise, err);
            else if (options === undefined)
              lib$rsvp$$internal$$resolve(promise, val);
            else if (options === true)
              lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$arrayResult(arguments));
            else if (lib$rsvp$utils$$isArray(options))
              lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$makeObject(arguments, options));
            else
              lib$rsvp$$internal$$resolve(promise, val);
          };
          if (promiseInput) {
            return lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self);
          } else {
            return lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self);
          }
        };
        fn.__proto__ = nodeFunc;
        return fn;
      }
      var lib$rsvp$node$$default = lib$rsvp$node$$denodeify;
      function lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self) {
        var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
        if (result === lib$rsvp$node$$ERROR) {
          lib$rsvp$$internal$$reject(promise, result.value);
        }
        return promise;
      }
      function lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self) {
        return lib$rsvp$promise$$default.all(args).then(function(args) {
          var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
          if (result === lib$rsvp$node$$ERROR) {
            lib$rsvp$$internal$$reject(promise, result.value);
          }
          return promise;
        });
      }
      function lib$rsvp$node$$needsPromiseInput(arg) {
        if (arg && typeof arg === 'object') {
          if (arg.constructor === lib$rsvp$promise$$default) {
            return true;
          } else {
            return lib$rsvp$node$$getThen(arg);
          }
        } else {
          return false;
        }
      }
      var lib$rsvp$platform$$platform;
      if (typeof self === 'object') {
        lib$rsvp$platform$$platform = self;
      } else if (typeof global === 'object') {
        lib$rsvp$platform$$platform = global;
      } else {
        throw new Error('no global: `self` or `global` found');
      }
      var lib$rsvp$platform$$default = lib$rsvp$platform$$platform;
      function lib$rsvp$race$$race(array, label) {
        return lib$rsvp$promise$$default.race(array, label);
      }
      var lib$rsvp$race$$default = lib$rsvp$race$$race;
      function lib$rsvp$reject$$reject(reason, label) {
        return lib$rsvp$promise$$default.reject(reason, label);
      }
      var lib$rsvp$reject$$default = lib$rsvp$reject$$reject;
      function lib$rsvp$resolve$$resolve(value, label) {
        return lib$rsvp$promise$$default.resolve(value, label);
      }
      var lib$rsvp$resolve$$default = lib$rsvp$resolve$$resolve;
      function lib$rsvp$rethrow$$rethrow(reason) {
        setTimeout(function() {
          throw reason;
        });
        throw reason;
      }
      var lib$rsvp$rethrow$$default = lib$rsvp$rethrow$$rethrow;
      lib$rsvp$config$$config.async = lib$rsvp$asap$$default;
      lib$rsvp$config$$config.after = function(cb) {
        setTimeout(cb, 0);
      };
      var lib$rsvp$$cast = lib$rsvp$resolve$$default;
      function lib$rsvp$$async(callback, arg) {
        lib$rsvp$config$$config.async(callback, arg);
      }
      function lib$rsvp$$on() {
        lib$rsvp$config$$config['on'].apply(lib$rsvp$config$$config, arguments);
      }
      function lib$rsvp$$off() {
        lib$rsvp$config$$config['off'].apply(lib$rsvp$config$$config, arguments);
      }
      if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {
        var lib$rsvp$$callbacks = window['__PROMISE_INSTRUMENTATION__'];
        lib$rsvp$config$$configure('instrument', true);
        for (var lib$rsvp$$eventName in lib$rsvp$$callbacks) {
          if (lib$rsvp$$callbacks.hasOwnProperty(lib$rsvp$$eventName)) {
            lib$rsvp$$on(lib$rsvp$$eventName, lib$rsvp$$callbacks[lib$rsvp$$eventName]);
          }
        }
      }
      var lib$rsvp$umd$$RSVP = {
        'race': lib$rsvp$race$$default,
        'Promise': lib$rsvp$promise$$default,
        'allSettled': lib$rsvp$all$settled$$default,
        'hash': lib$rsvp$hash$$default,
        'hashSettled': lib$rsvp$hash$settled$$default,
        'denodeify': lib$rsvp$node$$default,
        'on': lib$rsvp$$on,
        'off': lib$rsvp$$off,
        'map': lib$rsvp$map$$default,
        'filter': lib$rsvp$filter$$default,
        'resolve': lib$rsvp$resolve$$default,
        'reject': lib$rsvp$reject$$default,
        'all': lib$rsvp$all$$default,
        'rethrow': lib$rsvp$rethrow$$default,
        'defer': lib$rsvp$defer$$default,
        'EventTarget': lib$rsvp$events$$default,
        'configure': lib$rsvp$config$$configure,
        'async': lib$rsvp$$async
      };
      if (typeof define === 'function' && define['amd']) {
        define(function() {
          return lib$rsvp$umd$$RSVP;
        });
      } else if (typeof module !== 'undefined' && module['exports']) {
        module['exports'] = lib$rsvp$umd$$RSVP;
      } else if (typeof lib$rsvp$platform$$default !== 'undefined') {
        lib$rsvp$platform$$default['RSVP'] = lib$rsvp$umd$$RSVP;
      }
    }).call(this);
  })($__require('5a'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11", ["67"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('67');
  global.define = __define;
  return module.exports;
});

$__System.register('68', ['1', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '15', '16', '17', '19', '36', '37', '66', '69', '6a', 'c', '6b', 'b', 'd', '1e', '6c', '1f'], function (_export) {
  var SCMAP, Dijkstra, hasLocalStorage, hasSessionStorage, StarSystem, settings, _createClass, _classCallCheck, xhrPromise, RSVP, DisplayState, TWEEN, waitForFontAwesome, SelectedSystemGeometry, buildReferenceGrid, SystemsGeometry, SystemLabels, Interactables, SystemGlow, GLOW_MATERIAL_PROMISE, Goods, Faction, Route, UI, config, renderer, scene, Scene, Mesh, MeshBasicMaterial, Vector3, degToRad, JumpPoints, Map;

  function scaleSelector(mesh, scaleY) {
    mesh.scale.y = scaleY * 4.0 * config.renderScale;
    mesh.position.setY(scaleY * mesh.userData.position.y);
  }

  return {
    setters: [function (_3) {
      SCMAP = _3['default'];
    }, function (_6) {
      Dijkstra = _6['default'];
    }, function (_9) {
      hasLocalStorage = _9.hasLocalStorage;
      hasSessionStorage = _9.hasSessionStorage;
    }, function (_4) {
      StarSystem = _4['default'];
    }, function (_7) {
      settings = _7['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_8) {
      xhrPromise = _8['default'];
    }, function (_19) {
      RSVP = _19['default'];
    }, function (_10) {
      DisplayState = _10['default'];
    }, function (_18) {
      TWEEN = _18['default'];
    }, function (_11) {
      waitForFontAwesome = _11['default'];
    }, function (_12) {
      SelectedSystemGeometry = _12['default'];
    }, function (_13) {
      buildReferenceGrid = _13.buildReferenceGrid;
    }, function (_14) {
      SystemsGeometry = _14['default'];
    }, function (_15) {
      SystemLabels = _15['default'];
    }, function (_16) {
      Interactables = _16['default'];
    }, function (_17) {
      SystemGlow = _17['default'];
      GLOW_MATERIAL_PROMISE = _17.GLOW_MATERIAL_PROMISE;
    }, function (_5) {
      Goods = _5['default'];
    }, function (_a) {
      Faction = _a['default'];
    }, function (_c) {
      Route = _c['default'];
    }, function (_b) {
      UI = _b['default'];
    }, function (_b2) {
      config = _b2['default'];
    }, function (_d) {
      renderer = _d.renderer;
      scene = _d.scene;
    }, function (_e) {
      Scene = _e.Scene;
      Mesh = _e.Mesh;
      MeshBasicMaterial = _e.MeshBasicMaterial;
      Vector3 = _e.Vector3;
    }, function (_c2) {
      degToRad = _c2.degToRad;
    }, function (_f) {
      JumpPoints = _f['default'];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      'use strict';

      Map = (function () {
        function Map() {
          _classCallCheck(this, Map);

          this.name = 'Star Citizen Persistent Universe';
          this.scene = new Scene();

          this._route = null; // The main route the user can set

          this.geometry = {};
          this.displayState = this.buildDisplayState();

          this.geometry.selectedSystem = this._createSelectorObject(0x99FF99);
          this.geometry.selectedSystem.userData.scaleY = scaleSelector;
          scaleSelector(this.geometry.selectedSystem, this.displayState.currentScale);
          this.scene.add(this.geometry.selectedSystem);

          this.geometry.mouseOverObject = this._createSelectorObject(0x8844FF);
          this.geometry.mouseOverObject.scale.set(4.0 * config.renderScale, 4.0 * config.renderScale, 4.0 * config.renderScale);
          this.geometry.mouseOverObject.userData.scaleY = scaleSelector;
          scaleSelector(this.geometry.mouseOverObject, this.displayState.currentScale);
          this.scene.add(this.geometry.mouseOverObject);

          this.__currentlySelected = null;

          var map = this;

          var getSystems = xhrPromise(config.systemsJson);
          var getStrategicValues = xhrPromise(config.strategicValuesJson);
          var getFactions = xhrPromise(config.factionsJson);
          var getCrimeLevels = xhrPromise(config.crimeLevelsJson);
          var getGoods = xhrPromise(config.goodsJson);

          RSVP.all([getSystems, getStrategicValues, getFactions, getCrimeLevels, getGoods]).then(function (promises) {

            getStrategicValues.then(function (strategic_values) {
              SCMAP.importUEEStrategicValues(JSON.parse(strategic_values));
            });
            getCrimeLevels.then(function (crimeLevels) {
              SCMAP.importCrimeLevels(JSON.parse(crimeLevels));
            });

            getFactions.then(function (factions) {
              SCMAP.importFactions(JSON.parse(factions));
            });
            getGoods.then(function (goods) {
              SCMAP.importCommodities(JSON.parse(goods));
            });

            getSystems.then(function (systems) {
              try {
                systems = JSON.parse(systems);
                map.populate(systems);
              } catch (e) {
                console.error('Could not populate map:', e);
                throw e;
              };

              try {
                var grid = buildReferenceGrid();
                grid.name = 'referenceGrid';
                map.scene.add(grid);
                grid.position.y = -0.05;
                grid.updateMatrix();
              } catch (e) {
                console.error('Failed to create reference grid:', e);
              };

              UI.updateSystemsList();
              renderer.controls.idle();

              map.route().restoreFromSession();
              map.route().update();

              if ('selectedSystem' in settings.storage) {
                var selectedSystem = StarSystem.getById(settings.storage.selectedSystem);
                if (selectedSystem instanceof StarSystem) {
                  map.setSelectionTo(selectedSystem);
                  UI.displayInfoOn(selectedSystem, true);
                }
              }
            }, function (failed) {
              console.error('Failed to process systems', failed);
            });
          }, function (failure) {
            console.error('Failed loading data:', failure);
          });
        }

        _createClass(Map, [{
          key: 'buildDisplayState',
          value: function buildDisplayState() {
            var _this = this;

            var displayState = new DisplayState({
              mode: settings.mode,
              map: this,
              time: config.time
            });

            displayState.onUpdate = function (value) {
              _this.scene.children.forEach(function (mesh) {
                if (typeof mesh.userData.scaleY === 'function') {
                  mesh.userData.scaleY(mesh, value);
                }
              });
            };

            displayState.onEnter2D = function () {
              UI.entered2D();
              settings.mode = '2d';
            };

            displayState.onEnter3D = function () {
              UI.entered3D();
              settings.mode = '3d';
            };

            this.displayState = displayState;

            if (config.debug) {
              console.info('DisplayState is', displayState);
            }

            return displayState;
          }
        }, {
          key: 'getSelected',
          value: function getSelected() {
            return this.__currentlySelected;
          }
        }, {
          key: 'selected',
          value: function selected() {
            return this.getSelected();
          }
        }, {
          key: 'animate',
          value: function animate() {
            var rotationY = degToRad(Date.now() * 0.00025) * 300;
            this.scene.traverse(function (object) {
              if (object.userData.isSelector) {
                object.rotation.y = rotationY;
              }
            });
          }
        }, {
          key: 'setSelected',
          value: function setSelected(system) {
            if (system !== null && !(system instanceof StarSystem)) {
              throw new Error(system, 'is not an instance of StarSystem');
            }
            this.__currentlySelected = system;
            if (system) {
              settings.storage.selectedSystem = system.id;
            } else {
              delete settings.storage.selectedSystem;
            }
            return system;
          }
        }, {
          key: '_createSelectorObject',
          value: function _createSelectorObject(color) {
            var mesh = new Mesh(SelectedSystemGeometry, new MeshBasicMaterial({ color: color }));
            mesh.scale.set(4.2 * config.renderScale, 4.2 * config.renderScale, 4.2 * config.renderScale);
            mesh.visible = false;
            mesh.userData.isSelector = true;
            // 2d/3d tween callback
            mesh.userData.position = new Vector3(0, 0, 0);
            mesh.userData.scaleY = function (object, scalar) {
              object.position.setY(object.userData.position.y * scalar);
            };
            return mesh;
          }
        }, {
          key: '__updateSelectorObject',
          value: function __updateSelectorObject(system) {
            if (system instanceof StarSystem) {
              this.geometry.selectedSystem.visible = true;
              this.geometry.selectedSystem.userData.position.copy(system.position);
              this.moveSelectorTo(system);
              this.setSelected(system);
            } else {
              this.geometry.selectedSystem.visible = false;
              this.setSelected(null);
            }
          }

          // Lazy builds the route
        }, {
          key: 'route',
          value: function route() {
            if (!(this._route instanceof Route)) {
              this._route = new Route();
              if (config.debug) {
                console.log('Created new route', this._route.toString());
              }
            }

            return this._route;
          }
        }, {
          key: 'setSelectionTo',
          value: function setSelectionTo(system) {
            return this.__updateSelectorObject(system);
          }
        }, {
          key: 'deselect',
          value: function deselect() {
            return this.__updateSelectorObject();
          }
        }, {
          key: 'setAllLabelSizes',
          value: function setAllLabelSizes(vector) {
            SCMAP.allSystems.forEach(function (system) {
              system.setLabelScale(vector);
            });
          }
        }, {
          key: 'moveSelectorTo',
          value: function moveSelectorTo(destination) {
            var map = this;
            var tween = undefined,
                newPosition = undefined,
                position = undefined,
                poi = undefined,
                graph = undefined,
                route = undefined;
            var tweens = [];

            if (!this.geometry.selectedSystem.visible || !(this.getSelected() instanceof StarSystem)) {
              this.geometry.selectedSystem.userData.position.copy(destination.position);
              this.geometry.selectedSystem.position.copy(destination.position);
              this.geometry.selectedSystem.position.setY(destination.position.y * this.displayState.currentScale);
              this.geometry.selectedSystem.visible = true;
              this.getSelected(destination);
              return;
            }

            newPosition = destination.position.clone();
            graph = new Dijkstra(SCMAP.allSystems, this.getSelected(), destination);
            graph.buildGraph();

            route = graph.routeArray(destination);
            if (route.length <= 1) {
              this.geometry.selectedSystem.userData.position.copy(destination.position);
              this.geometry.selectedSystem.position.copy(destination.position);
              this.geometry.selectedSystem.position.setY(destination.position.y * this.displayState.currentScale);
              this.geometry.selectedSystem.visible = true;
              this.setSelected(destination);
              return;
            }

            position = {
              x: this.geometry.selectedSystem.position.x,
              y: this.geometry.selectedSystem.position.y * this.displayState.currentScale,
              z: this.geometry.selectedSystem.position.z
            };

            /* jshint ignore:start */
            for (var i = 0; i < route.length - 1; i++) {
              poi = route[i + 1].system;

              tween = new TWEEN.Tween(position).to({
                x: poi.position.x,
                y: poi.position.y * this.displayState.currentScale,
                z: poi.position.z
              }, 800 / (route.length - 1)).easing(TWEEN.Easing.Linear.None).onUpdate(function () {
                map.geometry.selectedSystem.position.set(this.x, this.y, this.z);
              });

              if (i == 0) {
                if (route.length == 2) {
                  tween.easing(TWEEN.Easing.Cubic.InOut);
                } else {
                  tween.easing(TWEEN.Easing.Cubic.In);
                }
              }

              if (i > 0) {
                tweens[i - 1].chain(tween);
              }

              if (i == route.length - 2) {
                tween.easing(TWEEN.Easing.Cubic.Out);
                tween.onComplete(function () {
                  map.geometry.selectedSystem.userData.position.copy(poi.position);
                  map.geometry.selectedSystem.position.copy(poi.position);
                  map.geometry.selectedSystem.position.setY(destination.position.y * map.displayState.currentScale);
                  map.setSelected(destination);
                });
              }

              tweens.push(tween);
            }
            /* jshint ignore:end */

            tweens[0].start();
          }
        }, {
          key: 'getIntersect',
          value: function getIntersect(event) {
            return this.geometry.interactables.getIntersect(event);
          }
        }, {
          key: 'syncCamera',
          value: function syncCamera() {
            renderer.controls.rememberPosition();
            this.geometry.systems.refreshLOD(renderer.camera);
            this.geometry.labels.matchRotation(renderer.cameraRotationMatrix());
          }
        }, {
          key: 'populate',
          value: function populate(data) {
            var _this2 = this;

            var startTime = new Date().getTime();

            SCMAP.importStarSystems(data);

            var standardGeometryParameters = {
              allSystems: SCMAP.allSystems,
              renderer: renderer,
              initialScale: this.displayState.currentScale
            };

            // Generate an object for the star systems
            this.geometry.systems = new SystemsGeometry(standardGeometryParameters);
            this.scene.add(this.geometry.systems.mesh);

            waitForFontAwesome().then(function () {
              // Generate the labels for the star systems
              _this2.geometry.labels = new SystemLabels(standardGeometryParameters);
              _this2.scene.add(_this2.geometry.labels.mesh);
            });

            // Generate the proxy sprites for mouse/touch interaction
            this.geometry.interactables = new Interactables(standardGeometryParameters);
            this.scene.add(this.geometry.interactables.mesh);

            // Generate an object for the jump points
            this.geometry.jumpPoints = new JumpPoints(standardGeometryParameters);
            this.scene.add(this.geometry.jumpPoints.mesh);

            // Glow sprites for the systems
            GLOW_MATERIAL_PROMISE.then(function (material) {
              standardGeometryParameters.material = material;
              _this2.geometry.glow = new SystemGlow(standardGeometryParameters);
              _this2.scene.add(_this2.geometry.glow.mesh);
            });

            console.info('Populating the scene took ' + (new Date().getTime() - startTime) + ' msec');

            UI.loadedSystems(SCMAP.allSystems.length);
          }
        }, {
          key: 'pointAtPlane',
          value: function pointAtPlane(theta, radius, y) {
            return new Vector3(radius * Math.cos(theta), y, -radius * Math.sin(theta));
          }
        }]);

        return Map;
      })();

      _export('default', Map);
    }
  };
});
$__System.registerDynamic("49", ["6d", "3b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = $__require('6d'),
      defined = $__require('3b');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6e", ["45", "23", "5e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('45'),
      core = $__require('23'),
      fails = $__require('5e');
  module.exports = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
      fn(1);
    }), 'Object', exp);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6f", ["49", "6e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('49');
  $__require('6e')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("70", ["40", "6f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('40');
  $__require('6f');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("71", ["70"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('70'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b", ["71"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$getOwnPropertyDescriptor = $__require('71')["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          desc = parent = undefined;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("58", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("21", ["58"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('58');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("64", ["40", "58", "21", "50"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = $__require('40').getDesc,
      isObject = $__require('58'),
      anObject = $__require('21');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = $__require('50')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("72", ["45", "64"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('45');
  $export($export.S, 'Object', {setPrototypeOf: $__require('64').set});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("73", ["72", "23"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('72');
  module.exports = $__require('23').Object.setPrototypeOf;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("74", ["73"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('73'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c", ["75", "74"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$create = $__require('75')["default"];
  var _Object$setPrototypeOf = $__require('74')["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("76", ["45", "56"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('45'),
      _isFinite = $__require('56').isFinite;
  $export($export.S, 'Number', {isFinite: function isFinite(it) {
      return typeof it == 'number' && _isFinite(it);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("77", ["76", "23"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('76');
  module.exports = $__require('23').Number.isFinite;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("78", ["77"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('77'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("79", ["40"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('40');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("75", ["79"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('79'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7a", ["40"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('40');
  module.exports = function defineProperties(T, D) {
    return $.setDescs(T, D);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7b", ["7a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('7a'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7c", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function() {
    var StateMachine = {
      VERSION: "2.3.5",
      Result: {
        SUCCEEDED: 1,
        NOTRANSITION: 2,
        CANCELLED: 3,
        PENDING: 4
      },
      Error: {
        INVALID_TRANSITION: 100,
        PENDING_TRANSITION: 200,
        INVALID_CALLBACK: 300
      },
      WILDCARD: '*',
      ASYNC: 'async',
      create: function(cfg, target) {
        var initial = (typeof cfg.initial == 'string') ? {state: cfg.initial} : cfg.initial;
        var terminal = cfg.terminal || cfg['final'];
        var fsm = target || cfg.target || {};
        var events = cfg.events || [];
        var callbacks = cfg.callbacks || {};
        var map = {};
        var transitions = {};
        var add = function(e) {
          var from = (e.from instanceof Array) ? e.from : (e.from ? [e.from] : [StateMachine.WILDCARD]);
          map[e.name] = map[e.name] || {};
          for (var n = 0; n < from.length; n++) {
            transitions[from[n]] = transitions[from[n]] || [];
            transitions[from[n]].push(e.name);
            map[e.name][from[n]] = e.to || from[n];
          }
        };
        if (initial) {
          initial.event = initial.event || 'startup';
          add({
            name: initial.event,
            from: 'none',
            to: initial.state
          });
        }
        for (var n = 0; n < events.length; n++)
          add(events[n]);
        for (var name in map) {
          if (map.hasOwnProperty(name))
            fsm[name] = StateMachine.buildEvent(name, map[name]);
        }
        for (var name in callbacks) {
          if (callbacks.hasOwnProperty(name))
            fsm[name] = callbacks[name];
        }
        fsm.current = 'none';
        fsm.is = function(state) {
          return (state instanceof Array) ? (state.indexOf(this.current) >= 0) : (this.current === state);
        };
        fsm.can = function(event) {
          return !this.transition && (map[event].hasOwnProperty(this.current) || map[event].hasOwnProperty(StateMachine.WILDCARD));
        };
        fsm.cannot = function(event) {
          return !this.can(event);
        };
        fsm.transitions = function() {
          return transitions[this.current];
        };
        fsm.isFinished = function() {
          return this.is(terminal);
        };
        fsm.error = cfg.error || function(name, from, to, args, error, msg, e) {
          throw e || msg;
        };
        if (initial && !initial.defer)
          fsm[initial.event]();
        return fsm;
      },
      doCallback: function(fsm, func, name, from, to, args) {
        if (func) {
          try {
            return func.apply(fsm, [name, from, to].concat(args));
          } catch (e) {
            return fsm.error(name, from, to, args, StateMachine.Error.INVALID_CALLBACK, "an exception occurred in a caller-provided callback function", e);
          }
        }
      },
      beforeAnyEvent: function(fsm, name, from, to, args) {
        return StateMachine.doCallback(fsm, fsm['onbeforeevent'], name, from, to, args);
      },
      afterAnyEvent: function(fsm, name, from, to, args) {
        return StateMachine.doCallback(fsm, fsm['onafterevent'] || fsm['onevent'], name, from, to, args);
      },
      leaveAnyState: function(fsm, name, from, to, args) {
        return StateMachine.doCallback(fsm, fsm['onleavestate'], name, from, to, args);
      },
      enterAnyState: function(fsm, name, from, to, args) {
        return StateMachine.doCallback(fsm, fsm['onenterstate'] || fsm['onstate'], name, from, to, args);
      },
      changeState: function(fsm, name, from, to, args) {
        return StateMachine.doCallback(fsm, fsm['onchangestate'], name, from, to, args);
      },
      beforeThisEvent: function(fsm, name, from, to, args) {
        return StateMachine.doCallback(fsm, fsm['onbefore' + name], name, from, to, args);
      },
      afterThisEvent: function(fsm, name, from, to, args) {
        return StateMachine.doCallback(fsm, fsm['onafter' + name] || fsm['on' + name], name, from, to, args);
      },
      leaveThisState: function(fsm, name, from, to, args) {
        return StateMachine.doCallback(fsm, fsm['onleave' + from], name, from, to, args);
      },
      enterThisState: function(fsm, name, from, to, args) {
        return StateMachine.doCallback(fsm, fsm['onenter' + to] || fsm['on' + to], name, from, to, args);
      },
      beforeEvent: function(fsm, name, from, to, args) {
        if ((false === StateMachine.beforeThisEvent(fsm, name, from, to, args)) || (false === StateMachine.beforeAnyEvent(fsm, name, from, to, args)))
          return false;
      },
      afterEvent: function(fsm, name, from, to, args) {
        StateMachine.afterThisEvent(fsm, name, from, to, args);
        StateMachine.afterAnyEvent(fsm, name, from, to, args);
      },
      leaveState: function(fsm, name, from, to, args) {
        var specific = StateMachine.leaveThisState(fsm, name, from, to, args),
            general = StateMachine.leaveAnyState(fsm, name, from, to, args);
        if ((false === specific) || (false === general))
          return false;
        else if ((StateMachine.ASYNC === specific) || (StateMachine.ASYNC === general))
          return StateMachine.ASYNC;
      },
      enterState: function(fsm, name, from, to, args) {
        StateMachine.enterThisState(fsm, name, from, to, args);
        StateMachine.enterAnyState(fsm, name, from, to, args);
      },
      buildEvent: function(name, map) {
        return function() {
          var from = this.current;
          var to = map[from] || map[StateMachine.WILDCARD] || from;
          var args = Array.prototype.slice.call(arguments);
          if (this.transition)
            return this.error(name, from, to, args, StateMachine.Error.PENDING_TRANSITION, "event " + name + " inappropriate because previous transition did not complete");
          if (this.cannot(name))
            return this.error(name, from, to, args, StateMachine.Error.INVALID_TRANSITION, "event " + name + " inappropriate in current state " + this.current);
          if (false === StateMachine.beforeEvent(this, name, from, to, args))
            return StateMachine.Result.CANCELLED;
          if (from === to) {
            StateMachine.afterEvent(this, name, from, to, args);
            return StateMachine.Result.NOTRANSITION;
          }
          var fsm = this;
          this.transition = function() {
            fsm.transition = null;
            fsm.current = to;
            StateMachine.enterState(fsm, name, from, to, args);
            StateMachine.changeState(fsm, name, from, to, args);
            StateMachine.afterEvent(fsm, name, from, to, args);
            return StateMachine.Result.SUCCEEDED;
          };
          this.transition.cancel = function() {
            fsm.transition = null;
            StateMachine.afterEvent(fsm, name, from, to, args);
          };
          var leave = StateMachine.leaveState(this, name, from, to, args);
          if (false === leave) {
            this.transition = null;
            return StateMachine.Result.CANCELLED;
          } else if (StateMachine.ASYNC === leave) {
            return StateMachine.Result.PENDING;
          } else {
            if (this.transition)
              return this.transition();
          }
        };
      }
    };
    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = StateMachine;
      }
      exports.StateMachine = StateMachine;
    } else if (typeof define === 'function' && define.amd) {
      define(function($__require) {
        return StateMachine;
      });
    } else if (typeof window !== 'undefined') {
      window.StateMachine = StateMachine;
    } else if (typeof self !== 'undefined') {
      self.StateMachine = StateMachine;
    }
  }());
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14", ["7c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('7c');
  global.define = __define;
  return module.exports;
});

$__System.register('7d', ['3', '6', '7', '9', '13', '14', '75', '78', '1b', '1c', '7b', '6b', '7e'], function (_export) {
  var THREE, StarSystem, settings, _classCallCheck, TWEEN, StateMachine, _Object$create, _Number$isFinite, _get, _inherits, _Object$defineProperties, UI, toggleFullScreen, startEvent, changeEvent, endEvent, OrbitControls;

  return {
    setters: [function (_6) {
      THREE = _6['default'];
    }, function (_4) {
      StarSystem = _4['default'];
    }, function (_5) {
      settings = _5['default'];
    }, function (_) {
      _classCallCheck = _['default'];
    }, function (_7) {
      TWEEN = _7['default'];
    }, function (_8) {
      StateMachine = _8['default'];
    }, function (_3) {
      _Object$create = _3['default'];
    }, function (_2) {
      _Number$isFinite = _2['default'];
    }, function (_b) {
      _get = _b['default'];
    }, function (_c) {
      _inherits = _c['default'];
    }, function (_b2) {
      _Object$defineProperties = _b2['default'];
    }, function (_b3) {
      UI = _b3['default'];
    }, function (_e) {
      toggleFullScreen = _e['default'];
    }],
    execute: function () {
      // jscs:disable
      // Wrapped as an ES6 module by Lianna Eeftinck - https://github.com/Leeft/

      'use strict';

      startEvent = { type: 'start' };
      changeEvent = { type: 'change' };
      endEvent = { type: 'end' };

      /**
       * @author qiao / https://github.com/qiao
       * @author mrdoob / http://mrdoob.com
       * @author alteredq / http://alteredqualia.com/
       * @author WestLangley / http://github.com/WestLangley
       * @author erich666 / http://erichaines.com
       */

      // This set of controls performs orbiting, dollying (zooming), and panning.
      // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
      //
      //    Orbit - left mouse / touch: one finger move
      //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
      //    Pan - right mouse, or arrow keys / touch: three finter swipe

      THREE.OrbitControls = function (object, domElement) {
        var _this = this;

        this.object = object;

        this.domElement = domElement !== undefined ? domElement : document;

        // Set to false to disable this control
        this.enabled = true;

        // "target" sets the location of focus, where the object orbits around
        this.target = new THREE.Vector3();

        // How far you can dolly in and out ( PerspectiveCamera only )
        this.minDistance = 0;
        this.maxDistance = Infinity;

        // How far you can zoom in and out ( OrthographicCamera only )
        this.minZoom = 0;
        this.maxZoom = Infinity;

        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians

        // How far you can orbit horizontally, upper and lower limits.
        // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
        this.minAzimuthAngle = -Infinity; // radians
        this.maxAzimuthAngle = Infinity; // radians

        // Set to true to enable damping (inertia)
        // If damping is enabled, you must call controls.update() in your animation loop
        this.enableDamping = false;
        this.dampingFactor = 0.25;

        // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
        // Set to false to disable zooming
        this.enableZoom = true;
        this.zoomSpeed = 1.0;

        // Set to false to disable rotating
        this.enableRotate = true;
        this.rotateSpeed = 1.0;

        // Set to false to disable panning
        this.enablePan = true;
        this.keyPanSpeed = 7.0; // pixels moved per arrow key push

        // Set to true to automatically rotate around the target
        // If auto-rotate is enabled, you must call controls.update() in your animation loop
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

        // Set to false to disable use of the keys
        this.enableKeys = true;

        // The four arrow keys
        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

        // Mouse buttons
        this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

        // for reset
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;

        //
        // public methods
        //

        this.getPolarAngle = function () {

          return phi;
        };

        this.getAzimuthalAngle = function () {

          return theta;
        };

        this.reset = function () {

          scope.target.copy(scope.target0);
          scope.object.position.copy(scope.position0);
          scope.object.zoom = scope.zoom0;

          scope.object.updateProjectionMatrix();
          scope.dispatchEvent(changeEvent);

          scope.update();

          state = STATE.NONE;
        };

        // this method is exposed, but perhaps it would be better if we can make it private...
        this.update = (function () {

          var offset = new THREE.Vector3();

          // so camera.up is the orbit axis
          var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
          var quatInverse = quat.clone().inverse();

          var lastPosition = new THREE.Vector3();
          var lastQuaternion = new THREE.Quaternion();

          return function () {

            var position = scope.object.position;

            offset.copy(position).sub(scope.target);

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion(quat);

            // angle from z-axis around y-axis

            theta = Math.atan2(offset.x, offset.z);

            // angle from y-axis

            phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);

            if (scope.autoRotate && state === STATE.NONE) {

              rotateLeft(getAutoRotationAngle());
            }

            theta += thetaDelta;
            phi += phiDelta;

            // restrict theta to be between desired limits
            theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, theta));

            // restrict phi to be between desired limits
            phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, phi));

            // restrict phi to be betwee EPS and PI-EPS
            phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

            var radius = offset.length() * scale;

            // restrict radius to be between desired limits
            radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, radius));

            // move target to panned location
            scope.target.add(panOffset);

            offset.x = radius * Math.sin(phi) * Math.sin(theta);
            offset.y = radius * Math.cos(phi);
            offset.z = radius * Math.sin(phi) * Math.cos(theta);

            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion(quatInverse);

            position.copy(scope.target).add(offset);

            scope.object.lookAt(scope.target);

            if (scope.enableDamping === true) {

              thetaDelta *= 1 - scope.dampingFactor;
              phiDelta *= 1 - scope.dampingFactor;
            } else {

              thetaDelta = 0;
              phiDelta = 0;
            }

            scale = 1;
            panOffset.set(0, 0, 0);

            // update condition is:
            // min(camera displacement, camera rotation in radians)^2 > EPS
            // using small-angle approximation cos(x/2) = 1 - x^2 / 8

            if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {

              scope.dispatchEvent(changeEvent);

              lastPosition.copy(scope.object.position);
              lastQuaternion.copy(scope.object.quaternion);
              zoomChanged = false;

              return true;
            }

            return false;
          };
        })();

        this.dispose = function () {

          scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
          scope.domElement.removeEventListener('mousedown', onMouseDown, false);
          scope.domElement.removeEventListener('mousewheel', onMouseWheel, false);
          scope.domElement.removeEventListener('MozMousePixelScroll', onMouseWheel, false); // firefox

          scope.domElement.removeEventListener('touchstart', onTouchStart, false);
          scope.domElement.removeEventListener('touchend', onTouchEnd, false);
          scope.domElement.removeEventListener('touchmove', onTouchMove, false);

          document.removeEventListener('mousemove', onMouseMove, false);
          document.removeEventListener('mouseup', onMouseUp, false);
          document.removeEventListener('mouseout', onMouseUp, false);

          window.removeEventListener('keydown', onKeyDown, false);

          //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
        };

        //
        // internals
        //

        var scope = this;

        /*
        var changeEvent = { type: 'change' };
        var startEvent = { type: 'start' };
        var endEvent = { type: 'end' };
        */

        var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

        STATE.DRAGROUTE = 6; // Leeft addition
        STATE.PAN_XY = 7; // Leeft addition
        STATE.TOUCH_PAN_XY = 8; // Leeft addition

        var state = STATE.NONE;

        var EPS = 0.000001;

        // current position in spherical coordinates
        var theta;
        var phi;

        var phiDelta = 0;
        var thetaDelta = 0;
        var scale = 1;
        var panOffset = new THREE.Vector3();
        var zoomChanged = false;

        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();

        var panStart = new THREE.Vector2();
        var panEnd = new THREE.Vector2();
        var panDelta = new THREE.Vector2();

        var dollyStart = new THREE.Vector2();
        var dollyEnd = new THREE.Vector2();
        var dollyDelta = new THREE.Vector2();

        function getAutoRotationAngle() {

          return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
        }

        function getZoomScale() {

          return Math.pow(0.95, scope.zoomSpeed);
        }

        function rotateLeft(angle) {

          thetaDelta -= angle;
        }

        function rotateUp(angle) {

          phiDelta -= angle;
        }

        var panLeft = (function () {

          var v = new THREE.Vector3();

          return function panLeft(distance, objectMatrix) {

            var te = objectMatrix.elements;

            // get X column of objectMatrix
            v.set(te[0], te[1], te[2]);

            v.multiplyScalar(-distance);

            panOffset.add(v);
          };
        })();

        var panUp = (function () {

          var v = new THREE.Vector3();

          return function panUp(distance, objectMatrix) {

            var te = objectMatrix.elements;

            // get Y column of objectMatrix
            v.set(te[4], te[5], te[6]);

            v.multiplyScalar(distance);

            panOffset.add(v);
          };
        })();

        //
        // Leeft addition: pan across grid rather than x/y screen coordinates
        //
        var orgPanUp = panUp;

        panUp = (function () {

          return function (distance) {
            var sameLevelTarget = _this.target.clone().setY(_this.object.position.y);
            var v = _this.object.position.clone().sub(sameLevelTarget).negate().setLength(distance);
            panOffset.add(v);
          };
        })();
        //
        // End Leeft addition
        //

        // deltaX and deltaY are in pixels; right and down are positive
        var pan = (function () {

          var offset = new THREE.Vector3();

          return function (deltaX, deltaY) {

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            if (scope.object instanceof THREE.PerspectiveCamera) {

              // perspective
              var position = scope.object.position;
              offset.copy(position).sub(scope.target);
              var targetDistance = offset.length();

              // half of the fov is center to top of screen
              targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

              // we actually don't use screenWidth, since perspective camera is fixed to screen height
              panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
              // Leeft modifications start
              if (state === STATE.PAN_XY || state === STATE.TOUCH_PAN_XY) {
                orgPanUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
              } else {
                panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
              }
              // Leeft modifications end
            } else if (scope.object instanceof THREE.OrthographicCamera) {

                // orthographic
                panLeft(deltaX * (scope.object.right - scope.object.left) / element.clientWidth, scope.object.matrix);
                panUp(deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight, scope.object.matrix);
              } else {

                // camera neither orthographic nor perspective
                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
                scope.enablePan = false;
              }
          };
        })();

        function dollyIn(dollyScale) {

          if (scope.object instanceof THREE.PerspectiveCamera) {

            scale /= dollyScale;
          } else if (scope.object instanceof THREE.OrthographicCamera) {

            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {

            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
            scope.enableZoom = false;
          }
        }

        function dollyOut(dollyScale) {

          if (scope.object instanceof THREE.PerspectiveCamera) {

            scale *= dollyScale;
          } else if (scope.object instanceof THREE.OrthographicCamera) {

            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          } else {

            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
            scope.enableZoom = false;
          }
        }

        //
        // event callbacks - update the object state
        //

        function handleMouseDownRotate(event) {

          //console.log( 'handleMouseDownRotate' );

          rotateStart.set(event.clientX, event.clientY);
        }

        function handleMouseDownDolly(event) {

          //console.log( 'handleMouseDownDolly' );

          dollyStart.set(event.clientX, event.clientY);
        }

        function handleMouseDownPan(event) {

          //console.log( 'handleMouseDownPan' );

          panStart.set(event.clientX, event.clientY);
        }

        function handleMouseMoveRotate(event) {

          //console.log( 'handleMouseMoveRotate' );

          rotateEnd.set(event.clientX, event.clientY);
          rotateDelta.subVectors(rotateEnd, rotateStart);

          var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

          // rotating across whole screen goes 360 degrees around
          rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

          // rotating up and down along whole screen attempts to go 360, but limited to 180
          rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

          rotateStart.copy(rotateEnd);

          scope.update();
        }

        function handleMouseMoveDolly(event) {

          //console.log( 'handleMouseMoveDolly' );

          dollyEnd.set(event.clientX, event.clientY);

          dollyDelta.subVectors(dollyEnd, dollyStart);

          if (dollyDelta.y > 0) {

            dollyIn(getZoomScale());
          } else if (dollyDelta.y < 0) {

            dollyOut(getZoomScale());
          }

          dollyStart.copy(dollyEnd);

          scope.update();
        }

        function handleMouseMovePan(event) {

          //console.log( 'handleMouseMovePan' );

          panEnd.set(event.clientX, event.clientY);

          panDelta.subVectors(panEnd, panStart);

          pan(panDelta.x, panDelta.y);

          panStart.copy(panEnd);

          scope.update();
        }

        function handleMouseUp(event) {

          //console.log( 'handleMouseUp' );

          // Leeft addition start
          if (state === STATE.DRAGROUTE) {
            var system = systemIndicated(event);
            if (system) {
              scope.endObject = system;
              if (system !== scope.startObject) {
                var route = scope.map.route();
                if (route.isSet() && scope.startObject !== scope.endObject) {
                  route.update(scope.endObject);
                  route.storeToSession();
                  UI.toTab('route');
                }
              } else if (system === scope.startObject) {
                scope.map.setSelectionTo(system);
                UI.displayInfoOn(system);
              }
            }
          }

          scope.dispatchEvent(changeEvent);

          // Leeft addition end
        }

        function handleMouseWheel(event) {

          //console.log( 'handleMouseWheel' );

          var delta = 0;

          if (event.wheelDelta !== undefined) {

            // WebKit / Opera / Explorer 9

            delta = event.wheelDelta;
          } else if (event.detail !== undefined) {

            // Firefox

            delta = -event.detail;
          }

          if (delta > 0) {

            dollyOut(getZoomScale());
          } else if (delta < 0) {

            dollyIn(getZoomScale());
          }

          scope.update();
        }

        function handleKeyDown(event) {

          //console.log( 'handleKeyDown' );

          switch (event.keyCode) {

            case scope.keys.UP:
              pan(0, scope.keyPanSpeed);
              scope.update();
              break;

            case scope.keys.BOTTOM:
              pan(0, -scope.keyPanSpeed);
              scope.update();
              break;

            case scope.keys.LEFT:
              pan(scope.keyPanSpeed, 0);
              scope.update();
              break;

            case scope.keys.RIGHT:
              pan(-scope.keyPanSpeed, 0);
              scope.update();
              break;

            //
            // Leeft additions ..
            //

            case scope.keys.ESCAPE:
              // Deselect selected
              scope.map.deselect();
              break;

            case scope.keys.TAB:
              // Tab through route
              // TODO
              break;

            case scope.keys.R:
              // Reset orientation
              scope.rotateTo(0, undefined, undefined);
              break;

            case scope.keys.C:
              // Center on default
              scope.moveTo(settings.cameraDefaults.target);
              break;

            case scope.keys.T:
              // Top view
              scope.rotateTo(0, 0, 200);
              break;

            case scope.keys.ENTER:
              // Full screen
              toggleFullScreen();
              break;

            case scope.keys['2']:
              // 2D mode
              scope.enableRotate = false;
              UI.rotationLocked();
              scope.map.displayState.to2d();
              scope.rotateTo(0, 0, 180);
              break;

            case scope.keys['3']:
              // 3D mode
              scope.enableRotate = true;
              scope.map.displayState.to3d();
              UI.rotationUnlocked();
              scope.rotateTo(settings.cameraDefaults.orientation.theta, settings.cameraDefaults.orientation.phi, settings.cameraDefaults.orientation.radius);
              break;

            case scope.keys.L:
              // Lock/unlock rotation
              if (!event.ctrlKey) {
                UI.rotationLockToggle();
              }
              break;

            //
            // End of Leeft additions
            //
          }
        }

        function handleTouchStartRotate(event) {

          //console.log( 'handleTouchStartRotate' );

          rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
        }

        function handleTouchStartDolly(event) {

          //console.log( 'handleTouchStartDolly' );

          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;

          var distance = Math.sqrt(dx * dx + dy * dy);

          dollyStart.set(0, distance);
        }

        function handleTouchStartPan(event) {

          //console.log( 'handleTouchStartPan' );

          panStart.set(event.touches[0].pageX, event.touches[0].pageY);
        }

        function handleTouchMoveRotate(event) {

          //console.log( 'handleTouchMoveRotate' );

          rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
          rotateDelta.subVectors(rotateEnd, rotateStart);

          var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

          // rotating across whole screen goes 360 degrees around
          rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

          // rotating up and down along whole screen attempts to go 360, but limited to 180
          rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

          rotateStart.copy(rotateEnd);

          scope.update();
        }

        function handleTouchMoveDolly(event) {

          //console.log( 'handleTouchMoveDolly' );

          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;

          var distance = Math.sqrt(dx * dx + dy * dy);

          dollyEnd.set(0, distance);

          dollyDelta.subVectors(dollyEnd, dollyStart);

          if (dollyDelta.y > 0) {

            dollyOut(getZoomScale());
          } else if (dollyDelta.y < 0) {

            dollyIn(getZoomScale());
          }

          dollyStart.copy(dollyEnd);

          scope.update();
        }

        function handleTouchMovePan(event) {

          //console.log( 'handleTouchMovePan' );

          panEnd.set(event.touches[0].pageX, event.touches[0].pageY);

          panDelta.subVectors(panEnd, panStart);

          pan(panDelta.x, panDelta.y);

          panStart.copy(panEnd);

          scope.update();
        }

        function handleTouchEnd(event) {

          //console.log( 'handleTouchEnd' );

          // Leeft addition start
          if (state === STATE.DRAGROUTE) {
            var system = systemIndicated(event);
            if (system) {
              scope.endObject = system;
              if (system !== scope.startObject) {
                var route = scope.map.route();
                if (route.isSet() && scope.startObject !== scope.endObject) {
                  route.update(scope.endObject);
                  route.storeToSession();
                  UI.toTab('route');
                }
              } else if (system === scope.startObject) {
                scope.map.setSelectionTo(system);
                UI.displayInfoOn(system);
              }
            }
          }

          scope.dispatchEvent(changeEvent);

          // Leeft addition end
        }

        //
        // Leeft additions
        //
        this.moveTo = function (destination) {
          // method assumes mapMode for now
          // FIXME: destination should be only a vector, not a system
          var destinationVector = undefined;

          // makes sure the destination is at the same xz plane
          if (destination instanceof StarSystem) {
            destinationVector = destination.position.clone();
          } else if (destination instanceof THREE.Vector3) {
            destinationVector = destination.clone();
          } else {
            return;
          }

          if (_this.targetTween) {
            _this.targetTween.stop();
          }

          if (destination instanceof StarSystem) {
            _this.map.setSelectionTo(destination);
          }

          var vec = new THREE.Vector3(0, 0, 0);

          _this.targetTween = new TWEEN.Tween(_this.target.clone()).to({ x: destinationVector.x, y: destinationVector.y, z: destinationVector.z }, 750).easing(TWEEN.Easing.Cubic.InOut).onUpdate(function () {
            vec.set(this.x, this.y, this.z);
            scope.goTo(vec);
            //this.isMoving = true; // FIXME
          });

          _this.targetTween.onComplete(function () {
            _this.map.syncCamera();
            _this.targetTween = undefined;
          });

          _this.targetTween.start();
        };

        // assumes mapMode for now
        this.goTo = function (vector) {
          // make sure the given vector is at the same xz plane
          vector = vector.clone();
          vector.sub(_this.target);
          panOffset.add(vector);
        };

        this.rotateTo = function (left, up, radius) {
          if (_this.rotationTween) {
            _this.rotationTween.stop();
          }

          var offset = _this.object.position.clone().sub(_this.target);

          var from = {
            left: _this.getAzimuthalAngle(),
            up: _this.getPolarAngle(),
            radius: offset.length()
          };

          var to = {
            left: _Number$isFinite(left) ? left : _this.getAzimuthalAngle(),
            up: _Number$isFinite(up) ? up : _this.getPolarAngle(),
            radius: _Number$isFinite(radius) ? radius : offset.length()
          };

          _this.rotationTween = new TWEEN.Tween(from).to(to, 800).easing(TWEEN.Easing.Cubic.InOut).onUpdate(function () {
            if (_Number$isFinite(left)) {
              rotateLeft(scope.getAzimuthalAngle() - this.left);
            }
            if (_Number$isFinite(up)) {
              rotateUp(scope.getPolarAngle() - this.up);
            }
            if (_Number$isFinite(radius)) {
              var _offset = scope.object.position.clone().sub(scope.target).length();
              scale = this.radius / _offset;
            }
            scope.map.syncCamera();
          });

          _this.rotationTween.onComplete(function () {
            _this.rotationTween = undefined;
            _this.map.syncCamera();
          });

          _this.dispatchEvent(startEvent);
          _this.rotationTween.start();
        };

        this.cameraTo = function (target, theta, phi, radius) {
          _this.rotateTo(theta, phi, radius);
          _this.moveTo(target);
        };

        this.rememberPosition = function () {
          settings.camera.camera = _this.object.position;
          settings.camera.target = _this.target;
          settings.save('camera');
        };

        function systemIndicated(event) {
          var intersect = scope.map.getIntersect(event);
          if (intersect && intersect.object.userData.system) {
            return intersect.object.userData.system;
          }
          return;
        }

        function handleMouseMoveDrag(event) {
          var system = systemIndicated(event);

          //UI.endHoverOverStarSystem(); // FIXME

          if (system) {

            //UI.startHoverOverStarSystem(); // FIXME

            if (scope.startObject !== system && scope.endObject !== system) {

              scope.endObject = system;

              var route = scope.map.route();

              if (!route.isSet()) {
                route.start = scope.startObject;
                route.waypoints = [scope.endObject];
                route.update();
                route.storeToSession();
                //if ( scope.debug ) {
                //  console.log( 'Intermediate object while dragging is "' + endObject.name + '"' );
                //}
              } else {
                  route.moveWaypoint(scope.startObject, scope.endObject);
                  if (scope.startObject !== scope.endObject) {
                    route.update();
                    route.storeToSession();
                  }
                  scope.startObject = scope.endObject;
                  //console.log( 'In-route mode -- intermediate object while dragging is "' + endObject.name + '"' );
                }
            }
          }
        }

        //
        // End of Leeft additions
        //

        //
        // event handlers - FSM: listen for events and reset state
        //

        function onMouseDown(event) {
          if (scope.enabled === false) return;

          event.preventDefault();

          if (event.button === scope.mouseButtons.ORBIT) {

            // Leeft additions and modification
            var system = systemIndicated(event);

            if (system) {

              scope.startObject = system;
              scope.endObject = undefined;

              if (scope.enableRouting === false) return;

              state = STATE.DRAGROUTE;
            } else {

              if (scope.enableRotate === false) return;

              handleMouseDownRotate(event);

              state = STATE.ROTATE;
            }
            // End Leeft additions and modification
          } else if (event.button === scope.mouseButtons.ZOOM) {

              if (scope.enableZoom === false) return;

              handleMouseDownDolly(event);

              state = STATE.DOLLY;
            } else if (event.button === scope.mouseButtons.PAN) {

              if (scope.enablePan === false) return;

              handleMouseDownPan(event);

              // Leeft additions and modification
              if (event.altKey) {
                state = STATE.PAN_XY;
              } else {
                state = STATE.PAN;
              }
              // End Leeft additions and modification
            }

          if (state !== STATE.NONE) {

            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mouseout', onMouseUp, false);

            scope.dispatchEvent(startEvent);
          }
        }

        function onMouseMove(event) {

          if (scope.enabled === false) return;

          event.preventDefault();

          if (state === STATE.ROTATE) {

            if (scope.enableRotate === false) return;

            handleMouseMoveRotate(event);

            scope.map.syncCamera();
          } else if (state === STATE.DOLLY) {

            if (scope.enableZoom === false) return;

            handleMouseMoveDolly(event);
          } else if (state === STATE.PAN) {

            if (scope.enablePan === false) return;

            handleMouseMovePan(event);

            // Leeft addition
          } else if (state === STATE.PAN_XY) {

              if (scope.enablePan === false) return;

              handleMouseMovePan(event);
            } else if (state === STATE.DRAGROUTE) {

              if (scope.enableRouting === false) return;

              handleMouseMoveDrag(event);

              // End Leeft addition
            }
        }

        function onMouseUp(event) {

          if (scope.enabled === false) return;

          handleMouseUp(event);

          document.removeEventListener('mousemove', onMouseMove, false);
          document.removeEventListener('mouseup', onMouseUp, false);
          document.removeEventListener('mouseout', onMouseUp, false);

          scope.dispatchEvent(endEvent);

          state = STATE.NONE;
        }

        function onMouseWheel(event) {

          if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;

          event.preventDefault();
          event.stopPropagation();

          handleMouseWheel(event);

          scope.dispatchEvent(startEvent); // not sure why these are here...
          scope.dispatchEvent(endEvent);
        }

        function onKeyDown(event) {

          if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;

          handleKeyDown(event);
        }

        function onTouchStart(event) {

          if (scope.enabled === false) return;

          switch (event.touches.length) {

            case 1:
              // one-fingered touch: rotate

              // Leeft additions and modification
              var system = systemIndicated(event);

              if (system) {

                scope.startObject = system;
                scope.endObject = undefined;

                if (scope.enableRouting === false) return;

                state = STATE.DRAGROUTE;
              } else {

                if (scope.enableRotate === false) return;

                handleTouchStartRotate(event);

                state = STATE.TOUCH_ROTATE;
              }
              // End Leeft additions and modification

              break;

            case 2:
              // two-fingered touch: dolly

              if (scope.enableZoom === false) return;

              handleTouchStartDolly(event);

              state = STATE.TOUCH_DOLLY;

              break;

            case 3:
              // three-fingered touch: pan

              if (scope.enablePan === false) return;

              handleTouchStartPan(event);

              state = STATE.TOUCH_PAN;

              break;

            // Leeft

            case 4:
              // four-fingered touch: pan

              if (scope.enablePan === false) return;

              handleTouchStartPan(event);

              state = STATE.TOUCH_PAN_XY;

              break;

            // End leeft

            default:

              state = STATE.NONE;

          }

          if (state !== STATE.NONE) {

            scope.dispatchEvent(startEvent);
          }
        }

        function onTouchMove(event) {

          if (scope.enabled === false) return;

          event.preventDefault();
          event.stopPropagation();

          switch (event.touches.length) {

            case 1:
              // one-fingered touch: rotate

              // Leeft addition and modification

              if (state === STATE.DRAGROUTE) {

                if (scope.enableRouting === false) return;

                handleMouseMoveDrag(event);
              } else {

                if (scope.enableRotate === false) return;
                if (state !== STATE.TOUCH_ROTATE) return; // is this needed?...

                handleTouchMoveRotate(event);

                scope.map.syncCamera();
              }

              // End Leeft addition and modification

              break;

            case 2:
              // two-fingered touch: dolly

              if (scope.enableZoom === false) return;
              if (state !== STATE.TOUCH_DOLLY) return; // is this needed?...

              handleTouchMoveDolly(event);

              break;

            case 3:
              // three-fingered touch: pan

              if (scope.enablePan === false) return;
              if (state !== STATE.TOUCH_PAN) return; // is this needed?...

              handleTouchMovePan(event);

              break;

            // Leeft

            case 4:
              // four-fingered touch: pan

              if (scope.enablePan === false) return;
              if (state !== STATE.TOUCH_PAN_XY) return; // is this needed?...

              handleTouchMovePan(event);

              break;

            // End leeft

            default:

              state = STATE.NONE;

          }
        }

        function onTouchEnd(event) {

          if (scope.enabled === false) return;

          handleTouchEnd(event);

          scope.dispatchEvent(endEvent);

          state = STATE.NONE;
        }

        function onContextMenu(event) {

          event.preventDefault();
        }

        //

        scope.domElement.addEventListener('contextmenu', onContextMenu, false);

        scope.domElement.addEventListener('mousedown', onMouseDown, false);
        scope.domElement.addEventListener('mousewheel', onMouseWheel, false);
        scope.domElement.addEventListener('MozMousePixelScroll', onMouseWheel, false); // firefox

        scope.domElement.addEventListener('touchstart', onTouchStart, false);
        scope.domElement.addEventListener('touchend', onTouchEnd, false);
        scope.domElement.addEventListener('touchmove', onTouchMove, false);

        window.addEventListener('keydown', onKeyDown, false);

        // force an update at start

        this.update();
      };

      THREE.OrbitControls.prototype = _Object$create(THREE.EventDispatcher.prototype);
      THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

      _Object$defineProperties(THREE.OrbitControls.prototype, {

        center: {

          get: function get() {

            console.warn('THREE.OrbitControls: .center has been renamed to .target');
            return this.target;
          }

        },

        // backward compatibility

        noZoom: {

          get: function get() {

            console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
            return !this.enableZoom;
          },

          set: function set(value) {

            console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
            this.enableZoom = !value;
          }

        },

        noRotate: {

          get: function get() {

            console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
            return !this.enableRotate;
          },

          set: function set(value) {

            console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
            this.enableRotate = !value;
          }

        },

        noPan: {

          get: function get() {

            console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
            return !this.enablePan;
          },

          set: function set(value) {

            console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
            this.enablePan = !value;
          }

        },

        noKeys: {

          get: function get() {

            console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
            return !this.enableKeys;
          },

          set: function set(value) {

            console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
            this.enableKeys = !value;
          }

        },

        staticMoving: {

          get: function get() {

            console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
            return !this.constraint.enableDamping;
          },

          set: function set(value) {

            console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
            this.constraint.enableDamping = !value;
          }

        },

        dynamicDampingFactor: {

          get: function get() {

            console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
            return this.constraint.dampingFactor;
          },

          set: function set(value) {

            console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
            this.constraint.dampingFactor = value;
          }

        }

      });

      // Leeft additions, done here as far as possible to make OrbitControls updates easier

      OrbitControls = (function (_THREE$OrbitControls) {
        _inherits(OrbitControls, _THREE$OrbitControls);

        function OrbitControls(renderer) {
          _classCallCheck(this, OrbitControls);

          // My own constructor takes different arguments, so make them compatible
          // without having to modify the base class
          _get(Object.getPrototypeOf(OrbitControls.prototype), 'constructor', this).call(this, renderer.camera, renderer.container);

          this.map = renderer.map;
          this.keys = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            BOTTOM: 40,
            ESCAPE: 27,
            R: 82,
            C: 67,
            T: 84,
            2: 50,
            3: 51,
            L: 76,
            SPACE: 32,
            TAB: 9,
            ENTER: 13
          };

          this.targetTween = undefined;
          this.rotationTween = undefined;
          this.enableRouting = true;
        }

        //this.cameraIsMoving = function cameraIsMoving() {
        //  return(
        //    (state.current === 'pan') ||
        //    (state.current === 'dolly') ||
        //    (state.current === 'rotate') ||
        //    (state.current === 'loading') ||
        //    !dollyStart.equals( dollyEnd ) ||
        //    isMoving
        //  );
        //}
        return OrbitControls;
      })(THREE.OrbitControls);

      _export('default', OrbitControls);
    }
  };
});
$__System.registerDynamic("7f", ["45"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('45');
  $export($export.S, 'Number', {isNaN: function isNaN(number) {
      return number != number;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("80", ["7f", "23"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('7f');
  module.exports = $__require('23').Number.isNaN;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("81", ["80"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('80'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.register('82', ['8', '9', '34', '81'], function (_export) {
  var _createClass, _classCallCheck, _Object$assign, _Number$isNaN, DEFAULTS, IconLabelSymbol;

  return {
    setters: [function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_3) {
      _Object$assign = _3['default'];
    }, function (_4) {
      _Number$isNaN = _4['default'];
    }],
    execute: function () {
      'use strict';

      DEFAULTS = {
        fontFamily: 'FontAwesome', // Can override the font to use if needed (note that it won't be loaded for you!)
        color: 'rgba(255,255,255,1.0)', // The color we'll use to render with

        scale: 1.0, // Scale can be used to make different icons appear the same size
        offset: { x: 0, y: 0 }, // As does offset (which can be a THREE.Vector2 as well)

        cssClass: 'fa-warning', // You can use this for HTML generation (this class itself does not use it)
        description: '' };
      // And the description is for HTML generation as well, I've used it for a legend

      IconLabelSymbol = (function () {
        function IconLabelSymbol() {
          var _this = this;

          _classCallCheck(this, IconLabelSymbol);

          if (typeof arguments[0] !== 'object') {
            throw new Error('Symbol requires an object for the constructor');
          }

          if (!('code' in arguments[0])) {
            throw new Error('Missing code argument');
          }

          _Object$assign(this, DEFAULTS, arguments[0]);

          // Force a check for these important properties
          ['code', 'scale', 'offset'].forEach(function (prop) {
            _this[prop] = _this[prop];
          });
        }

        _createClass(IconLabelSymbol, [{
          key: 'code',
          set: function set(value) {
            if (typeof value !== 'string' || value.length < 1) {
              throw new TypeError('code must be a single character string');
            }
            if (value.length !== 1) {
              throw new TypeError('Multiple character code not currently supported (' + value + ')');
            }
            this._code = value;
          },
          get: function get() {
            return this._code;
          }
        }, {
          key: 'scale',
          set: function set(value) {
            if (typeof value !== 'number') {
              throw new TypeError('scale must be a number');
            }
            if (_Number$isNaN(value) || value < 0.1 || value > 5.0) {
              throw new RangeError('scale is outside my expected useful range');
            }
            this._scale = value;
          },
          get: function get() {
            return this._scale;
          }
        }, {
          key: 'offset',
          set: function set(value) {
            if (value === null || typeof value !== 'object' || !'x' in value || !'y' in value) {
              throw new TypeError('offset must be an object with .x and .y properties');
            }
            this._offset = value;
          },
          get: function get() {
            return this._offset;
          }
        }]);

        return IconLabelSymbol;
      })();

      _export('default', IconLabelSymbol);
    }
  };
});
$__System.register('83', ['82'], function (_export) {
  /**
  * @author Lianna Eeftinck / https://github.com/Leeft
  */

  // TODO: Make this data-driven?

  'use strict';

  var IconLabelSymbol, SYMBOLS;
  return {
    setters: [function (_) {
      IconLabelSymbol = _['default'];
    }],
    execute: function () {
      SYMBOLS = {

        DANGER: new IconLabelSymbol({
          code: '',
          scale: 0.9,
          cssClass: 'fa-warning',
          description: 'Danger, hostile faction',
          color: 'rgba(255,50,50,1.0)'
        }),

        WARNING: new IconLabelSymbol({
          code: '',
          scale: 0.9,
          cssClass: 'fa-warning',
          description: 'Warning, hostile environment',
          color: 'rgba(255,117,25,1.0)'
        }),

        HANGAR: new IconLabelSymbol({
          code: '',
          scale: 1.15,
          cssClass: 'fa-home',
          description: 'Hangar location',
          color: 'rgba(255,255,255,1.0)',
          offset: { x: -0.25, y: -1 }
        }),

        INFO: new IconLabelSymbol({
          code: '',
          scale: 1.0,
          cssClass: 'fa-info-circle',
          description: 'Information available',
          color: 'rgba(255,162,255,1.0)'
        }),

        TRADE: new IconLabelSymbol({
          code: '',
          scale: 0.9,
          cssClass: 'fa-shopping-basket',
          description: 'Major trade hub',
          color: 'rgba(255,255,0,1.0)',
          offset: { x: 0, y: -1 }
        }),

        BANNED: new IconLabelSymbol({
          code: '',
          scale: 1.0,
          cssClass: 'fa-ban',
          description: 'System off-limits',
          color: 'rgba(255, 117, 25, 1.0)',
          offset: { x: 0, y: -1 }
        }),

        AVOID: new IconLabelSymbol({
          code: '',
          scale: 1.2,
          cssClass: 'fa-times',
          description: 'Avoid: do not route here',
          color: 'rgba(255,50,50,1.0)',
          offset: { x: 0, y: -2 }
        }),

        COMMENTS: new IconLabelSymbol({
          code: '',
          scale: 1.0,
          cssClass: 'fa-comment',
          description: 'Your comments',
          color: 'rgba(106,187,207,1.0)',
          offset: { x: 0, y: -3 }
        }),

        BOOKMARK: new IconLabelSymbol({
          code: '',
          scale: 1.05,
          cssClass: 'fa-bookmark',
          description: 'Bookmarked',
          color: 'rgba(102,193,0,1.0)',
          offset: { x: -1, y: -1 }
        })
      };

      _export('default', SYMBOLS);
    }
  };
});
$__System.register('7', ['1', '5', '8', '9', 'b', '1e'], function (_export) {
  var SCMAP, hasLocalStorage, hasSessionStorage, _createClass, _classCallCheck, config, Vector3, Settings;

  return {
    setters: [function (_3) {
      SCMAP = _3['default'];
    }, function (_4) {
      hasLocalStorage = _4.hasLocalStorage;
      hasSessionStorage = _4.hasSessionStorage;
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_b) {
      config = _b['default'];
    }, function (_e) {
      Vector3 = _e.Vector3;
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */
      'use strict';

      Settings = (function () {
        function Settings() {
          _classCallCheck(this, Settings);

          if (hasLocalStorage()) {
            this.storage = window.localStorage;
          } else if (hasSessionStorage()) {
            this.storage = window.sessionStorage;
          } else {
            this.storage = {};
          }

          this.camera = {
            camera: new Vector3(0, 70 * config.renderScale, 100 * config.renderScale),
            target: new Vector3(0, 0 * config.renderScale, 0),
            orientation: {
              theta: 0,
              phi: 0.9616764178488756,
              radius: 122.2 * config.renderScale
            }
          };

          this.effect = {
            Antialias: true,
            FXAA: false,
            Bloom: false
          };

          this.control = {
            rotationLocked: this.storage['control.rotationLocked'] === '1' ? true : false
          };

          this.renderer = {
            Stats: this.storage['renderer.Stats'] === '1' ? true : false
          };

          this.route = {
            avoidHostile: false,
            avoidOffLimits: false,
            avoidUnknownJumppoints: false
          };

          // Clean up the mess we made in older versions

          this.removeOldSettings();

          // Load configs

          this.cameraDefaults = JSON.parse(JSON.stringify(this.camera));
          this.cameraDefaults.camera = new Vector3();
          this.cameraDefaults.camera.copy(this.camera.camera);
          this.cameraDefaults.target = new Vector3();
          this.cameraDefaults.target.copy(this.camera.target);

          this.load('camera');

          if (this.storage && 'route' in this.storage) {
            this.load('route');
          }

          this.load('systems');
          if (!this.systems) {
            this.systems = {};
          }
          this.save('systems');

          this.load('effect');
        }

        _createClass(Settings, [{
          key: 'load',
          value: function load(key) {
            if (key in this.storage) {
              try {
                this[key] = JSON.parse(this.storage[key]);
              } catch (e) {
                console.error('Error parsing \'localStorage.' + key + '\'; ' + e.name + ': ' + e.message);
              }
            }
          }
        }, {
          key: 'save',
          value: function save(key) {
            if (key in this) {
              this.storage[key] = JSON.stringify(this[key]);
            }
          }
        }, {
          key: 'removeOldSettings',
          value: function removeOldSettings() {
            if ('effect.Bloom' in this.storage) {
              delete this.storage['effect.Bloom'];
            }

            if ('effect.FXAA' in this.storage) {
              delete this.storage['effect.FXAA'];
            }

            for (var property in this.storage) {
              if (/^(comments|hangarLocation|bookmarks)[.](\d+)$/.test(property)) {
                delete this.storage[property];
              }

              if (/^(camera|target)[.](x|y|z)$/.test(property)) {
                delete this.storage[property];
              }
            }
          }
        }, {
          key: 'mode',
          get: function get() {
            return this.storage.mode === '2d' ? '2d' : '3d';
          },
          set: function set(value) {
            if (/^(2d|3d)$/.test(value)) {
              this.storage.mode = value;
            } else {
              this.storage.mode = '3d';
            }
          }
        }, {
          key: 'uiWidth',
          get: function get() {
            return Number(this.storage['settings.uiWidth']) > 0 ? Number(this.storage['settings.uiWidth']) : 320;
          },
          set: function set(value) {
            this.storage['settings.uiWidth'] = value;
          }
        }, {
          key: 'labelScale',
          get: function get() {
            var userScale = Number(this.storage['settings.labelScale']) > 0 ? Number(this.storage['settings.labelScale']) : Number(config.defaultLabelScale);
            return Math.max(Number(config.minLabelScale), Math.min(userScale, config.maxLabelScale));
          },
          set: function set(value) {
            this.storage['settings.labelScale'] = value;
          }
        }, {
          key: 'labelOffset',
          get: function get() {
            var userOffset = Number(this.storage['settings.labelOffset']) ? Number(this.storage['settings.labelOffset']) : Number(config.defaultLabelOffset);
            return Math.max(Number(config.minLabelOffset), Math.min(userOffset, config.maxLabelOffset));
          },
          set: function set(value) {
            this.storage['settings.labelOffset'] = value;
          }
        }, {
          key: 'systemScale',
          get: function get() {
            var userScale = Number(this.storage['settings.systemScale']) > 0 ? Number(this.storage['settings.systemScale']) : Number(config.defaultSystemScale);
            return Math.max(Number(config.minSystemScale), Math.min(userScale, config.maxSystemScale));
          },
          set: function set(value) {
            this.storage['settings.systemScale'] = value;
          }
        }, {
          key: 'glow',
          get: function get() {
            return this.storage['settings.Glow'] !== '0';
          },
          set: function set(value) {
            this.storage['settings.Glow'] = value ? '1' : '0';
          }
        }, {
          key: 'labels',
          get: function get() {
            return this.storage['settings.Labels'] !== '0';
          },
          set: function set(value) {
            this.storage['settings.Labels'] = value ? '1' : '0';
          }
        }, {
          key: 'labelIcons',
          get: function get() {
            return this.storage['settings.LabelIcons'] !== '0';
          },
          set: function set(value) {
            this.storage['settings.LabelIcons'] = value ? '1' : '0';
          }
        }, {
          key: 'usersFaction',
          get: function get() {
            return SCMAP.getFactionById('UEE');
          }
        }]);

        return Settings;
      })();

      _export('default', new Settings());
    }
  };
});
$__System.register('e', ['7', '8', '9', '84', '6b'], function (_export) {
  var settings, _createClass, _classCallCheck, jQuery, UI, oldRoute, RouteUI;

  return {
    setters: [function (_3) {
      settings = _3['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_4) {
      jQuery = _4['default'];
    }, function (_b) {
      UI = _b['default'];
    }],
    execute: function () {
      /**
        * @author Lianna Eeftinck / https://github.com/Leeft
        */

      'use strict';

      oldRoute = '';

      RouteUI = (function () {
        function RouteUI() {
          _classCallCheck(this, RouteUI);
        }

        _createClass(RouteUI, null, [{
          key: 'update',
          value: function update(route) {
            jQuery(UI.Tab('route').id).empty().append(UI.Templates.routeList({ route: RouteUI.templateData(route) }));

            if (oldRoute !== route.toString()) {
              oldRoute = route.toString();
              UI.toTab('route');
            }
          }
        }, {
          key: 'templateData',
          value: function templateData(route) {
            var waypoint = undefined;

            var entireRoute = route.currentRoute();

            var templateData = {
              settings: {
                avoidHostile: settings.route.avoidHostile,
                avoidUnknownJumppoints: settings.route.avoidUnknownJumppoints,
                avoidOffLimits: settings.route.avoidOffLimits
              }
            };

            if (!entireRoute.length) {
              if (route.start && route.waypoints.length) {
                templateData.status = {
                  text: 'No route available with your current settings.',
                  'class': 'impossible'
                };
              } else {
                templateData.status = {
                  text: 'No route set',
                  'class': 'no-route'
                };
              }
            } else {
              templateData.from = entireRoute[0].system;
              templateData.to = entireRoute[entireRoute.length - 1].system;
              templateData.waypoints = [];
              templateData.totalDuration = 0;

              for (var i = 0, entireRouteLength = entireRoute.length; i < entireRouteLength; i += 1) {
                var system = entireRoute[i].system;

                if (i > 0 && system.id === entireRoute[i - 1].system.id) {
                  // Duplicate waypoint, which means we jumped between routes, so update the last waypoint instead
                  waypoint = templateData.waypoints[templateData.waypoints.length - 1];
                  waypoint.iconClass = 'fa-times text-danger';
                  waypoint.iconTitle = 'Remove waypoint';
                  waypoint.rowClass = 'waypoint';
                  waypoint.action = '<a href="#" class="remove-waypoint" data-system="' + system.id + '">';
                  continue;
                }

                waypoint = {
                  rowClass: '',
                  index: templateData.waypoints.length + 1,
                  system: system,
                  iconClass: 'fa-long-arrow-down',
                  iconTitle: 'Jump Point',
                  duration: 30 * 60,
                  action: ''
                };

                if (i === 0) {

                  waypoint.duration = 30 * 60 / 2; // TODO
                  waypoint.rowClass = 'start';
                  waypoint.iconClass = 'fa-flag';
                  waypoint.iconTitle = 'Start';
                } else if (i === entireRoute.length - 1) {

                  waypoint.duration = 30 * 60 / 2; // TODO
                  waypoint.rowClass = 'end';
                  waypoint.iconClass = 'fa-flag-checkered';
                  waypoint.iconTitle = 'Destination';
                }

                templateData.waypoints.push(waypoint);
                templateData.totalDuration += waypoint.duration;
              }
            }

            return templateData;
          }
        }]);

        return RouteUI;
      })();

      _export('default', RouteUI);
    }
  };
});
$__System.register("7e", [], function (_export) {
  // Thanks to https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API
  "use strict";

  function toggleFullScreen() {
    if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
      // current working methods
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen();
      } else if (document.documentElement.msRequestFullscreen) {
        document.documentElement.msRequestFullscreen();
      } else if (document.documentElement.mozRequestFullScreen) {
        document.documentElement.mozRequestFullScreen();
      } else if (document.documentElement.webkitRequestFullscreen) {
        document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      }
    }
  }

  return {
    setters: [],
    execute: function () {
      _export("default", toggleFullScreen);
    }
  };
});
$__System.registerDynamic("85", ["40"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('40');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("86", ["85"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('85'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8", ["86"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$defineProperty = $__require('86')["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.register('87', ['8', '9'], function (_export) {
  var _createClass, _classCallCheck, MapSymbol;

  return {
    setters: [function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }],
    execute: function () {
      /**
      * @author LiannaEeftinck / https://github.com/Leeft
      */

      'use strict';

      MapSymbol = (function () {
        function MapSymbol() {
          _classCallCheck(this, MapSymbol);
        }

        _createClass(MapSymbol, [{
          key: 'getTag',
          value: function getTag(icon) {
            var $icon = $('<i title="' + icon.description + '" class="fa fa-fw ' + icon.cssClass + '"></i>');
            $icon.css('color', icon.color);
            return $icon;
          }
        }, {
          key: 'SIZE',
          get: function get() {
            return 24;
          }
        }, {
          key: 'SPACING',
          get: function get() {
            return 2;
          }
        }]);

        return MapSymbol;
      })();

      ;

      _export('default', new MapSymbol());
    }
  };
});
$__System.register('88', ['84', '87', '89', '6b', 'd'], function (_export) {
  /**
  * @author Lianna Eeftinck / https://github.com/Leeft
  */

  'use strict';

  var $, MapSymbol, markdown, UI, map;

  function createInfoLink(system, noSymbols, noTarget) {
    var $line = $('<a></a>');

    if (typeof system.faction !== 'undefined' && typeof system.faction !== 'undefined') {
      $line.css('color', system.faction.color.getStyle());
    }

    $line.addClass('system-link');
    $line.attr('data-goto', 'system');
    $line.attr('data-system', system.id);
    $line.attr('href', '#system=' + encodeURIComponent(system.name));
    $line.attr('title', 'Show information on ' + system.name);
    if (noTarget) {
      $line.text(system.name);
    } else {
      $line.html('<i class="fa fa-crosshairs"></i>&nbsp;' + system.name);
    }

    if (!noSymbols) {
      var symbols = system.getIcons();
      if (symbols.length) {
        var $span = $('<span class="icons"></span>');
        for (var i = 0; i < symbols.length; i++) {
          $span.append(MapSymbol.getTag(symbols[i]));
        }
        $line.append($span);
      }
    }

    return $line;
  }

  function displayInfo(system, doNotSwitch) {
    var previous = null;
    var next = null;
    var currentStep = map.route().indexOfCurrentRoute(system);

    if (typeof currentStep === 'number') {
      var currentRoute = map.route().currentRoute();

      if (currentStep > 0) {
        previous = currentRoute[currentStep - 1].system;
        if (currentStep > 1 && previous === currentRoute[currentStep].system) {
          previous = currentRoute[currentStep - 2].system;
        }
        previous = previous;
      }

      if (currentStep < currentRoute.length - 1) {
        next = currentRoute[currentStep + 1].system;
        if (currentStep < currentRoute.length - 2 && next === currentRoute[currentStep].system) {
          next = currentRoute[currentStep + 2].system;
        }
      }
    }

    var $element = $(UI.Tab('system').id).empty().append(UI.Templates.systemInfo({
      previous: previous,
      system: system,
      next: next
    }));

    // Set user's notes and bookmarks
    $element.find('.user-system-ishangar').prop('checked', system.hasHangar()).attr('data-system', system.id);
    $element.find('.user-system-bookmarked').prop('checked', system.isBookmarked()).attr('data-system', system.id);
    $element.find('.user-system-avoid').prop('checked', system.isToBeAvoided()).attr('data-system', system.id);

    if (system.hasComments()) {
      $element.find('.user-system-comments').empty().val(system.getComments());
      $element.find('.user-system-comments-md').html($(markdown.markdown.toHTML(system.getComments())));
    } else {
      $element.find('.user-system-comments').empty().val('');
      $element.find('.user-system-comments-md').empty();
    }

    if (!doNotSwitch) {
      UI.toTab('system');
    }
  }

  return {
    setters: [function (_2) {
      $ = _2['default'];
    }, function (_) {
      MapSymbol = _['default'];
    }, function (_3) {
      markdown = _3['default'];
    }, function (_b) {
      UI = _b['default'];
    }, function (_d) {
      map = _d.map;
    }],
    execute: function () {
      _export('displayInfo', displayInfo);

      _export('createInfoLink', createInfoLink);
    }
  };
});
$__System.register('8a', ['1', '5', '6', '84', '88', '89', '6a', '6b', '1e', '8b'], function (_export) {
  /**
    * @author Lianna Eeftinck / https://github.com/Leeft
    */

  'use strict';

  var SCMAP, hasSessionStorage, StarSystem, $, createInfoLink, markdown, Faction, UI, Color, Handlebars, sectionLevel, tabCounter, storage;
  return {
    setters: [function (_) {
      SCMAP = _['default'];
    }, function (_3) {
      hasSessionStorage = _3.hasSessionStorage;
    }, function (_2) {
      StarSystem = _2['default'];
    }, function (_6) {
      $ = _6['default'];
    }, function (_4) {
      createInfoLink = _4.createInfoLink;
    }, function (_5) {
      markdown = _5['default'];
    }, function (_a) {
      Faction = _a['default'];
    }, function (_b) {
      UI = _b['default'];
    }, function (_e) {
      Color = _e.Color;
    }, function (_b2) {
      Handlebars = _b2['default'];
    }],
    execute: function () {
      sectionLevel = 1;
      tabCounter = 0;
      storage = {};

      Handlebars.registerHelper('distanceLY', function (distance) {
        if (!distance) {
          return new Handlebars.SafeString('');
        }

        return new Handlebars.SafeString(distance.toFixed(1) + ' ly');
      });

      Handlebars.registerHelper('uiSection', function (title, shouldOpen, options) {
        var opened = shouldOpen ? true : false;
        var icon = 'fa-caret-right';
        var hidden = 'style="display: none;"';
        var attrs = [],
            str = undefined;
        var oldLevel = sectionLevel++;
        var safeTitle = 'panel' + title.replace(/[^\w]/g, '');

        if (hasSessionStorage()) {
          storage = window.sessionStorage;
        }

        if (typeof storage[safeTitle] === 'string') {
          opened = storage[safeTitle] === '1' ? true : false;
        }

        if (opened) {
          icon = 'fa-caret-down';
          hidden = '';
        }

        for (var prop in options.hash) {
          attrs.push(prop + '="' + options.hash[prop] + '"');
        }

        str = '<h' + oldLevel + '><a href="#" data-title="' + UI.htmlEscape(safeTitle) + '" data-toggle-next="next" ' + attrs.join(' ') + '><i class="fa fa-fw fa-lg ' + icon + '">' + '</i>' + title + '</a></h' + oldLevel + '>\n' + '         <div class="ui-section" ' + hidden + '>';

        if ('fn' in options) {
          str += options.fn(this);
        }

        str += '</div>';
        sectionLevel -= 1;
        return new Handlebars.SafeString(str);
      });

      Handlebars.registerHelper('tabHeader', function (title) {
        return new Handlebars.SafeString('<h1 class="padleft">' + title + '</h1>');
      });

      /* title: shown to user, name: internal name, icon: font awesome icon class */
      Handlebars.registerHelper('jQueryUiTab', function (title, name, icon, options) {
        var hidden = 'style="display: none;"';
        var attrs = [],
            str = '';
        var $menuItem = undefined;
        var id = 'sc-map-ui-tab-' + UI.makeSafeForCSS(name);

        //for ( let prop in options.hash ) {
        //   attrs.push( prop + '="' + options.hash[prop] + '"' );
        //}

        $menuItem = $('<li>' + '<a title="' + UI.htmlEscape(title) + '" data-tab="' + UI.htmlEscape(name) + '" href="#' + UI.htmlEscape(id) + '">' + '<i class="fa fa-fw fa-2x ' + UI.htmlEscape(icon) + '"></i>' + '</a>' + '</li>');

        UI.menuBar.push($menuItem);

        str = '<div id="' + id + '" class="sc-map-ui-tab" ' + (tabCounter !== 0 ? 'style="display: none"' : '') + '>';
        if ('fn' in options) {
          str += options.fn(this);
        }
        str += '</div>';

        UI.Tabs.push({ id: '#' + id, name: name, index: tabCounter++ });

        return new Handlebars.SafeString(str);
      });

      Handlebars.registerHelper('bigButton', function (id, cssClass, title) {
        return new Handlebars.SafeString('<button class="big-button" id="' + id + '"><i class="fa ' + cssClass + ' fa-fw fa-lg"></i>' + title + '</button><br>');
      });

      Handlebars.registerHelper('commoditiesList', function (commodities) {
        if (!commodities.length) {
          return new Handlebars.SafeString('&mdash;');
        }

        return new Handlebars.SafeString($.map(commodities, function (elem, i) {
          var commodity = SCMAP.getCommodityById(elem);
          return commodity ? commodity.name : '???';
        }).join(', '));
      });

      Handlebars.registerHelper('markdown', function (markdownText) {
        return new Handlebars.SafeString(markdown.markdown.toHTML(markdownText || ''));
      });

      Handlebars.registerHelper('colourGetStyle', function (colour) {
        return new Handlebars.SafeString(colour.getStyle());
      });

      Handlebars.registerHelper('systemLink', function (system, options) {
        var noIcons = false,
            noTarget = false;
        if ('noIcons' in options.hash) {
          noIcons = options.hash.noIcons ? true : false;
        }
        if ('noTarget' in options.hash) {
          noTarget = options.hash.noTarget ? true : false;
        }
        if (!(system instanceof StarSystem)) {
          return '';
        }
        return new Handlebars.SafeString(createInfoLink(system, noIcons, noTarget).outerHtml());
      });

      Handlebars.registerHelper('routeNavLinks', function (prev, next, options) {
        var str = '',
            $elem = undefined;

        if (!prev && !next) {
          return new Handlebars.SafeString('');
        }

        if (prev instanceof StarSystem) {
          $elem = $('<a></a>');
          if (prev.faction instanceof Faction && prev.faction.color instanceof Color) {
            $elem.css('color', prev.faction.color.getStyle());
          }
          $elem.addClass('system-link');
          $elem.attr('data-goto', 'system');
          $elem.attr('data-system', prev.id);
          $elem.attr('href', '#system=' + encodeURIComponent(prev.name));
          $elem.attr('title', 'Previous jump, coming from ' + prev.name + ' (' + prev.faction.name + ' territory)');
          $elem.empty().append('<i class="left fa fa-fw fa-arrow-left"></i>');
          str += $elem.outerHtml();
        } else {
          str += '<i class="left fa fa-fw"></i>';
        }

        if (next instanceof StarSystem) {
          $elem = $('<a></a>');
          if (next.faction instanceof Faction && next.faction.color instanceof Color) {
            $elem.css('color', next.faction.color.getStyle());
          }
          $elem.addClass('system-link');
          $elem.attr('data-goto', 'system');
          $elem.attr('data-system', next.id);
          $elem.attr('href', '#system=' + encodeURIComponent(next.name));
          $elem.attr('title', 'Next jump, leading to ' + next.name + ' (' + next.faction.name + ' territory)');
          $elem.empty().append('<i class="right fa fa-fw fa-arrow-right"></i>');
          str += $elem.outerHtml();
        } else {
          str += '<i class="right fa fa-fw"></i>';
        }

        return new Handlebars.SafeString(str);
      });

      Handlebars.registerHelper('checkboxButton', function (id, title, options) {
        var attrs = [];
        for (var prop in options.hash) {
          if (prop === 'icon') {
            title = title + ' <i class="fa fa-lg fa-fw ' + options.hash[prop] + '"></i>';
          } else {
            attrs.push(prop + '="' + UI.htmlEscape(options.hash[prop]) + '"');
          }
        }
        return new Handlebars.SafeString('<span class="checkmark-button">' + '<input type="checkbox" id="' + id + '" ' + attrs.join(' ') + '>' + '<label for="' + id + '">' + title + '</label>' + '</span>');
      });

      Handlebars.registerHelper('debug', function (optionalValue) {
        console.log('Current Context', this);

        if (optionalValue) {
          console.log('Value', optionalValue);
        }
      });

      Handlebars.registerHelper('durationHMM', function (duration) {
        if (!duration) {
          return new Handlebars.SafeString('');
        }

        var sec_num = parseInt(duration, 10);
        var hours = Math.floor(sec_num / 3600);

        var minutes = Math.floor((sec_num - hours * 3600) / 60);

        if (minutes < 10) {
          minutes = '0' + minutes;
        }

        return new Handlebars.SafeString(hours + ':' + minutes);
      });

      Handlebars.registerHelper('plusOne', function (number) {
        return new Handlebars.SafeString(number + 1);
      });

      Handlebars.registerHelper('minusOne', function (number) {
        return new Handlebars.SafeString(number - 1);
      });

      Handlebars.registerHelper('checked', function (isChecked) {
        return new Handlebars.SafeString(isChecked ? 'checked' : '');
      });

      Handlebars.registerHelper('checkboxOption', function (id, defaultChecked, title, description, options) {
        var attrs = [];
        var checked = '';

        if (defaultChecked) {
          checked = 'checked';
        }

        for (var prop in options.hash) {
          if (prop === 'icon') {
            title = title + ' <i class="fa fa-lg fa-fw ' + options.hash[prop] + '\'"></i>';
          } else {
            attrs.push(prop + '="' + UI.htmlEscape(options.hash[prop]) + '"');
          }
        }

        return new Handlebars.SafeString('<span class="checkmark-option">' + '<input class="' + id + '" type="checkbox" id="' + id + '" ' + checked + '>' + '<label for="' + id + '">' + title + '<span class="small label-info">' + description + '</span>' + '</label>' + '</span>');
      });
    }
  };
});
$__System.registerDynamic("8c", ["8b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8b').template({
    "compiler": [7, ">= 4.0.0"],
    "main": function(container, depth0, helpers, partials, data) {
      return container.escapeExpression((helpers.tabHeader || (depth0 && depth0.tabHeader) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "About this map", {
        "name": "tabHeader",
        "hash": {},
        "data": data
      })) + "\n\n<p class=\"ui-section\">\n  A 3D (and 2D) interactive galaxy map of the space sim adventure game <a href=\"https://robertsspaceindustries.com/about-the-game\" target=\"_blank\">Star Citizen</a> (currently being developed).\n</p>\n\n<p class=\"ui-section\">\n  Created by <a href=\"https://forums.robertsspaceindustries.com/profile/51803/Shiari\" title=\"My profile on the Roberts Space Industries forums\" target=\"_blank\">Daughter of Sol</a> (@Shiari on the RSI forums) using <a href=\"http://get.webgl.org/\">WebGL</a> and is announced and discussed in <a href=\"https://forums.robertsspaceindustries.com/discussion/54931/browser-based-3d-system-map-wip\" target=\"_blank\">my forum thread</a>.\n</p>\n\n<p class=\"ui-section\">\n  Map data was originally kindly provided for use by me by <a href=\"https://forums.robertsspaceindustries.com/profile/149083/Zuur\" target=\"_blank\">Zuur</a>, see <a href=\"http://mobiglas.com/StarMap/\" target=\"_blank\">the MobiGlas Star Map</a> for his original map. It's now also updated with some of the data from the <a href=\"https://robertsspaceindustries.com/starmap\" target=\"ark-map\">ARK star map</a>.\n</p>\n\n<p class=\"ui-section\">\n  The sourcecode which drives this map is available under the MIT license on its <a href=\"https://github.com/Leeft/Star-Citizen-WebGL-Map\" target=\"_blank\">GitHub project page</a>.\n</p>\n";
    },
    "useData": true
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8d", ["8b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8b').template({
    "compiler": [7, ">= 4.0.0"],
    "main": function(container, depth0, helpers, partials, data) {
      return container.escapeExpression((helpers.tabHeader || (depth0 && depth0.tabHeader) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Debug information", {
        "name": "tabHeader",
        "hash": {},
        "data": data
      })) + "\n\n<p class=\"ui-section\">\n  " + container.escapeExpression((helpers.checkboxButton || (depth0 && depth0.checkboxButton) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-toggle-stats", "Framerate statistics", {
        "name": "checkboxButton",
        "hash": {},
        "data": data
      })) + "\n</p>\n\n<div class=\"sc-map-debug ui-section\">\n  <p id=\"debug-systems\"></p>\n  <p id=\"debug-state\"></p>\n  <p id=\"debug-camera-is-moving\"></p>\n  <p id=\"debug-angle\" class=\"hide\"></p>\n  <p id=\"debug-target\"></p>\n  <p id=\"debug-axis\" class=\"hide\"></p>\n  <div id=\"debug-renderer\" class=\"hide\">\n    <p>Render:</p>\n    <dl class=\"medium\">\n      <dt class=\"calls\">Calls</dt>\n      <dd class=\"calls\">&mdash;</dd>\n      <dt class=\"faces\">Faces</dt>\n      <dd class=\"faces\">&mdash;</dd>\n      <dt class=\"points\">Points</dt>\n      <dd class=\"points\">&mdash;</dd>\n      <dt class=\"vertices\">Vertices</dt>\n      <dd class=\"vertices\">&mdash;</dd>\n    </dl>\n\n    <p>Memory:</p>\n    <dl class=\"medium\">\n      <dt class=\"geometries\">Geometries</dt>\n      <dd class=\"geometries\">&mdash;</dd>\n      <dt class=\"textures\">Textures</dt>\n      <dd class=\"textures\">&mdash;</dd>\n    </dl>\n  </div>\n  <p id=\"debug-canvases\"></p>\n</div>\n";
    },
    "useData": true
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8e", ["8b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8b').template({
    "1": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "  <ul class=\"fa-ul bullet-list-med legend\">\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.icons : depth0), {
        "name": "each",
        "hash": {},
        "fn": container.program(2, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "  </ul>\n";
    },
    "2": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "      <li>" + ((stack1 = container.lambda(depth0, depth0)) != null ? stack1 : "") + "</li>\n";
    },
    "compiler": [7, ">= 4.0.0"],
    "main": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Icon legend", 0, {
        "name": "uiSection",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "");
    },
    "useData": true
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8f", ["8b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8b').template({
    "1": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "  <ul class=\"fa-ul bullet-list-med\">\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.instructions : depth0), {
        "name": "each",
        "hash": {},
        "fn": container.program(2, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "  </ul>\n";
    },
    "2": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "      <li><i class=\"fa fa-li fa-circle-thin\"></i>" + ((stack1 = container.lambda(depth0, depth0)) != null ? stack1 : "") + "</li>\n";
    },
    "compiler": [7, ">= 4.0.0"],
    "main": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Instructions", 0, {
        "name": "uiSection",
        "hash": {"class": "no-pad-top"},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "");
    },
    "useData": true
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("90", ["8b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8b').template({
    "1": function(container, depth0, helpers, partials, data) {
      return "  <p>\n    " + container.escapeExpression((helpers.bigButton || (depth0 && depth0.bigButton) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-resetCamera", "fa-camera", "Reset view", {
        "name": "bigButton",
        "hash": {},
        "data": data
      })) + "\n    " + container.escapeExpression((helpers.bigButton || (depth0 && depth0.bigButton) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-centreCamera", "fa-home", "Centre view [C]", {
        "name": "bigButton",
        "hash": {},
        "data": data
      })) + "\n    " + container.escapeExpression((helpers.bigButton || (depth0 && depth0.bigButton) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-northCamera", "fa-compass", "Reset orientation [R]", {
        "name": "bigButton",
        "hash": {},
        "data": data
      })) + "\n    " + container.escapeExpression((helpers.bigButton || (depth0 && depth0.bigButton) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-topCamera", "fa-camera-retro", "Top-down view [T]", {
        "name": "bigButton",
        "hash": {},
        "data": data
      })) + "\n    " + container.escapeExpression((helpers.bigButton || (depth0 && depth0.bigButton) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-top2D", "fa-map-marker", "2D map mode [2]", {
        "name": "bigButton",
        "hash": {},
        "data": data
      })) + "\n    " + container.escapeExpression((helpers.bigButton || (depth0 && depth0.bigButton) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-toggleFullScreen", "fa-arrows-alt", "Toggle full screen mode", {
        "name": "bigButton",
        "hash": {},
        "data": data
      })) + "\n    <br>\n    " + container.escapeExpression((helpers.checkboxButton || (depth0 && depth0.checkboxButton) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-3d-mode", "3D map mode [3]", {
        "name": "checkboxButton",
        "hash": {},
        "data": data
      })) + "\n    " + container.escapeExpression((helpers.checkboxButton || (depth0 && depth0.checkboxButton) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-lock-rotation", "Lock map rotation [L]", {
        "name": "checkboxButton",
        "hash": {},
        "data": data
      })) + "\n  </p>\n";
    },
    "compiler": [7, ">= 4.0.0"],
    "main": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Quick functions", 1, {
        "name": "uiSection",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "");
    },
    "useData": true
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("91", ["8b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8b').template({
    "compiler": [7, ">= 4.0.0"],
    "main": function(container, depth0, helpers, partials, data) {
      var stack1;
      return container.escapeExpression((helpers.tabHeader || (depth0 && depth0.tabHeader) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Settings", {
        "name": "tabHeader",
        "hash": {},
        "data": data
      })) + "\n\n<p class=\"ui-section\">\n  " + container.escapeExpression((helpers.checkboxOption || (depth0 && depth0.checkboxOption) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-toggle-antialias", ((stack1 = ((stack1 = (depth0 != null ? depth0.settings : depth0)) != null ? stack1.effect : stack1)) != null ? stack1.Antialias : stack1), "Enable antialiasing", "Disable postprocessing; forces reload.<br>Note: antialiasing does not work everywhere.", {
        "name": "checkboxOption",
        "hash": {},
        "data": data
      })) + "\n  " + container.escapeExpression((helpers.checkboxOption || (depth0 && depth0.checkboxOption) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-toggle-fxaa", ((stack1 = ((stack1 = (depth0 != null ? depth0.settings : depth0)) != null ? stack1.effect : stack1)) != null ? stack1.FXAA : stack1), "Postprocess: FXAA", "", {
        "name": "checkboxOption",
        "hash": {},
        "data": data
      })) + "\n  " + container.escapeExpression((helpers.checkboxOption || (depth0 && depth0.checkboxOption) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-toggle-bloom", ((stack1 = ((stack1 = (depth0 != null ? depth0.settings : depth0)) != null ? stack1.effect : stack1)) != null ? stack1.Bloom : stack1), "Postprocess: Bloom", "", {
        "name": "checkboxOption",
        "hash": {},
        "data": data
      })) + "\n\n  <p class=\"ui-section-width\">\n    <span class=\"slider-option\">\n      <label for=\"sc-map-slider-system-size\">System size:</label>\n      <div id=\"sc-map-slider-system-size\" class=\"sc-map-slider-system-size\"></div>\n    </span>\n  </p>\n\n  <p class=\"ui-section-width\">\n    <span class=\"slider-option\">\n      <label for=\"sc-map-slider-label-size\">Label size:</label>\n      <div id=\"sc-map-slider-label-size\" class=\"sc-map-slider-label-size\"></div>\n    </span>\n  </p>\n\n  <p class=\"ui-section-width\">\n    <span class=\"slider-option\">\n      <label for=\"sc-map-slider-label-offset\">Label offset:</label>\n      <div id=\"sc-map-slider-label-offset\" class=\"sc-map-slider-label-offset\"></div>\n    </span>\n  </p>\n</p>\n\n<p class=\"ui-section\">\n  " + container.escapeExpression((helpers.checkboxOption || (depth0 && depth0.checkboxOption) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-toggle-glow", ((stack1 = (depth0 != null ? depth0.settings : depth0)) != null ? stack1.glow : stack1), "Enable star glow", "", {
        "name": "checkboxOption",
        "hash": {},
        "data": data
      })) + "\n  <span class=\"checkmark-option\">\n    <input type=\"checkbox\" id=\"sc-map-toggle-labels\" " + container.escapeExpression((helpers.checked || (depth0 && depth0.checked) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, ((stack1 = (depth0 != null ? depth0.settings : depth0)) != null ? stack1.labels : stack1), {
        "name": "checked",
        "hash": {},
        "data": data
      })) + ">\n    <label for=\"sc-map-toggle-labels\">Enable system labels</label>\n    <input type=\"checkbox\" id=\"sc-map-toggle-label-icons\"  " + container.escapeExpression((helpers.checked || (depth0 && depth0.checked) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, ((stack1 = (depth0 != null ? depth0.settings : depth0)) != null ? stack1.labelIcons : stack1), {
        "name": "checked",
        "hash": {},
        "data": data
      })) + ">\n    <label for=\"sc-map-toggle-label-icons\"><i class=\"fa fa-level-up fa-rotate-90 fa-fw\"></i> Display icons in system labels</label>\n  </span>\n</p>\n\n<p class=\"ui-section\">\n  <span class=\"slider-option\">\n    <label for=\"sc-map-slider-uiwidth\">UI width:</label>\n    <div id=\"sc-map-slider-uiwidth\" class=\"sc-map-slider-uiwidth\"></div>\n  </span>\n</p>\n";
    },
    "useData": true
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("92", ["8b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8b').template({
    "1": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "  <dl class=\"shortcuts\">\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.shortcuts : depth0), {
        "name": "each",
        "hash": {},
        "fn": container.program(2, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "  </dl>\n";
    },
    "2": function(container, depth0, helpers, partials, data) {
      var stack1,
          helper;
      return "      <dt>" + ((stack1 = ((helper = (helper = helpers.key || (depth0 != null ? depth0.key : depth0)) != null ? helper : helpers.helperMissing), (typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {}, {
        "name": "key",
        "hash": {},
        "data": data
      }) : helper))) != null ? stack1 : "") + "</dt>\n      <dd>" + ((stack1 = ((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helpers.helperMissing), (typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {}, {
        "name": "description",
        "hash": {},
        "data": data
      }) : helper))) != null ? stack1 : "") + "</dd>\n";
    },
    "compiler": [7, ">= 4.0.0"],
    "main": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Keyboard shortcuts", 0, {
        "name": "uiSection",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "");
    },
    "useData": true
  });
  global.define = __define;
  return module.exports;
});

$__System.register('93', ['90', '91', '92', '94', '95', '96', '8b', '8c', '8d', '8e', '8f'], function (_export) {
  /**
    * @author Lianna Eeftinck / https://github.com/Leeft
    */

  'use strict';

  var partialQuickFunctions, partialSettings, partialShortcuts, partialRouteList, partialSystemInfo, partialSystemsListing, Handlebars, partialAbout, partialDebugInformation, partialIconLegend, partialInstructions;
  return {
    setters: [function (_) {
      partialQuickFunctions = _['default'];
    }, function (_3) {
      partialSettings = _3['default'];
    }, function (_4) {
      partialShortcuts = _4['default'];
    }, function (_2) {
      partialRouteList = _2['default'];
    }, function (_5) {
      partialSystemInfo = _5['default'];
    }, function (_6) {
      partialSystemsListing = _6['default'];
    }, function (_b) {
      Handlebars = _b['default'];
    }, function (_c) {
      partialAbout = _c['default'];
    }, function (_d) {
      partialDebugInformation = _d['default'];
    }, function (_e) {
      partialIconLegend = _e['default'];
    }, function (_f) {
      partialInstructions = _f['default'];
    }],
    execute: function () {

      Handlebars.registerPartial('templateAbout', partialAbout);
      Handlebars.registerPartial('templateDebugInformation', partialDebugInformation);
      Handlebars.registerPartial('templateMainIconLegend', partialIconLegend);
      Handlebars.registerPartial('templateMainInstructions', partialInstructions);
      Handlebars.registerPartial('templateMainQuickFunctions', partialQuickFunctions);
      Handlebars.registerPartial('templateRouteList', partialRouteList);
      Handlebars.registerPartial('templateSettings', partialSettings);
      Handlebars.registerPartial('templateMainShortcuts', partialShortcuts);
      Handlebars.registerPartial('templateSystemInfo', partialSystemInfo);
      Handlebars.registerPartial('templateSystemsListing', partialSystemsListing);
    }
  };
});
$__System.registerDynamic("97", ["8b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8b').template({
    "1": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = container.invokePartial(partials.templateMainInstructions, depth0, {
        "name": "templateMainInstructions",
        "data": data,
        "indent": "    ",
        "helpers": helpers,
        "partials": partials,
        "decorators": container.decorators
      })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials.templateMainShortcuts, depth0, {
        "name": "templateMainShortcuts",
        "data": data,
        "indent": "    ",
        "helpers": helpers,
        "partials": partials,
        "decorators": container.decorators
      })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials.templateMainIconLegend, depth0, {
        "name": "templateMainIconLegend",
        "data": data,
        "indent": "    ",
        "helpers": helpers,
        "partials": partials,
        "decorators": container.decorators
      })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials.templateMainQuickFunctions, depth0, {
        "name": "templateMainQuickFunctions",
        "data": data,
        "indent": "    ",
        "helpers": helpers,
        "partials": partials,
        "decorators": container.decorators
      })) != null ? stack1 : "");
    },
    "3": function(container, depth0, helpers, partials, data) {
      return "";
    },
    "5": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = container.invokePartial(partials.templateSystemInfo, depth0, {
        "name": "templateSystemInfo",
        "data": data,
        "indent": "    ",
        "helpers": helpers,
        "partials": partials,
        "decorators": container.decorators
      })) != null ? stack1 : "");
    },
    "7": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = container.invokePartial(partials.templateRouteList, depth0, {
        "name": "templateRouteList",
        "data": data,
        "indent": "    ",
        "helpers": helpers,
        "partials": partials,
        "decorators": container.decorators
      })) != null ? stack1 : "");
    },
    "9": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = container.invokePartial(partials.templateSettings, depth0, {
        "name": "templateSettings",
        "data": data,
        "indent": "    ",
        "helpers": helpers,
        "partials": partials,
        "decorators": container.decorators
      })) != null ? stack1 : "");
    },
    "11": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = container.invokePartial(partials.templateDebugInformation, depth0, {
        "name": "templateDebugInformation",
        "data": data,
        "indent": "    ",
        "helpers": helpers,
        "partials": partials,
        "decorators": container.decorators
      })) != null ? stack1 : "");
    },
    "13": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = container.invokePartial(partials.templateAbout, depth0, {
        "name": "templateAbout",
        "data": data,
        "indent": "    ",
        "helpers": helpers,
        "partials": partials,
        "decorators": container.decorators
      })) != null ? stack1 : "");
    },
    "compiler": [7, ">= 4.0.0"],
    "main": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "<div class=\"sc-map-ui-padding\">\n  <ul class=\"menubar\"></ul>\n\n" + ((stack1 = (helpers.jQueryUiTab || (depth0 && depth0.jQueryUiTab) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Usage", "usage", "fa-home", {
        "name": "jQueryUiTab",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "\n" + ((stack1 = (helpers.jQueryUiTab || (depth0 && depth0.jQueryUiTab) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Systems", "systems", "fa-list", {
        "name": "jQueryUiTab",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "\n" + ((stack1 = (helpers.jQueryUiTab || (depth0 && depth0.jQueryUiTab) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Selected system information", "system", "fa-info-circle", {
        "name": "jQueryUiTab",
        "hash": {},
        "fn": container.program(5, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "\n" + ((stack1 = (helpers.jQueryUiTab || (depth0 && depth0.jQueryUiTab) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Plan a route", "route", "fa-paper-plane", {
        "name": "jQueryUiTab",
        "hash": {},
        "fn": container.program(7, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "\n" + ((stack1 = (helpers.jQueryUiTab || (depth0 && depth0.jQueryUiTab) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Settings", "settings", "fa-wrench", {
        "name": "jQueryUiTab",
        "hash": {},
        "fn": container.program(9, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "\n" + ((stack1 = (helpers.jQueryUiTab || (depth0 && depth0.jQueryUiTab) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Debug information", "debug", "fa-bug", {
        "name": "jQueryUiTab",
        "hash": {},
        "fn": container.program(11, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "\n" + ((stack1 = (helpers.jQueryUiTab || (depth0 && depth0.jQueryUiTab) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "About this map", "about", "fa-comment", {
        "name": "jQueryUiTab",
        "hash": {},
        "fn": container.program(13, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "</div>\n";
    },
    "usePartial": true,
    "useData": true
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("95", ["8b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8b').template({
    "1": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "  <h1 class=\"systemname " + ((stack1 = helpers.unless.call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.previous : depth0), {
        "name": "unless",
        "hash": {},
        "fn": container.program(2, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "\" style=\"color: " + container.escapeExpression((helpers.colourGetStyle || (depth0 && depth0.colourGetStyle) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, ((stack1 = ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.faction : stack1)) != null ? stack1.color : stack1), {
        "name": "colourGetStyle",
        "hash": {},
        "data": data
      })) + "\">\n    " + container.escapeExpression((helpers.routeNavLinks || (depth0 && depth0.routeNavLinks) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.previous : depth0), (depth0 != null ? depth0.next : depth0), {
        "name": "routeNavLinks",
        "hash": {},
        "data": data
      })) + "\n    " + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.name : stack1), depth0)) + "\n  </h1>\n\n" + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {}, ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.nickname : stack1), {
        "name": "if",
        "hash": {},
        "fn": container.program(5, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "\n  <article>\n" + ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Basic info", 1, {
        "name": "uiSection",
        "hash": {},
        "fn": container.program(7, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "  </article>\n\n  <article>\n" + ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Jump points", 1, {
        "name": "uiSection",
        "hash": {},
        "fn": container.program(9, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "  </article>\n\n  <article>\n" + ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Comments and settings", 0, {
        "name": "uiSection",
        "hash": {},
        "fn": container.program(12, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "  </article>\n\n" + ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Description", 1, {
        "name": "uiSection",
        "hash": {},
        "fn": container.program(15, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {}, ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.info : stack1), {
        "name": "each",
        "hash": {},
        "fn": container.program(17, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "\n";
    },
    "2": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = helpers.unless.call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.next : depth0), {
        "name": "unless",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "");
    },
    "3": function(container, depth0, helpers, partials, data) {
      return "padleft";
    },
    "5": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "    <h2 class=\"nickname quote padleft\" style=\"color: " + container.escapeExpression((helpers.colourGetStyle || (depth0 && depth0.colourGetStyle) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, ((stack1 = ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.faction : stack1)) != null ? stack1.color : stack1), {
        "name": "colourGetStyle",
        "hash": {},
        "data": data
      })) + "\">" + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.nickname : stack1), depth0)) + "</h2>\n";
    },
    "7": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "      <dl class=\"wide basic-system\">\n        <dt class=\"faction\">Faction</dt>\n        <dd class=\"faction\">" + container.escapeExpression(container.lambda(((stack1 = ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.faction : stack1)) != null ? stack1.name : stack1), depth0)) + "</dd>\n\n        <!-- <dt class=\"planets\">Planets</dt>\n        <dd class=\"planets\">TODO</dd> -->\n\n        <!-- <dt class=\"rotation\">Planetary rotation</dt>\n        <dd class=\"rotation\">TODO</dd> -->\n\n        <dt class=\"import\">Import</dt>\n        <dd class=\"import\">" + ((stack1 = (helpers.commoditiesList || (depth0 && depth0.commoditiesList) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1["import"] : stack1), {
        "name": "commoditiesList",
        "hash": {},
        "data": data
      })) != null ? stack1 : "") + "</dd>\n\n        <dt class=\"export\">Export</dt>\n        <dd class=\"export\">" + ((stack1 = (helpers.commoditiesList || (depth0 && depth0.commoditiesList) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1["export"] : stack1), {
        "name": "commoditiesList",
        "hash": {},
        "data": data
      })) != null ? stack1 : "") + "</dd>\n\n        <dt class=\"blackMarket\">Black market</dt>\n        <dd class=\"blackMarket\">" + ((stack1 = (helpers.commoditiesList || (depth0 && depth0.commoditiesList) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.blackMarket : stack1), {
        "name": "commoditiesList",
        "hash": {},
        "data": data
      })) != null ? stack1 : "") + "</dd>\n\n\n        <dt class=\"crime\">Crime status</dt>\n        <dd class=\"crime crime_" + container.escapeExpression(container.lambda(((stack1 = ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.crimeStatus : stack1)) != null ? stack1.name : stack1), depth0)) + "\">" + container.escapeExpression(container.lambda(((stack1 = ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.crimeStatus : stack1)) != null ? stack1.name : stack1), depth0)) + "</dd>\n\n        <dt class=\"strategic\">UEE strategic value</dt>\n        <dd class=\"strategic strategic_value_" + container.escapeExpression(container.lambda(((stack1 = ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.ueeStrategicValue : stack1)) != null ? stack1.color : stack1), depth0)) + "\">" + container.escapeExpression(container.lambda(((stack1 = ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.ueeStrategicValue : stack1)) != null ? stack1.color : stack1), depth0)) + "</dd>\n\n      </dl>\n";
    },
    "9": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "      <table class=\"jumps\">\n        <tbody>\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {}, ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.jumpPoints : stack1), {
        "name": "each",
        "hash": {},
        "fn": container.program(10, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "        </tbody>\n      </table>\n";
    },
    "10": function(container, depth0, helpers, partials, data) {
      return "          <tr>\n            <th class=\"system\">" + container.escapeExpression((helpers.systemLink || (depth0 && depth0.systemLink) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.destination : depth0), {
        "name": "systemLink",
        "hash": {
          "noTarget": 1,
          "noIcons": 1
        },
        "data": data
      })) + "</th>\n            <td class=\"size\">" + container.escapeExpression(container.lambda((depth0 != null ? depth0.size : depth0), depth0)) + "</td>\n            <td class=\"distance\">" + container.escapeExpression((helpers.distanceLY || (depth0 && depth0.distanceLY) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.distanceInLY : depth0), {
        "name": "distanceLY",
        "hash": {},
        "data": data
      })) + "</td>\n          </tr>\n";
    },
    "12": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "\n      " + container.escapeExpression((helpers.checkboxButton || (depth0 && depth0.checkboxButton) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-hangar-location", "My hangar location", {
        "name": "checkboxButton",
        "hash": {
          "data-system": ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.id : stack1),
          "class": "user-system-ishangar",
          "icon": "fa-home"
        },
        "data": data
      })) + "\n      " + container.escapeExpression((helpers.checkboxButton || (depth0 && depth0.checkboxButton) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-bookmark", "Bookmarked", {
        "name": "checkboxButton",
        "hash": {
          "data-system": ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.id : stack1),
          "class": "user-system-bookmarked",
          "icon": "fa-bookmark"
        },
        "data": data
      })) + "\n      " + container.escapeExpression((helpers.checkboxButton || (depth0 && depth0.checkboxButton) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-avoid-system", "Avoid: don't route here", {
        "name": "checkboxButton",
        "hash": {
          "data-system": ((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.id : stack1),
          "class": "user-system-avoid",
          "icon": "fa-times"
        },
        "data": data
      })) + "\n\n      <div class=\"comment-editing\">\n" + ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Edit your comments", 0, {
        "name": "uiSection",
        "hash": {"class": "user ui-section"},
        "fn": container.program(13, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "\n        <p class=\"ui-section user-system-comments-md\"></p>\n      </div>\n\n";
    },
    "13": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "          <div class=\"user wide\">\n            <label for=\"user-comments-" + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.id : stack1), depth0)) + "\">Your comments (<a href=\"https://daringfireball.net/projects/markdown/basics\" target=\"_new\">markdown syntax</a>):\n            </label><a href=\"#\" class=\"remove-system-comments\" title=\"Remove\" data-system=\"" + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.id : stack1), depth0)) + "\" class=\"pull-right text-danger\"><i class=\"fa fa-fw fa-lg fa-times\"></i></a>\n            <textarea id=\"user-comments-" + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.id : stack1), depth0)) + "\" data-system=\"" + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.id : stack1), depth0)) + "\" class=\"user-system-comments\"></textarea>\n          </div>\n";
    },
    "15": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "    <div class=\"system-description\">\n      " + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.system : depth0)) != null ? stack1.description : stack1), depth0)) + "\n    </div>\n";
    },
    "17": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "    <article>\n" + ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Background info", 1, {
        "name": "uiSection",
        "hash": {},
        "fn": container.program(18, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "    </article>\n";
    },
    "18": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "        <div class=\"system-blurb-body\" data-source=\"" + container.escapeExpression(container.lambda((depth0 != null ? depth0.source : depth0), depth0)) + "\">\n          " + container.escapeExpression((helpers.markdown || (depth0 && depth0.markdown) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.article : depth0), {
        "name": "markdown",
        "hash": {},
        "data": data
      })) + "\n        </div>\n" + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.source : depth0), {
        "name": "if",
        "hash": {},
        "fn": container.program(19, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "");
    },
    "19": function(container, depth0, helpers, partials, data) {
      return "          <p class=\"system-blurb-source\"><a href=\"" + container.escapeExpression(container.lambda((depth0 != null ? depth0.source : depth0), depth0)) + "\" target=\"_new\">(source)</a></p>\n";
    },
    "21": function(container, depth0, helpers, partials, data) {
      return "\n  <div>\n    <p class=\"padleft impossible large ui-section\">No system selected</p>\n  </div>\n\n";
    },
    "compiler": [7, ">= 4.0.0"],
    "main": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.system : depth0), {
        "name": "if",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.program(21, data, 0),
        "data": data
      })) != null ? stack1 : "");
    },
    "useData": true
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("96", ["8b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8b').template({
    "1": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.items : depth0), {
        "name": "if",
        "hash": {},
        "fn": container.program(2, data, 0),
        "inverse": container.program(6, data, 0),
        "data": data
      })) != null ? stack1 : "");
    },
    "2": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.title : depth0), 0, {
        "name": "uiSection",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "");
    },
    "3": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "    <ul class=\"nostyle\">\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.items : depth0), {
        "name": "each",
        "hash": {},
        "fn": container.program(4, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "    </ul>\n";
    },
    "4": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "        <li>" + ((stack1 = container.lambda(depth0, depth0)) != null ? stack1 : "") + "</li>\n";
    },
    "6": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.title : depth0), 0, {
        "name": "uiSection",
        "hash": {},
        "fn": container.program(7, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "");
    },
    "7": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.factions : depth0), {
        "name": "each",
        "hash": {},
        "fn": container.program(8, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "");
    },
    "8": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.faction : depth0), 0, {
        "name": "uiSection",
        "hash": {},
        "fn": container.program(9, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "");
    },
    "9": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "      <ul class=\"nostyle\">\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.items : depth0), {
        "name": "each",
        "hash": {},
        "fn": container.program(10, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "      </ul>\n";
    },
    "10": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "          <li>" + ((stack1 = container.lambda(depth0, depth0)) != null ? stack1 : "") + "</li>\n";
    },
    "compiler": [7, ">= 4.0.0"],
    "main": function(container, depth0, helpers, partials, data) {
      var stack1;
      return container.escapeExpression((helpers.tabHeader || (depth0 && depth0.tabHeader) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Systems", {
        "name": "tabHeader",
        "hash": {},
        "data": data
      })) + "\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.systemGroups : depth0), {
        "name": "each",
        "hash": {},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "");
    },
    "useData": true
  });
  global.define = __define;
  return module.exports;
});

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
"format amd";
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd)
    define("8b", [], factory);
  else if (typeof exports === 'object')
    exports["Handlebars"] = factory();
  else
    root["Handlebars"] = factory();
})(this, function() {
  return (function(modules) {
    var installedModules = {};
    function __webpack_require__(moduleId) {
      if (installedModules[moduleId])
        return installedModules[moduleId].exports;
      var module = installedModules[moduleId] = {
        exports: {},
        id: moduleId,
        loaded: false
      };
      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
      module.loaded = true;
      return module.exports;
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.p = "";
    return __webpack_require__(0);
  })([function(module, exports, __webpack_require__) {
    'use strict';
    var _interopRequireWildcard = __webpack_require__(1)['default'];
    var _interopRequireDefault = __webpack_require__(2)['default'];
    exports.__esModule = true;
    var _handlebarsBase = __webpack_require__(3);
    var base = _interopRequireWildcard(_handlebarsBase);
    var _handlebarsSafeString = __webpack_require__(17);
    var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
    var _handlebarsException = __webpack_require__(5);
    var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
    var _handlebarsUtils = __webpack_require__(4);
    var Utils = _interopRequireWildcard(_handlebarsUtils);
    var _handlebarsRuntime = __webpack_require__(18);
    var runtime = _interopRequireWildcard(_handlebarsRuntime);
    var _handlebarsNoConflict = __webpack_require__(19);
    var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
    function create() {
      var hb = new base.HandlebarsEnvironment();
      Utils.extend(hb, base);
      hb.SafeString = _handlebarsSafeString2['default'];
      hb.Exception = _handlebarsException2['default'];
      hb.Utils = Utils;
      hb.escapeExpression = Utils.escapeExpression;
      hb.VM = runtime;
      hb.template = function(spec) {
        return runtime.template(spec, hb);
      };
      return hb;
    }
    var inst = create();
    inst.create = create;
    _handlebarsNoConflict2['default'](inst);
    inst['default'] = inst;
    exports['default'] = inst;
    module.exports = exports['default'];
  }, function(module, exports) {
    "use strict";
    exports["default"] = function(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    };
    exports.__esModule = true;
  }, function(module, exports) {
    "use strict";
    exports["default"] = function(obj) {
      return obj && obj.__esModule ? obj : {"default": obj};
    };
    exports.__esModule = true;
  }, function(module, exports, __webpack_require__) {
    'use strict';
    var _interopRequireDefault = __webpack_require__(2)['default'];
    exports.__esModule = true;
    exports.HandlebarsEnvironment = HandlebarsEnvironment;
    var _utils = __webpack_require__(4);
    var _exception = __webpack_require__(5);
    var _exception2 = _interopRequireDefault(_exception);
    var _helpers = __webpack_require__(6);
    var _decorators = __webpack_require__(14);
    var _logger = __webpack_require__(16);
    var _logger2 = _interopRequireDefault(_logger);
    var VERSION = '4.0.5';
    exports.VERSION = VERSION;
    var COMPILER_REVISION = 7;
    exports.COMPILER_REVISION = COMPILER_REVISION;
    var REVISION_CHANGES = {
      1: '<= 1.0.rc.2',
      2: '== 1.0.0-rc.3',
      3: '== 1.0.0-rc.4',
      4: '== 1.x.x',
      5: '== 2.0.0-alpha.x',
      6: '>= 2.0.0-beta.1',
      7: '>= 4.0.0'
    };
    exports.REVISION_CHANGES = REVISION_CHANGES;
    var objectType = '[object Object]';
    function HandlebarsEnvironment(helpers, partials, decorators) {
      this.helpers = helpers || {};
      this.partials = partials || {};
      this.decorators = decorators || {};
      _helpers.registerDefaultHelpers(this);
      _decorators.registerDefaultDecorators(this);
    }
    HandlebarsEnvironment.prototype = {
      constructor: HandlebarsEnvironment,
      logger: _logger2['default'],
      log: _logger2['default'].log,
      registerHelper: function registerHelper(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2['default']('Arg not supported with multiple helpers');
          }
          _utils.extend(this.helpers, name);
        } else {
          this.helpers[name] = fn;
        }
      },
      unregisterHelper: function unregisterHelper(name) {
        delete this.helpers[name];
      },
      registerPartial: function registerPartial(name, partial) {
        if (_utils.toString.call(name) === objectType) {
          _utils.extend(this.partials, name);
        } else {
          if (typeof partial === 'undefined') {
            throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
          }
          this.partials[name] = partial;
        }
      },
      unregisterPartial: function unregisterPartial(name) {
        delete this.partials[name];
      },
      registerDecorator: function registerDecorator(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2['default']('Arg not supported with multiple decorators');
          }
          _utils.extend(this.decorators, name);
        } else {
          this.decorators[name] = fn;
        }
      },
      unregisterDecorator: function unregisterDecorator(name) {
        delete this.decorators[name];
      }
    };
    var log = _logger2['default'].log;
    exports.log = log;
    exports.createFrame = _utils.createFrame;
    exports.logger = _logger2['default'];
  }, function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.extend = extend;
    exports.indexOf = indexOf;
    exports.escapeExpression = escapeExpression;
    exports.isEmpty = isEmpty;
    exports.createFrame = createFrame;
    exports.blockParams = blockParams;
    exports.appendContextPath = appendContextPath;
    var escape = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '`': '&#x60;',
      '=': '&#x3D;'
    };
    var badChars = /[&<>"'`=]/g,
        possible = /[&<>"'`=]/;
    function escapeChar(chr) {
      return escape[chr];
    }
    function extend(obj) {
      for (var i = 1; i < arguments.length; i++) {
        for (var key in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
            obj[key] = arguments[i][key];
          }
        }
      }
      return obj;
    }
    var toString = Object.prototype.toString;
    exports.toString = toString;
    var isFunction = function isFunction(value) {
      return typeof value === 'function';
    };
    if (isFunction(/x/)) {
      exports.isFunction = isFunction = function(value) {
        return typeof value === 'function' && toString.call(value) === '[object Function]';
      };
    }
    exports.isFunction = isFunction;
    var isArray = Array.isArray || function(value) {
      return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
    };
    exports.isArray = isArray;
    function indexOf(array, value) {
      for (var i = 0,
          len = array.length; i < len; i++) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    }
    function escapeExpression(string) {
      if (typeof string !== 'string') {
        if (string && string.toHTML) {
          return string.toHTML();
        } else if (string == null) {
          return '';
        } else if (!string) {
          return string + '';
        }
        string = '' + string;
      }
      if (!possible.test(string)) {
        return string;
      }
      return string.replace(badChars, escapeChar);
    }
    function isEmpty(value) {
      if (!value && value !== 0) {
        return true;
      } else if (isArray(value) && value.length === 0) {
        return true;
      } else {
        return false;
      }
    }
    function createFrame(object) {
      var frame = extend({}, object);
      frame._parent = object;
      return frame;
    }
    function blockParams(params, ids) {
      params.path = ids;
      return params;
    }
    function appendContextPath(contextPath, id) {
      return (contextPath ? contextPath + '.' : '') + id;
    }
  }, function(module, exports) {
    'use strict';
    exports.__esModule = true;
    var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];
    function Exception(message, node) {
      var loc = node && node.loc,
          line = undefined,
          column = undefined;
      if (loc) {
        line = loc.start.line;
        column = loc.start.column;
        message += ' - ' + line + ':' + column;
      }
      var tmp = Error.prototype.constructor.call(this, message);
      for (var idx = 0; idx < errorProps.length; idx++) {
        this[errorProps[idx]] = tmp[errorProps[idx]];
      }
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, Exception);
      }
      if (loc) {
        this.lineNumber = line;
        this.column = column;
      }
    }
    Exception.prototype = new Error();
    exports['default'] = Exception;
    module.exports = exports['default'];
  }, function(module, exports, __webpack_require__) {
    'use strict';
    var _interopRequireDefault = __webpack_require__(2)['default'];
    exports.__esModule = true;
    exports.registerDefaultHelpers = registerDefaultHelpers;
    var _helpersBlockHelperMissing = __webpack_require__(7);
    var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
    var _helpersEach = __webpack_require__(8);
    var _helpersEach2 = _interopRequireDefault(_helpersEach);
    var _helpersHelperMissing = __webpack_require__(9);
    var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
    var _helpersIf = __webpack_require__(10);
    var _helpersIf2 = _interopRequireDefault(_helpersIf);
    var _helpersLog = __webpack_require__(11);
    var _helpersLog2 = _interopRequireDefault(_helpersLog);
    var _helpersLookup = __webpack_require__(12);
    var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
    var _helpersWith = __webpack_require__(13);
    var _helpersWith2 = _interopRequireDefault(_helpersWith);
    function registerDefaultHelpers(instance) {
      _helpersBlockHelperMissing2['default'](instance);
      _helpersEach2['default'](instance);
      _helpersHelperMissing2['default'](instance);
      _helpersIf2['default'](instance);
      _helpersLog2['default'](instance);
      _helpersLookup2['default'](instance);
      _helpersWith2['default'](instance);
    }
  }, function(module, exports, __webpack_require__) {
    'use strict';
    exports.__esModule = true;
    var _utils = __webpack_require__(4);
    exports['default'] = function(instance) {
      instance.registerHelper('blockHelperMissing', function(context, options) {
        var inverse = options.inverse,
            fn = options.fn;
        if (context === true) {
          return fn(this);
        } else if (context === false || context == null) {
          return inverse(this);
        } else if (_utils.isArray(context)) {
          if (context.length > 0) {
            if (options.ids) {
              options.ids = [options.name];
            }
            return instance.helpers.each(context, options);
          } else {
            return inverse(this);
          }
        } else {
          if (options.data && options.ids) {
            var data = _utils.createFrame(options.data);
            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
            options = {data: data};
          }
          return fn(context, options);
        }
      });
    };
    module.exports = exports['default'];
  }, function(module, exports, __webpack_require__) {
    'use strict';
    var _interopRequireDefault = __webpack_require__(2)['default'];
    exports.__esModule = true;
    var _utils = __webpack_require__(4);
    var _exception = __webpack_require__(5);
    var _exception2 = _interopRequireDefault(_exception);
    exports['default'] = function(instance) {
      instance.registerHelper('each', function(context, options) {
        if (!options) {
          throw new _exception2['default']('Must pass iterator to #each');
        }
        var fn = options.fn,
            inverse = options.inverse,
            i = 0,
            ret = '',
            data = undefined,
            contextPath = undefined;
        if (options.data && options.ids) {
          contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
        }
        if (_utils.isFunction(context)) {
          context = context.call(this);
        }
        if (options.data) {
          data = _utils.createFrame(options.data);
        }
        function execIteration(field, index, last) {
          if (data) {
            data.key = field;
            data.index = index;
            data.first = index === 0;
            data.last = !!last;
            if (contextPath) {
              data.contextPath = contextPath + field;
            }
          }
          ret = ret + fn(context[field], {
            data: data,
            blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
          });
        }
        if (context && typeof context === 'object') {
          if (_utils.isArray(context)) {
            for (var j = context.length; i < j; i++) {
              if (i in context) {
                execIteration(i, i, i === context.length - 1);
              }
            }
          } else {
            var priorKey = undefined;
            for (var key in context) {
              if (context.hasOwnProperty(key)) {
                if (priorKey !== undefined) {
                  execIteration(priorKey, i - 1);
                }
                priorKey = key;
                i++;
              }
            }
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1, true);
            }
          }
        }
        if (i === 0) {
          ret = inverse(this);
        }
        return ret;
      });
    };
    module.exports = exports['default'];
  }, function(module, exports, __webpack_require__) {
    'use strict';
    var _interopRequireDefault = __webpack_require__(2)['default'];
    exports.__esModule = true;
    var _exception = __webpack_require__(5);
    var _exception2 = _interopRequireDefault(_exception);
    exports['default'] = function(instance) {
      instance.registerHelper('helperMissing', function() {
        if (arguments.length === 1) {
          return undefined;
        } else {
          throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
        }
      });
    };
    module.exports = exports['default'];
  }, function(module, exports, __webpack_require__) {
    'use strict';
    exports.__esModule = true;
    var _utils = __webpack_require__(4);
    exports['default'] = function(instance) {
      instance.registerHelper('if', function(conditional, options) {
        if (_utils.isFunction(conditional)) {
          conditional = conditional.call(this);
        }
        if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
          return options.inverse(this);
        } else {
          return options.fn(this);
        }
      });
      instance.registerHelper('unless', function(conditional, options) {
        return instance.helpers['if'].call(this, conditional, {
          fn: options.inverse,
          inverse: options.fn,
          hash: options.hash
        });
      });
    };
    module.exports = exports['default'];
  }, function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports['default'] = function(instance) {
      instance.registerHelper('log', function() {
        var args = [undefined],
            options = arguments[arguments.length - 1];
        for (var i = 0; i < arguments.length - 1; i++) {
          args.push(arguments[i]);
        }
        var level = 1;
        if (options.hash.level != null) {
          level = options.hash.level;
        } else if (options.data && options.data.level != null) {
          level = options.data.level;
        }
        args[0] = level;
        instance.log.apply(instance, args);
      });
    };
    module.exports = exports['default'];
  }, function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports['default'] = function(instance) {
      instance.registerHelper('lookup', function(obj, field) {
        return obj && obj[field];
      });
    };
    module.exports = exports['default'];
  }, function(module, exports, __webpack_require__) {
    'use strict';
    exports.__esModule = true;
    var _utils = __webpack_require__(4);
    exports['default'] = function(instance) {
      instance.registerHelper('with', function(context, options) {
        if (_utils.isFunction(context)) {
          context = context.call(this);
        }
        var fn = options.fn;
        if (!_utils.isEmpty(context)) {
          var data = options.data;
          if (options.data && options.ids) {
            data = _utils.createFrame(options.data);
            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
          }
          return fn(context, {
            data: data,
            blockParams: _utils.blockParams([context], [data && data.contextPath])
          });
        } else {
          return options.inverse(this);
        }
      });
    };
    module.exports = exports['default'];
  }, function(module, exports, __webpack_require__) {
    'use strict';
    var _interopRequireDefault = __webpack_require__(2)['default'];
    exports.__esModule = true;
    exports.registerDefaultDecorators = registerDefaultDecorators;
    var _decoratorsInline = __webpack_require__(15);
    var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
    function registerDefaultDecorators(instance) {
      _decoratorsInline2['default'](instance);
    }
  }, function(module, exports, __webpack_require__) {
    'use strict';
    exports.__esModule = true;
    var _utils = __webpack_require__(4);
    exports['default'] = function(instance) {
      instance.registerDecorator('inline', function(fn, props, container, options) {
        var ret = fn;
        if (!props.partials) {
          props.partials = {};
          ret = function(context, options) {
            var original = container.partials;
            container.partials = _utils.extend({}, original, props.partials);
            var ret = fn(context, options);
            container.partials = original;
            return ret;
          };
        }
        props.partials[options.args[0]] = options.fn;
        return ret;
      });
    };
    module.exports = exports['default'];
  }, function(module, exports, __webpack_require__) {
    'use strict';
    exports.__esModule = true;
    var _utils = __webpack_require__(4);
    var logger = {
      methodMap: ['debug', 'info', 'warn', 'error'],
      level: 'info',
      lookupLevel: function lookupLevel(level) {
        if (typeof level === 'string') {
          var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
          if (levelMap >= 0) {
            level = levelMap;
          } else {
            level = parseInt(level, 10);
          }
        }
        return level;
      },
      log: function log(level) {
        level = logger.lookupLevel(level);
        if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
          var method = logger.methodMap[level];
          if (!console[method]) {
            method = 'log';
          }
          for (var _len = arguments.length,
              message = Array(_len > 1 ? _len - 1 : 0),
              _key = 1; _key < _len; _key++) {
            message[_key - 1] = arguments[_key];
          }
          console[method].apply(console, message);
        }
      }
    };
    exports['default'] = logger;
    module.exports = exports['default'];
  }, function(module, exports) {
    'use strict';
    exports.__esModule = true;
    function SafeString(string) {
      this.string = string;
    }
    SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
      return '' + this.string;
    };
    exports['default'] = SafeString;
    module.exports = exports['default'];
  }, function(module, exports, __webpack_require__) {
    'use strict';
    var _interopRequireWildcard = __webpack_require__(1)['default'];
    var _interopRequireDefault = __webpack_require__(2)['default'];
    exports.__esModule = true;
    exports.checkRevision = checkRevision;
    exports.template = template;
    exports.wrapProgram = wrapProgram;
    exports.resolvePartial = resolvePartial;
    exports.invokePartial = invokePartial;
    exports.noop = noop;
    var _utils = __webpack_require__(4);
    var Utils = _interopRequireWildcard(_utils);
    var _exception = __webpack_require__(5);
    var _exception2 = _interopRequireDefault(_exception);
    var _base = __webpack_require__(3);
    function checkRevision(compilerInfo) {
      var compilerRevision = compilerInfo && compilerInfo[0] || 1,
          currentRevision = _base.COMPILER_REVISION;
      if (compilerRevision !== currentRevision) {
        if (compilerRevision < currentRevision) {
          var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
              compilerVersions = _base.REVISION_CHANGES[compilerRevision];
          throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
        } else {
          throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
        }
      }
    }
    function template(templateSpec, env) {
      if (!env) {
        throw new _exception2['default']('No environment passed to template');
      }
      if (!templateSpec || !templateSpec.main) {
        throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
      }
      templateSpec.main.decorator = templateSpec.main_d;
      env.VM.checkRevision(templateSpec.compiler);
      function invokePartialWrapper(partial, context, options) {
        if (options.hash) {
          context = Utils.extend({}, context, options.hash);
          if (options.ids) {
            options.ids[0] = true;
          }
        }
        partial = env.VM.resolvePartial.call(this, partial, context, options);
        var result = env.VM.invokePartial.call(this, partial, context, options);
        if (result == null && env.compile) {
          options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
          result = options.partials[options.name](context, options);
        }
        if (result != null) {
          if (options.indent) {
            var lines = result.split('\n');
            for (var i = 0,
                l = lines.length; i < l; i++) {
              if (!lines[i] && i + 1 === l) {
                break;
              }
              lines[i] = options.indent + lines[i];
            }
            result = lines.join('\n');
          }
          return result;
        } else {
          throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
        }
      }
      var container = {
        strict: function strict(obj, name) {
          if (!(name in obj)) {
            throw new _exception2['default']('"' + name + '" not defined in ' + obj);
          }
          return obj[name];
        },
        lookup: function lookup(depths, name) {
          var len = depths.length;
          for (var i = 0; i < len; i++) {
            if (depths[i] && depths[i][name] != null) {
              return depths[i][name];
            }
          }
        },
        lambda: function lambda(current, context) {
          return typeof current === 'function' ? current.call(context) : current;
        },
        escapeExpression: Utils.escapeExpression,
        invokePartial: invokePartialWrapper,
        fn: function fn(i) {
          var ret = templateSpec[i];
          ret.decorator = templateSpec[i + '_d'];
          return ret;
        },
        programs: [],
        program: function program(i, data, declaredBlockParams, blockParams, depths) {
          var programWrapper = this.programs[i],
              fn = this.fn(i);
          if (data || depths || blockParams || declaredBlockParams) {
            programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
          } else if (!programWrapper) {
            programWrapper = this.programs[i] = wrapProgram(this, i, fn);
          }
          return programWrapper;
        },
        data: function data(value, depth) {
          while (value && depth--) {
            value = value._parent;
          }
          return value;
        },
        merge: function merge(param, common) {
          var obj = param || common;
          if (param && common && param !== common) {
            obj = Utils.extend({}, common, param);
          }
          return obj;
        },
        noop: env.VM.noop,
        compilerInfo: templateSpec.compiler
      };
      function ret(context) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
        var data = options.data;
        ret._setup(options);
        if (!options.partial && templateSpec.useData) {
          data = initData(context, data);
        }
        var depths = undefined,
            blockParams = templateSpec.useBlockParams ? [] : undefined;
        if (templateSpec.useDepths) {
          if (options.depths) {
            depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
          } else {
            depths = [context];
          }
        }
        function main(context) {
          return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
        }
        main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
        return main(context, options);
      }
      ret.isTop = true;
      ret._setup = function(options) {
        if (!options.partial) {
          container.helpers = container.merge(options.helpers, env.helpers);
          if (templateSpec.usePartial) {
            container.partials = container.merge(options.partials, env.partials);
          }
          if (templateSpec.usePartial || templateSpec.useDecorators) {
            container.decorators = container.merge(options.decorators, env.decorators);
          }
        } else {
          container.helpers = options.helpers;
          container.partials = options.partials;
          container.decorators = options.decorators;
        }
      };
      ret._child = function(i, data, blockParams, depths) {
        if (templateSpec.useBlockParams && !blockParams) {
          throw new _exception2['default']('must pass block params');
        }
        if (templateSpec.useDepths && !depths) {
          throw new _exception2['default']('must pass parent depths');
        }
        return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
      };
      return ret;
    }
    function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
      function prog(context) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
        var currentDepths = depths;
        if (depths && context !== depths[0]) {
          currentDepths = [context].concat(depths);
        }
        return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
      }
      prog = executeDecorators(fn, prog, container, depths, data, blockParams);
      prog.program = i;
      prog.depth = depths ? depths.length : 0;
      prog.blockParams = declaredBlockParams || 0;
      return prog;
    }
    function resolvePartial(partial, context, options) {
      if (!partial) {
        if (options.name === '@partial-block') {
          partial = options.data['partial-block'];
        } else {
          partial = options.partials[options.name];
        }
      } else if (!partial.call && !options.name) {
        options.name = partial;
        partial = options.partials[partial];
      }
      return partial;
    }
    function invokePartial(partial, context, options) {
      options.partial = true;
      if (options.ids) {
        options.data.contextPath = options.ids[0] || options.data.contextPath;
      }
      var partialBlock = undefined;
      if (options.fn && options.fn !== noop) {
        options.data = _base.createFrame(options.data);
        partialBlock = options.data['partial-block'] = options.fn;
        if (partialBlock.partials) {
          options.partials = Utils.extend({}, options.partials, partialBlock.partials);
        }
      }
      if (partial === undefined && partialBlock) {
        partial = partialBlock;
      }
      if (partial === undefined) {
        throw new _exception2['default']('The partial ' + options.name + ' could not be found');
      } else if (partial instanceof Function) {
        return partial(context, options);
      }
    }
    function noop() {
      return '';
    }
    function initData(context, data) {
      if (!data || !('root' in data)) {
        data = data ? _base.createFrame(data) : {};
        data.root = context;
      }
      return data;
    }
    function executeDecorators(fn, prog, container, depths, data, blockParams) {
      if (fn.decorator) {
        var props = {};
        prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
        Utils.extend(prog, props);
      }
      return prog;
    }
  }, function(module, exports) {
    (function(global) {
      'use strict';
      exports.__esModule = true;
      exports['default'] = function(Handlebars) {
        var root = typeof global !== 'undefined' ? global : window,
            $Handlebars = root.Handlebars;
        Handlebars.noConflict = function() {
          if (root.Handlebars === Handlebars) {
            root.Handlebars = $Handlebars;
          }
          return Handlebars;
        };
      };
      module.exports = exports['default'];
    }.call(exports, (function() {
      return this;
    }())));
  }]);
});
;

_removeDefine();
})();
$__System.registerDynamic("94", ["8b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8b').template({
    "1": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "  " + container.escapeExpression((helpers.checkboxOption || (depth0 && depth0.checkboxOption) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-avoid-hostile", ((stack1 = ((stack1 = (depth0 != null ? depth0.route : depth0)) != null ? stack1.settings : stack1)) != null ? stack1.avoidHostile : stack1), "Don't enter hostile territory", "But do try to get out of it quickly.", {
        "name": "checkboxOption",
        "hash": {},
        "data": data
      })) + "\n  " + container.escapeExpression((helpers.checkboxOption || (depth0 && depth0.checkboxOption) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-avoid-unknown-jumppoints", ((stack1 = ((stack1 = (depth0 != null ? depth0.route : depth0)) != null ? stack1.settings : stack1)) != null ? stack1.avoidUnknownJumppoints : stack1), "Avoid unconfirmed jumppoints", "Any jumppoint not yet confirmed, or not yet mapped - those with dashed lines.", {
        "name": "checkboxOption",
        "hash": {},
        "data": data
      })) + "\n  " + container.escapeExpression((helpers.checkboxOption || (depth0 && depth0.checkboxOption) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "sc-map-avoid-off-limits", ((stack1 = ((stack1 = (depth0 != null ? depth0.route : depth0)) != null ? stack1.settings : stack1)) != null ? stack1.avoidOffLimits : stack1), "Avoid 'off limits' systems", "Note though that not all of the system marked as such is necessarily off-limits.", {
        "name": "checkboxOption",
        "hash": {},
        "data": data
      })) + "\n";
    },
    "3": function(container, depth0, helpers, partials, data) {
      return "  <p>Click and drag from system to system to calculate a route between these two systems, which then becomes your current route. You can have only one active route, so you must delete the current route to create a new one, or modify your existing route as desired.</p>\n\n  <p>Use the options section above to configure the global routing options, or set the 'avoid' flag on a system to change the routing through that system only. Note that all route options are advisory, the user has the final say ... as an example: if you set the destination just into hostile territory then turning on the option to avoid hostile systems will not be effective.</p>\n\n  <p>The route will always be the shortest number of jumps possible with the given settings, as using a jump is always faster than traveling in a system from jumppoint to jumppoint, and using jumppoints has been stated to not require fuel.</p>\n\n  <p>Once a route is set, you can drag any of its waypoints elsewhere.  Dragging will create a new waypoint as needed. Existing waypoints on the route can be removed again with the <i class=\"fa fa-times\"></i> symbol in the route list below.</p>\n\n  <p>On a final note: the given estimate times are extremely rough indications based on available information (very little at this time). As we learn more about the in-system and jumppoint traveling I will do my best to refine the calculation accordingly.</p>\n";
    },
    "5": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = helpers.unless.call(depth0 != null ? depth0 : {}, ((stack1 = (depth0 != null ? depth0.route : depth0)) != null ? stack1.status : stack1), {
        "name": "unless",
        "hash": {},
        "fn": container.program(6, data, 0),
        "inverse": container.program(12, data, 0),
        "data": data
      })) != null ? stack1 : "");
    },
    "6": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "    <table class=\"routelist\">\n      <caption>\n        Route from " + container.escapeExpression((helpers.systemLink || (depth0 && depth0.systemLink) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, ((stack1 = (depth0 != null ? depth0.route : depth0)) != null ? stack1.from : stack1), {
        "name": "systemLink",
        "hash": {
          "noTarget": 1,
          "noIcons": 1
        },
        "data": data
      })) + " to " + container.escapeExpression((helpers.systemLink || (depth0 && depth0.systemLink) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, ((stack1 = (depth0 != null ? depth0.route : depth0)) != null ? stack1.to : stack1), {
        "name": "systemLink",
        "hash": {
          "noTarget": 1,
          "noIcons": 1
        },
        "data": data
      })) + "\n        along <strong class=\"route-count\">" + container.escapeExpression((helpers.minusOne || (depth0 && depth0.minusOne) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, ((stack1 = ((stack1 = (depth0 != null ? depth0.route : depth0)) != null ? stack1.waypoints : stack1)) != null ? stack1.length : stack1), {
        "name": "minusOne",
        "hash": {},
        "data": data
      })) + "</strong> jump points:\n      </caption>\n      <tbody>\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {}, ((stack1 = (depth0 != null ? depth0.route : depth0)) != null ? stack1.waypoints : stack1), {
        "name": "each",
        "hash": {},
        "fn": container.program(7, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "      </tbody>\n      <tfoot>\n        <tr>\n          <th class=\"count\">&nbsp;</th>\n          <th class=\"control\">&nbsp;</th>\n          <th class=\"system\">&nbsp;</th>\n          <th class=\"duration small\">&plusmn;" + container.escapeExpression((helpers.durationHMM || (depth0 && depth0.durationHMM) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, ((stack1 = (depth0 != null ? depth0.route : depth0)) != null ? stack1.totalDuration : stack1), {
        "name": "durationHMM",
        "hash": {},
        "data": data
      })) + "</th>\n        </tr>\n      </tfoot>\n    </table>\n    <p>\n      <button class=\"delete-route\"><i class=\"fa fa-fw fa-trash-o\"></i>Delete route</button>\n    </p>\n";
    },
    "7": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "          <tr>\n            <th class=\"count muted\">" + container.escapeExpression((helpers.plusOne || (depth0 && depth0.plusOne) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, (data && data.index), {
        "name": "plusOne",
        "hash": {},
        "data": data
      })) + "</th>\n            <td class=\"control muted\">\n" + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.action : depth0), {
        "name": "if",
        "hash": {},
        "fn": container.program(8, data, 0),
        "inverse": container.program(10, data, 0),
        "data": data
      })) != null ? stack1 : "") + "            </td>\n            <td class=\"system\">" + container.escapeExpression((helpers.systemLink || (depth0 && depth0.systemLink) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.system : depth0), {
        "name": "systemLink",
        "hash": {
          "noTarget": 0,
          "noIcons": 0
        },
        "data": data
      })) + "</td>\n            <td class=\"duration muted small\">" + container.escapeExpression((helpers.durationHMM || (depth0 && depth0.durationHMM) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, (depth0 != null ? depth0.duration : depth0), {
        "name": "durationHMM",
        "hash": {},
        "data": data
      })) + "</td>\n          </tr>\n";
    },
    "8": function(container, depth0, helpers, partials, data) {
      var stack1,
          helper;
      return "                  " + ((stack1 = ((helper = (helper = helpers.action || (depth0 != null ? depth0.action : depth0)) != null ? helper : helpers.helperMissing), (typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {}, {
        "name": "action",
        "hash": {},
        "data": data
      }) : helper))) != null ? stack1 : "") + "<i class=\"fa fa-fw fa-lg " + container.escapeExpression(((helper = (helper = helpers.iconClass || (depth0 != null ? depth0.iconClass : depth0)) != null ? helper : helpers.helperMissing), (typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {}, {
        "name": "iconClass",
        "hash": {},
        "data": data
      }) : helper))) + "\" title=\"" + container.escapeExpression(((helper = (helper = helpers.iconTitle || (depth0 != null ? depth0.iconTitle : depth0)) != null ? helper : helpers.helperMissing), (typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {}, {
        "name": "iconTitle",
        "hash": {},
        "data": data
      }) : helper))) + "\"></i></a>\n";
    },
    "10": function(container, depth0, helpers, partials, data) {
      var helper;
      return "                  <i class=\"fa fa-fw fa-lg " + container.escapeExpression(((helper = (helper = helpers.iconClass || (depth0 != null ? depth0.iconClass : depth0)) != null ? helper : helpers.helperMissing), (typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {}, {
        "name": "iconClass",
        "hash": {},
        "data": data
      }) : helper))) + "\" title=\"" + container.escapeExpression(((helper = (helper = helpers.iconTitle || (depth0 != null ? depth0.iconTitle : depth0)) != null ? helper : helpers.helperMissing), (typeof helper === "function" ? helper.call(depth0 != null ? depth0 : {}, {
        "name": "iconTitle",
        "hash": {},
        "data": data
      }) : helper))) + "\"></i>\n";
    },
    "12": function(container, depth0, helpers, partials, data) {
      var stack1;
      return "    <p class=\"" + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.status : depth0)) != null ? stack1["class"] : stack1), depth0)) + "\">" + container.escapeExpression(container.lambda(((stack1 = ((stack1 = (depth0 != null ? depth0.route : depth0)) != null ? stack1.status : stack1)) != null ? stack1.text : stack1), depth0)) + "</p>\n";
    },
    "compiler": [7, ">= 4.0.0"],
    "main": function(container, depth0, helpers, partials, data) {
      var stack1;
      return ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Routing options", 0, {
        "name": "uiSection",
        "hash": {"class": "no-pad-top"},
        "fn": container.program(1, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "\n" + ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "How this works", 0, {
        "name": "uiSection",
        "hash": {},
        "fn": container.program(3, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "") + "\n" + ((stack1 = (helpers.uiSection || (depth0 && depth0.uiSection) || helpers.helperMissing).call(depth0 != null ? depth0 : {}, "Calculated route", 1, {
        "name": "uiSection",
        "hash": {},
        "fn": container.program(5, data, 0),
        "inverse": container.noop,
        "data": data
      })) != null ? stack1 : "");
    },
    "useData": true
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("98", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("99", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  if (typeof Object.create === 'function') {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }});
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9a", ["99"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('99');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9b", ["98", "9a", "5a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%')
          return '%';
        if (i >= len)
          return x;
        switch (x) {
          case '%s':
            return String(args[i++]);
          case '%d':
            return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (isUndefined(global.process)) {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      if (process.noDeprecation === true) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnviron;
    exports.debuglog = function(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = process.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    };
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      'regexp': 'red'
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '',
          array = false,
          braces = ['{', '}'];
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0,
          l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name,
          str,
          desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = $__require('98');
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }
    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }
    exports.log = function() {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = $__require('9a');
    exports._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  })($__require('5a'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9c", ["9b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('9b');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9d", ["9c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('util') : $__require('9c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9e", ["9d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('9d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9f", ["9e", "5a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    (function(expose) {
      var Markdown = expose.Markdown = function(dialect) {
        switch (typeof dialect) {
          case "undefined":
            this.dialect = Markdown.dialects.Gruber;
            break;
          case "object":
            this.dialect = dialect;
            break;
          default:
            if (dialect in Markdown.dialects) {
              this.dialect = Markdown.dialects[dialect];
            } else {
              throw new Error("Unknown Markdown dialect '" + String(dialect) + "'");
            }
            break;
        }
        this.em_state = [];
        this.strong_state = [];
        this.debug_indent = "";
      };
      expose.parse = function(source, dialect) {
        var md = new Markdown(dialect);
        return md.toTree(source);
      };
      expose.toHTML = function toHTML(source, dialect, options) {
        var input = expose.toHTMLTree(source, dialect, options);
        return expose.renderJsonML(input);
      };
      expose.toHTMLTree = function toHTMLTree(input, dialect, options) {
        if (typeof input === "string")
          input = this.parse(input, dialect);
        var attrs = extract_attr(input),
            refs = {};
        if (attrs && attrs.references) {
          refs = attrs.references;
        }
        var html = convert_tree_to_html(input, refs, options);
        merge_text_nodes(html);
        return html;
      };
      function mk_block_toSource() {
        return "Markdown.mk_block( " + uneval(this.toString()) + ", " + uneval(this.trailing) + ", " + uneval(this.lineNumber) + " )";
      }
      function mk_block_inspect() {
        var util = $__require('9e');
        return "Markdown.mk_block( " + util.inspect(this.toString()) + ", " + util.inspect(this.trailing) + ", " + util.inspect(this.lineNumber) + " )";
      }
      var mk_block = Markdown.mk_block = function(block, trail, line) {
        if (arguments.length == 1)
          trail = "\n\n";
        var s = new String(block);
        s.trailing = trail;
        s.inspect = mk_block_inspect;
        s.toSource = mk_block_toSource;
        if (line != undefined)
          s.lineNumber = line;
        return s;
      };
      function count_lines(str) {
        var n = 0,
            i = -1;
        while ((i = str.indexOf("\n", i + 1)) !== -1)
          n++;
        return n;
      }
      Markdown.prototype.split_blocks = function splitBlocks(input, startLine) {
        input = input.replace(/(\r\n|\n|\r)/g, "\n");
        var re = /([\s\S]+?)($|\n#|\n(?:\s*\n|$)+)/g,
            blocks = [],
            m;
        var line_no = 1;
        if ((m = /^(\s*\n)/.exec(input)) != null) {
          line_no += count_lines(m[0]);
          re.lastIndex = m[0].length;
        }
        while ((m = re.exec(input)) !== null) {
          if (m[2] == "\n#") {
            m[2] = "\n";
            re.lastIndex--;
          }
          blocks.push(mk_block(m[1], m[2], line_no));
          line_no += count_lines(m[0]);
        }
        return blocks;
      };
      Markdown.prototype.processBlock = function processBlock(block, next) {
        var cbs = this.dialect.block,
            ord = cbs.__order__;
        if ("__call__" in cbs) {
          return cbs.__call__.call(this, block, next);
        }
        for (var i = 0; i < ord.length; i++) {
          var res = cbs[ord[i]].call(this, block, next);
          if (res) {
            if (!isArray(res) || (res.length > 0 && !(isArray(res[0]))))
              this.debug(ord[i], "didn't return a proper array");
            return res;
          }
        }
        return [];
      };
      Markdown.prototype.processInline = function processInline(block) {
        return this.dialect.inline.__call__.call(this, String(block));
      };
      Markdown.prototype.toTree = function toTree(source, custom_root) {
        var blocks = source instanceof Array ? source : this.split_blocks(source);
        var old_tree = this.tree;
        try {
          this.tree = custom_root || this.tree || ["markdown"];
          blocks: while (blocks.length) {
            var b = this.processBlock(blocks.shift(), blocks);
            if (!b.length)
              continue blocks;
            this.tree.push.apply(this.tree, b);
          }
          return this.tree;
        } finally {
          if (custom_root) {
            this.tree = old_tree;
          }
        }
      };
      Markdown.prototype.debug = function() {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(this.debug_indent);
        if (typeof print !== "undefined")
          print.apply(print, args);
        if (typeof console !== "undefined" && typeof console.log !== "undefined")
          console.log.apply(null, args);
      };
      Markdown.prototype.loop_re_over_block = function(re, block, cb) {
        var m,
            b = block.valueOf();
        while (b.length && (m = re.exec(b)) != null) {
          b = b.substr(m[0].length);
          cb.call(this, m);
        }
        return b;
      };
      Markdown.dialects = {};
      Markdown.dialects.Gruber = {block: {
          atxHeader: function atxHeader(block, next) {
            var m = block.match(/^(#{1,6})\s*(.*?)\s*#*\s*(?:\n|$)/);
            if (!m)
              return undefined;
            var header = ["header", {level: m[1].length}];
            Array.prototype.push.apply(header, this.processInline(m[2]));
            if (m[0].length < block.length)
              next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));
            return [header];
          },
          setextHeader: function setextHeader(block, next) {
            var m = block.match(/^(.*)\n([-=])\2\2+(?:\n|$)/);
            if (!m)
              return undefined;
            var level = (m[2] === "=") ? 1 : 2;
            var header = ["header", {level: level}, m[1]];
            if (m[0].length < block.length)
              next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));
            return [header];
          },
          code: function code(block, next) {
            var ret = [],
                re = /^(?: {0,3}\t| {4})(.*)\n?/,
                lines;
            if (!block.match(re))
              return undefined;
            block_search: do {
              var b = this.loop_re_over_block(re, block.valueOf(), function(m) {
                ret.push(m[1]);
              });
              if (b.length) {
                next.unshift(mk_block(b, block.trailing));
                break block_search;
              } else if (next.length) {
                if (!next[0].match(re))
                  break block_search;
                ret.push(block.trailing.replace(/[^\n]/g, "").substring(2));
                block = next.shift();
              } else {
                break block_search;
              }
            } while (true);
            return [["code_block", ret.join("\n")]];
          },
          horizRule: function horizRule(block, next) {
            var m = block.match(/^(?:([\s\S]*?)\n)?[ \t]*([-_*])(?:[ \t]*\2){2,}[ \t]*(?:\n([\s\S]*))?$/);
            if (!m) {
              return undefined;
            }
            var jsonml = [["hr"]];
            if (m[1]) {
              jsonml.unshift.apply(jsonml, this.processBlock(m[1], []));
            }
            if (m[3]) {
              next.unshift(mk_block(m[3]));
            }
            return jsonml;
          },
          lists: (function() {
            var any_list = "[*+-]|\\d+\\.",
                bullet_list = /[*+-]/,
                number_list = /\d+\./,
                is_list_re = new RegExp("^( {0,3})(" + any_list + ")[ \t]+"),
                indent_re = "(?: {0,3}\\t| {4})";
            function regex_for_depth(depth) {
              return new RegExp("(?:^(" + indent_re + "{0," + depth + "} {0,3})(" + any_list + ")\\s+)|" + "(^" + indent_re + "{0," + (depth - 1) + "}[ ]{0,4})");
            }
            function expand_tab(input) {
              return input.replace(/ {0,3}\t/g, "    ");
            }
            function add(li, loose, inline, nl) {
              if (loose) {
                li.push(["para"].concat(inline));
                return;
              }
              var add_to = li[li.length - 1] instanceof Array && li[li.length - 1][0] == "para" ? li[li.length - 1] : li;
              if (nl && li.length > 1)
                inline.unshift(nl);
              for (var i = 0; i < inline.length; i++) {
                var what = inline[i],
                    is_str = typeof what == "string";
                if (is_str && add_to.length > 1 && typeof add_to[add_to.length - 1] == "string") {
                  add_to[add_to.length - 1] += what;
                } else {
                  add_to.push(what);
                }
              }
            }
            function get_contained_blocks(depth, blocks) {
              var re = new RegExp("^(" + indent_re + "{" + depth + "}.*?\\n?)*$"),
                  replace = new RegExp("^" + indent_re + "{" + depth + "}", "gm"),
                  ret = [];
              while (blocks.length > 0) {
                if (re.exec(blocks[0])) {
                  var b = blocks.shift(),
                      x = b.replace(replace, "");
                  ret.push(mk_block(x, b.trailing, b.lineNumber));
                } else {
                  break;
                }
              }
              return ret;
            }
            function paragraphify(s, i, stack) {
              var list = s.list;
              var last_li = list[list.length - 1];
              if (last_li[1] instanceof Array && last_li[1][0] == "para") {
                return;
              }
              if (i + 1 == stack.length) {
                last_li.push(["para"].concat(last_li.splice(1, last_li.length - 1)));
              } else {
                var sublist = last_li.pop();
                last_li.push(["para"].concat(last_li.splice(1, last_li.length - 1)), sublist);
              }
            }
            return function(block, next) {
              var m = block.match(is_list_re);
              if (!m)
                return undefined;
              function make_list(m) {
                var list = bullet_list.exec(m[2]) ? ["bulletlist"] : ["numberlist"];
                stack.push({
                  list: list,
                  indent: m[1]
                });
                return list;
              }
              var stack = [],
                  list = make_list(m),
                  last_li,
                  loose = false,
                  ret = [stack[0].list],
                  i;
              loose_search: while (true) {
                var lines = block.split(/(?=\n)/);
                var li_accumulate = "";
                tight_search: for (var line_no = 0; line_no < lines.length; line_no++) {
                  var nl = "",
                      l = lines[line_no].replace(/^\n/, function(n) {
                        nl = n;
                        return "";
                      });
                  var line_re = regex_for_depth(stack.length);
                  m = l.match(line_re);
                  if (m[1] !== undefined) {
                    if (li_accumulate.length) {
                      add(last_li, loose, this.processInline(li_accumulate), nl);
                      loose = false;
                      li_accumulate = "";
                    }
                    m[1] = expand_tab(m[1]);
                    var wanted_depth = Math.floor(m[1].length / 4) + 1;
                    if (wanted_depth > stack.length) {
                      list = make_list(m);
                      last_li.push(list);
                      last_li = list[1] = ["listitem"];
                    } else {
                      var found = false;
                      for (i = 0; i < stack.length; i++) {
                        if (stack[i].indent != m[1])
                          continue;
                        list = stack[i].list;
                        stack.splice(i + 1, stack.length - (i + 1));
                        found = true;
                        break;
                      }
                      if (!found) {
                        wanted_depth++;
                        if (wanted_depth <= stack.length) {
                          stack.splice(wanted_depth, stack.length - wanted_depth);
                          list = stack[wanted_depth - 1].list;
                        } else {
                          list = make_list(m);
                          last_li.push(list);
                        }
                      }
                      last_li = ["listitem"];
                      list.push(last_li);
                    }
                    nl = "";
                  }
                  if (l.length > m[0].length) {
                    li_accumulate += nl + l.substr(m[0].length);
                  }
                }
                if (li_accumulate.length) {
                  add(last_li, loose, this.processInline(li_accumulate), nl);
                  loose = false;
                  li_accumulate = "";
                }
                var contained = get_contained_blocks(stack.length, next);
                if (contained.length > 0) {
                  forEach(stack, paragraphify, this);
                  last_li.push.apply(last_li, this.toTree(contained, []));
                }
                var next_block = next[0] && next[0].valueOf() || "";
                if (next_block.match(is_list_re) || next_block.match(/^ /)) {
                  block = next.shift();
                  var hr = this.dialect.block.horizRule(block, next);
                  if (hr) {
                    ret.push.apply(ret, hr);
                    break;
                  }
                  forEach(stack, paragraphify, this);
                  loose = true;
                  continue loose_search;
                }
                break;
              }
              return ret;
            };
          })(),
          blockquote: function blockquote(block, next) {
            if (!block.match(/^>/m))
              return undefined;
            var jsonml = [];
            if (block[0] != ">") {
              var lines = block.split(/\n/),
                  prev = [],
                  line_no = block.lineNumber;
              while (lines.length && lines[0][0] != ">") {
                prev.push(lines.shift());
                line_no++;
              }
              var abutting = mk_block(prev.join("\n"), "\n", block.lineNumber);
              jsonml.push.apply(jsonml, this.processBlock(abutting, []));
              block = mk_block(lines.join("\n"), block.trailing, line_no);
            }
            while (next.length && next[0][0] == ">") {
              var b = next.shift();
              block = mk_block(block + block.trailing + b, b.trailing, block.lineNumber);
            }
            var input = block.replace(/^> ?/gm, ""),
                old_tree = this.tree,
                processedBlock = this.toTree(input, ["blockquote"]),
                attr = extract_attr(processedBlock);
            if (attr && attr.references) {
              delete attr.references;
              if (isEmpty(attr)) {
                processedBlock.splice(1, 1);
              }
            }
            jsonml.push(processedBlock);
            return jsonml;
          },
          referenceDefn: function referenceDefn(block, next) {
            var re = /^\s*\[(.*?)\]:\s*(\S+)(?:\s+(?:(['"])(.*?)\3|\((.*?)\)))?\n?/;
            if (!block.match(re))
              return undefined;
            if (!extract_attr(this.tree)) {
              this.tree.splice(1, 0, {});
            }
            var attrs = extract_attr(this.tree);
            if (attrs.references === undefined) {
              attrs.references = {};
            }
            var b = this.loop_re_over_block(re, block, function(m) {
              if (m[2] && m[2][0] == "<" && m[2][m[2].length - 1] == ">")
                m[2] = m[2].substring(1, m[2].length - 1);
              var ref = attrs.references[m[1].toLowerCase()] = {href: m[2]};
              if (m[4] !== undefined)
                ref.title = m[4];
              else if (m[5] !== undefined)
                ref.title = m[5];
            });
            if (b.length)
              next.unshift(mk_block(b, block.trailing));
            return [];
          },
          para: function para(block, next) {
            return [["para"].concat(this.processInline(block))];
          }
        }};
      Markdown.dialects.Gruber.inline = {
        __oneElement__: function oneElement(text, patterns_or_re, previous_nodes) {
          var m,
              res,
              lastIndex = 0;
          patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;
          var re = new RegExp("([\\s\\S]*?)(" + (patterns_or_re.source || patterns_or_re) + ")");
          m = re.exec(text);
          if (!m) {
            return [text.length, text];
          } else if (m[1]) {
            return [m[1].length, m[1]];
          }
          var res;
          if (m[2] in this.dialect.inline) {
            res = this.dialect.inline[m[2]].call(this, text.substr(m.index), m, previous_nodes || []);
          }
          res = res || [m[2].length, m[2]];
          return res;
        },
        __call__: function inline(text, patterns) {
          var out = [],
              res;
          function add(x) {
            if (typeof x == "string" && typeof out[out.length - 1] == "string")
              out[out.length - 1] += x;
            else
              out.push(x);
          }
          while (text.length > 0) {
            res = this.dialect.inline.__oneElement__.call(this, text, patterns, out);
            text = text.substr(res.shift());
            forEach(res, add);
          }
          return out;
        },
        "]": function() {},
        "}": function() {},
        __escape__: /^\\[\\`\*_{}\[\]()#\+.!\-]/,
        "\\": function escaped(text) {
          if (this.dialect.inline.__escape__.exec(text))
            return [2, text.charAt(1)];
          else
            return [1, "\\"];
        },
        "![": function image(text) {
          var m = text.match(/^!\[(.*?)\][ \t]*\([ \t]*([^")]*?)(?:[ \t]+(["'])(.*?)\3)?[ \t]*\)/);
          if (m) {
            if (m[2] && m[2][0] == "<" && m[2][m[2].length - 1] == ">")
              m[2] = m[2].substring(1, m[2].length - 1);
            m[2] = this.dialect.inline.__call__.call(this, m[2], /\\/)[0];
            var attrs = {
              alt: m[1],
              href: m[2] || ""
            };
            if (m[4] !== undefined)
              attrs.title = m[4];
            return [m[0].length, ["img", attrs]];
          }
          m = text.match(/^!\[(.*?)\][ \t]*\[(.*?)\]/);
          if (m) {
            return [m[0].length, ["img_ref", {
              alt: m[1],
              ref: m[2].toLowerCase(),
              original: m[0]
            }]];
          }
          return [2, "!["];
        },
        "[": function link(text) {
          var orig = String(text);
          var res = Markdown.DialectHelpers.inline_until_char.call(this, text.substr(1), "]");
          if (!res)
            return [1, "["];
          var consumed = 1 + res[0],
              children = res[1],
              link,
              attrs;
          text = text.substr(consumed);
          var m = text.match(/^\s*\([ \t]*([^"']*)(?:[ \t]+(["'])(.*?)\2)?[ \t]*\)/);
          if (m) {
            var url = m[1];
            consumed += m[0].length;
            if (url && url[0] == "<" && url[url.length - 1] == ">")
              url = url.substring(1, url.length - 1);
            if (!m[3]) {
              var open_parens = 1;
              for (var len = 0; len < url.length; len++) {
                switch (url[len]) {
                  case "(":
                    open_parens++;
                    break;
                  case ")":
                    if (--open_parens == 0) {
                      consumed -= url.length - len;
                      url = url.substring(0, len);
                    }
                    break;
                }
              }
            }
            url = this.dialect.inline.__call__.call(this, url, /\\/)[0];
            attrs = {href: url || ""};
            if (m[3] !== undefined)
              attrs.title = m[3];
            link = ["link", attrs].concat(children);
            return [consumed, link];
          }
          m = text.match(/^\s*\[(.*?)\]/);
          if (m) {
            consumed += m[0].length;
            attrs = {
              ref: (m[1] || String(children)).toLowerCase(),
              original: orig.substr(0, consumed)
            };
            link = ["link_ref", attrs].concat(children);
            return [consumed, link];
          }
          if (children.length == 1 && typeof children[0] == "string") {
            attrs = {
              ref: children[0].toLowerCase(),
              original: orig.substr(0, consumed)
            };
            link = ["link_ref", attrs, children[0]];
            return [consumed, link];
          }
          return [1, "["];
        },
        "<": function autoLink(text) {
          var m;
          if ((m = text.match(/^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\.[a-zA-Z]+))>/)) != null) {
            if (m[3]) {
              return [m[0].length, ["link", {href: "mailto:" + m[3]}, m[3]]];
            } else if (m[2] == "mailto") {
              return [m[0].length, ["link", {href: m[1]}, m[1].substr("mailto:".length)]];
            } else
              return [m[0].length, ["link", {href: m[1]}, m[1]]];
          }
          return [1, "<"];
        },
        "`": function inlineCode(text) {
          var m = text.match(/(`+)(([\s\S]*?)\1)/);
          if (m && m[2])
            return [m[1].length + m[2].length, ["inlinecode", m[3]]];
          else {
            return [1, "`"];
          }
        },
        "  \n": function lineBreak(text) {
          return [3, ["linebreak"]];
        }
      };
      function strong_em(tag, md) {
        var state_slot = tag + "_state",
            other_slot = tag == "strong" ? "em_state" : "strong_state";
        function CloseTag(len) {
          this.len_after = len;
          this.name = "close_" + md;
        }
        return function(text, orig_match) {
          if (this[state_slot][0] == md) {
            this[state_slot].shift();
            return [text.length, new CloseTag(text.length - md.length)];
          } else {
            var other = this[other_slot].slice(),
                state = this[state_slot].slice();
            this[state_slot].unshift(md);
            var res = this.processInline(text.substr(md.length));
            var last = res[res.length - 1];
            var check = this[state_slot].shift();
            if (last instanceof CloseTag) {
              res.pop();
              var consumed = text.length - last.len_after;
              return [consumed, [tag].concat(res)];
            } else {
              this[other_slot] = other;
              this[state_slot] = state;
              return [md.length, md];
            }
          }
        };
      }
      Markdown.dialects.Gruber.inline["**"] = strong_em("strong", "**");
      Markdown.dialects.Gruber.inline["__"] = strong_em("strong", "__");
      Markdown.dialects.Gruber.inline["*"] = strong_em("em", "*");
      Markdown.dialects.Gruber.inline["_"] = strong_em("em", "_");
      Markdown.buildBlockOrder = function(d) {
        var ord = [];
        for (var i in d) {
          if (i == "__order__" || i == "__call__")
            continue;
          ord.push(i);
        }
        d.__order__ = ord;
      };
      Markdown.buildInlinePatterns = function(d) {
        var patterns = [];
        for (var i in d) {
          if (i.match(/^__.*__$/))
            continue;
          var l = i.replace(/([\\.*+?|()\[\]{}])/g, "\\$1").replace(/\n/, "\\n");
          patterns.push(i.length == 1 ? l : "(?:" + l + ")");
        }
        patterns = patterns.join("|");
        d.__patterns__ = patterns;
        var fn = d.__call__;
        d.__call__ = function(text, pattern) {
          if (pattern != undefined) {
            return fn.call(this, text, pattern);
          } else {
            return fn.call(this, text, patterns);
          }
        };
      };
      Markdown.DialectHelpers = {};
      Markdown.DialectHelpers.inline_until_char = function(text, want) {
        var consumed = 0,
            nodes = [];
        while (true) {
          if (text.charAt(consumed) == want) {
            consumed++;
            return [consumed, nodes];
          }
          if (consumed >= text.length) {
            return null;
          }
          var res = this.dialect.inline.__oneElement__.call(this, text.substr(consumed));
          consumed += res[0];
          nodes.push.apply(nodes, res.slice(1));
        }
      };
      Markdown.subclassDialect = function(d) {
        function Block() {}
        Block.prototype = d.block;
        function Inline() {}
        Inline.prototype = d.inline;
        return {
          block: new Block(),
          inline: new Inline()
        };
      };
      Markdown.buildBlockOrder(Markdown.dialects.Gruber.block);
      Markdown.buildInlinePatterns(Markdown.dialects.Gruber.inline);
      Markdown.dialects.Maruku = Markdown.subclassDialect(Markdown.dialects.Gruber);
      Markdown.dialects.Maruku.processMetaHash = function processMetaHash(meta_string) {
        var meta = split_meta_hash(meta_string),
            attr = {};
        for (var i = 0; i < meta.length; ++i) {
          if (/^#/.test(meta[i])) {
            attr.id = meta[i].substring(1);
          } else if (/^\./.test(meta[i])) {
            if (attr["class"]) {
              attr["class"] = attr["class"] + meta[i].replace(/./, " ");
            } else {
              attr["class"] = meta[i].substring(1);
            }
          } else if (/\=/.test(meta[i])) {
            var s = meta[i].split(/\=/);
            attr[s[0]] = s[1];
          }
        }
        return attr;
      };
      function split_meta_hash(meta_string) {
        var meta = meta_string.split(""),
            parts = [""],
            in_quotes = false;
        while (meta.length) {
          var letter = meta.shift();
          switch (letter) {
            case " ":
              if (in_quotes) {
                parts[parts.length - 1] += letter;
              } else {
                parts.push("");
              }
              break;
            case "'":
            case '"':
              in_quotes = !in_quotes;
              break;
            case "\\":
              letter = meta.shift();
            default:
              parts[parts.length - 1] += letter;
              break;
          }
        }
        return parts;
      }
      Markdown.dialects.Maruku.block.document_meta = function document_meta(block, next) {
        if (block.lineNumber > 1)
          return undefined;
        if (!block.match(/^(?:\w+:.*\n)*\w+:.*$/))
          return undefined;
        if (!extract_attr(this.tree)) {
          this.tree.splice(1, 0, {});
        }
        var pairs = block.split(/\n/);
        for (p in pairs) {
          var m = pairs[p].match(/(\w+):\s*(.*)$/),
              key = m[1].toLowerCase(),
              value = m[2];
          this.tree[1][key] = value;
        }
        return [];
      };
      Markdown.dialects.Maruku.block.block_meta = function block_meta(block, next) {
        var m = block.match(/(^|\n) {0,3}\{:\s*((?:\\\}|[^\}])*)\s*\}$/);
        if (!m)
          return undefined;
        var attr = this.dialect.processMetaHash(m[2]);
        var hash;
        if (m[1] === "") {
          var node = this.tree[this.tree.length - 1];
          hash = extract_attr(node);
          if (typeof node === "string")
            return undefined;
          if (!hash) {
            hash = {};
            node.splice(1, 0, hash);
          }
          for (a in attr) {
            hash[a] = attr[a];
          }
          return [];
        }
        var b = block.replace(/\n.*$/, ""),
            result = this.processBlock(b, []);
        hash = extract_attr(result[0]);
        if (!hash) {
          hash = {};
          result[0].splice(1, 0, hash);
        }
        for (a in attr) {
          hash[a] = attr[a];
        }
        return result;
      };
      Markdown.dialects.Maruku.block.definition_list = function definition_list(block, next) {
        var tight = /^((?:[^\s:].*\n)+):\s+([\s\S]+)$/,
            list = ["dl"],
            i,
            m;
        if ((m = block.match(tight))) {
          var blocks = [block];
          while (next.length && tight.exec(next[0])) {
            blocks.push(next.shift());
          }
          for (var b = 0; b < blocks.length; ++b) {
            var m = blocks[b].match(tight),
                terms = m[1].replace(/\n$/, "").split(/\n/),
                defns = m[2].split(/\n:\s+/);
            for (i = 0; i < terms.length; ++i) {
              list.push(["dt", terms[i]]);
            }
            for (i = 0; i < defns.length; ++i) {
              list.push(["dd"].concat(this.processInline(defns[i].replace(/(\n)\s+/, "$1"))));
            }
          }
        } else {
          return undefined;
        }
        return [list];
      };
      Markdown.dialects.Maruku.block.table = function table(block, next) {
        var _split_on_unescaped = function(s, ch) {
          ch = ch || '\\s';
          if (ch.match(/^[\\|\[\]{}?*.+^$]$/)) {
            ch = '\\' + ch;
          }
          var res = [],
              r = new RegExp('^((?:\\\\.|[^\\\\' + ch + '])*)' + ch + '(.*)'),
              m;
          while (m = s.match(r)) {
            res.push(m[1]);
            s = m[2];
          }
          res.push(s);
          return res;
        };
        var leading_pipe = /^ {0,3}\|(.+)\n {0,3}\|\s*([\-:]+[\-| :]*)\n((?:\s*\|.*(?:\n|$))*)(?=\n|$)/,
            no_leading_pipe = /^ {0,3}(\S(?:\\.|[^\\|])*\|.*)\n {0,3}([\-:]+\s*\|[\-| :]*)\n((?:(?:\\.|[^\\|])*\|.*(?:\n|$))*)(?=\n|$)/,
            i,
            m;
        if (m = block.match(leading_pipe)) {
          m[3] = m[3].replace(/^\s*\|/gm, '');
        } else if (!(m = block.match(no_leading_pipe))) {
          return undefined;
        }
        var table = ["table", ["thead", ["tr"]], ["tbody"]];
        m[2] = m[2].replace(/\|\s*$/, '').split('|');
        var html_attrs = [];
        forEach(m[2], function(s) {
          if (s.match(/^\s*-+:\s*$/))
            html_attrs.push({align: "right"});
          else if (s.match(/^\s*:-+\s*$/))
            html_attrs.push({align: "left"});
          else if (s.match(/^\s*:-+:\s*$/))
            html_attrs.push({align: "center"});
          else
            html_attrs.push({});
        });
        m[1] = _split_on_unescaped(m[1].replace(/\|\s*$/, ''), '|');
        for (i = 0; i < m[1].length; i++) {
          table[1][1].push(['th', html_attrs[i] || {}].concat(this.processInline(m[1][i].trim())));
        }
        forEach(m[3].replace(/\|\s*$/mg, '').split('\n'), function(row) {
          var html_row = ['tr'];
          row = _split_on_unescaped(row, '|');
          for (i = 0; i < row.length; i++) {
            html_row.push(['td', html_attrs[i] || {}].concat(this.processInline(row[i].trim())));
          }
          table[2].push(html_row);
        }, this);
        return [table];
      };
      Markdown.dialects.Maruku.inline["{:"] = function inline_meta(text, matches, out) {
        if (!out.length) {
          return [2, "{:"];
        }
        var before = out[out.length - 1];
        if (typeof before === "string") {
          return [2, "{:"];
        }
        var m = text.match(/^\{:\s*((?:\\\}|[^\}])*)\s*\}/);
        if (!m) {
          return [2, "{:"];
        }
        var meta = this.dialect.processMetaHash(m[1]),
            attr = extract_attr(before);
        if (!attr) {
          attr = {};
          before.splice(1, 0, attr);
        }
        for (var k in meta) {
          attr[k] = meta[k];
        }
        return [m[0].length, ""];
      };
      Markdown.dialects.Maruku.inline.__escape__ = /^\\[\\`\*_{}\[\]()#\+.!\-|:]/;
      Markdown.buildBlockOrder(Markdown.dialects.Maruku.block);
      Markdown.buildInlinePatterns(Markdown.dialects.Maruku.inline);
      var isArray = Array.isArray || function(obj) {
        return Object.prototype.toString.call(obj) == "[object Array]";
      };
      var forEach;
      if (Array.prototype.forEach) {
        forEach = function(arr, cb, thisp) {
          return arr.forEach(cb, thisp);
        };
      } else {
        forEach = function(arr, cb, thisp) {
          for (var i = 0; i < arr.length; i++) {
            cb.call(thisp || arr, arr[i], i, arr);
          }
        };
      }
      var isEmpty = function(obj) {
        for (var key in obj) {
          if (hasOwnProperty.call(obj, key)) {
            return false;
          }
        }
        return true;
      };
      function extract_attr(jsonml) {
        return isArray(jsonml) && jsonml.length > 1 && typeof jsonml[1] === "object" && !(isArray(jsonml[1])) ? jsonml[1] : undefined;
      }
      expose.renderJsonML = function(jsonml, options) {
        options = options || {};
        options.root = options.root || false;
        var content = [];
        if (options.root) {
          content.push(render_tree(jsonml));
        } else {
          jsonml.shift();
          if (jsonml.length && typeof jsonml[0] === "object" && !(jsonml[0] instanceof Array)) {
            jsonml.shift();
          }
          while (jsonml.length) {
            content.push(render_tree(jsonml.shift()));
          }
        }
        return content.join("\n\n");
      };
      function escapeHTML(text) {
        return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      }
      function render_tree(jsonml) {
        if (typeof jsonml === "string") {
          return escapeHTML(jsonml);
        }
        var tag = jsonml.shift(),
            attributes = {},
            content = [];
        if (jsonml.length && typeof jsonml[0] === "object" && !(jsonml[0] instanceof Array)) {
          attributes = jsonml.shift();
        }
        while (jsonml.length) {
          content.push(render_tree(jsonml.shift()));
        }
        var tag_attrs = "";
        for (var a in attributes) {
          tag_attrs += " " + a + '="' + escapeHTML(attributes[a]) + '"';
        }
        if (tag == "img" || tag == "br" || tag == "hr") {
          return "<" + tag + tag_attrs + "/>";
        } else {
          return "<" + tag + tag_attrs + ">" + content.join("") + "</" + tag + ">";
        }
      }
      function convert_tree_to_html(tree, references, options) {
        var i;
        options = options || {};
        var jsonml = tree.slice(0);
        if (typeof options.preprocessTreeNode === "function") {
          jsonml = options.preprocessTreeNode(jsonml, references);
        }
        var attrs = extract_attr(jsonml);
        if (attrs) {
          jsonml[1] = {};
          for (i in attrs) {
            jsonml[1][i] = attrs[i];
          }
          attrs = jsonml[1];
        }
        if (typeof jsonml === "string") {
          return jsonml;
        }
        switch (jsonml[0]) {
          case "header":
            jsonml[0] = "h" + jsonml[1].level;
            delete jsonml[1].level;
            break;
          case "bulletlist":
            jsonml[0] = "ul";
            break;
          case "numberlist":
            jsonml[0] = "ol";
            break;
          case "listitem":
            jsonml[0] = "li";
            break;
          case "para":
            jsonml[0] = "p";
            break;
          case "markdown":
            jsonml[0] = "html";
            if (attrs)
              delete attrs.references;
            break;
          case "code_block":
            jsonml[0] = "pre";
            i = attrs ? 2 : 1;
            var code = ["code"];
            code.push.apply(code, jsonml.splice(i, jsonml.length - i));
            jsonml[i] = code;
            break;
          case "inlinecode":
            jsonml[0] = "code";
            break;
          case "img":
            jsonml[1].src = jsonml[1].href;
            delete jsonml[1].href;
            break;
          case "linebreak":
            jsonml[0] = "br";
            break;
          case "link":
            jsonml[0] = "a";
            break;
          case "link_ref":
            jsonml[0] = "a";
            var ref = references[attrs.ref];
            if (ref) {
              delete attrs.ref;
              attrs.href = ref.href;
              if (ref.title) {
                attrs.title = ref.title;
              }
              delete attrs.original;
            } else {
              return attrs.original;
            }
            break;
          case "img_ref":
            jsonml[0] = "img";
            var ref = references[attrs.ref];
            if (ref) {
              delete attrs.ref;
              attrs.src = ref.href;
              if (ref.title) {
                attrs.title = ref.title;
              }
              delete attrs.original;
            } else {
              return attrs.original;
            }
            break;
        }
        i = 1;
        if (attrs) {
          for (var key in jsonml[1]) {
            i = 2;
            break;
          }
          if (i === 1) {
            jsonml.splice(i, 1);
          }
        }
        for (; i < jsonml.length; ++i) {
          jsonml[i] = convert_tree_to_html(jsonml[i], references, options);
        }
        return jsonml;
      }
      function merge_text_nodes(jsonml) {
        var i = extract_attr(jsonml) ? 2 : 1;
        while (i < jsonml.length) {
          if (typeof jsonml[i] === "string") {
            if (i + 1 < jsonml.length && typeof jsonml[i + 1] === "string") {
              jsonml[i] += jsonml.splice(i + 1, 1)[0];
            } else {
              ++i;
            }
          } else {
            merge_text_nodes(jsonml[i]);
            ++i;
          }
        }
      }
    })((function() {
      if (typeof exports === "undefined") {
        window.markdown = {};
        return window.markdown;
      } else {
        return exports;
      }
    })());
  })($__require('5a'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a0", ["9f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.markdown = $__require('9f');
  exports.parse = exports.markdown.toHTML;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("89", ["a0"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('a0');
  global.define = __define;
  return module.exports;
});

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
(function(factory) {
  if (typeof define === "function" && define.amd) {
    define("a1", ["84", "a2", "a3"], factory);
  } else {
    factory(jQuery);
  }
}(function($) {
  return $.widget("ui.tabs", {
    version: "1.11.4",
    delay: 300,
    options: {
      active: null,
      collapsible: false,
      event: "click",
      heightStyle: "content",
      hide: null,
      show: null,
      activate: null,
      beforeActivate: null,
      beforeLoad: null,
      load: null
    },
    _isLocal: (function() {
      var rhash = /#.*$/;
      return function(anchor) {
        var anchorUrl,
            locationUrl;
        anchor = anchor.cloneNode(false);
        anchorUrl = anchor.href.replace(rhash, "");
        locationUrl = location.href.replace(rhash, "");
        try {
          anchorUrl = decodeURIComponent(anchorUrl);
        } catch (error) {}
        try {
          locationUrl = decodeURIComponent(locationUrl);
        } catch (error) {}
        return anchor.hash.length > 1 && anchorUrl === locationUrl;
      };
    })(),
    _create: function() {
      var that = this,
          options = this.options;
      this.running = false;
      this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible", options.collapsible);
      this._processTabs();
      options.active = this._initialActive();
      if ($.isArray(options.disabled)) {
        options.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter(".ui-state-disabled"), function(li) {
          return that.tabs.index(li);
        }))).sort();
      }
      if (this.options.active !== false && this.anchors.length) {
        this.active = this._findActive(options.active);
      } else {
        this.active = $();
      }
      this._refresh();
      if (this.active.length) {
        this.load(options.active);
      }
    },
    _initialActive: function() {
      var active = this.options.active,
          collapsible = this.options.collapsible,
          locationHash = location.hash.substring(1);
      if (active === null) {
        if (locationHash) {
          this.tabs.each(function(i, tab) {
            if ($(tab).attr("aria-controls") === locationHash) {
              active = i;
              return false;
            }
          });
        }
        if (active === null) {
          active = this.tabs.index(this.tabs.filter(".ui-tabs-active"));
        }
        if (active === null || active === -1) {
          active = this.tabs.length ? 0 : false;
        }
      }
      if (active !== false) {
        active = this.tabs.index(this.tabs.eq(active));
        if (active === -1) {
          active = collapsible ? false : 0;
        }
      }
      if (!collapsible && active === false && this.anchors.length) {
        active = 0;
      }
      return active;
    },
    _getCreateEventData: function() {
      return {
        tab: this.active,
        panel: !this.active.length ? $() : this._getPanelForTab(this.active)
      };
    },
    _tabKeydown: function(event) {
      var focusedTab = $(this.document[0].activeElement).closest("li"),
          selectedIndex = this.tabs.index(focusedTab),
          goingForward = true;
      if (this._handlePageNav(event)) {
        return;
      }
      switch (event.keyCode) {
        case $.ui.keyCode.RIGHT:
        case $.ui.keyCode.DOWN:
          selectedIndex++;
          break;
        case $.ui.keyCode.UP:
        case $.ui.keyCode.LEFT:
          goingForward = false;
          selectedIndex--;
          break;
        case $.ui.keyCode.END:
          selectedIndex = this.anchors.length - 1;
          break;
        case $.ui.keyCode.HOME:
          selectedIndex = 0;
          break;
        case $.ui.keyCode.SPACE:
          event.preventDefault();
          clearTimeout(this.activating);
          this._activate(selectedIndex);
          return;
        case $.ui.keyCode.ENTER:
          event.preventDefault();
          clearTimeout(this.activating);
          this._activate(selectedIndex === this.options.active ? false : selectedIndex);
          return;
        default:
          return;
      }
      event.preventDefault();
      clearTimeout(this.activating);
      selectedIndex = this._focusNextTab(selectedIndex, goingForward);
      if (!event.ctrlKey && !event.metaKey) {
        focusedTab.attr("aria-selected", "false");
        this.tabs.eq(selectedIndex).attr("aria-selected", "true");
        this.activating = this._delay(function() {
          this.option("active", selectedIndex);
        }, this.delay);
      }
    },
    _panelKeydown: function(event) {
      if (this._handlePageNav(event)) {
        return;
      }
      if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
        event.preventDefault();
        this.active.focus();
      }
    },
    _handlePageNav: function(event) {
      if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
        this._activate(this._focusNextTab(this.options.active - 1, false));
        return true;
      }
      if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
        this._activate(this._focusNextTab(this.options.active + 1, true));
        return true;
      }
    },
    _findNextTab: function(index, goingForward) {
      var lastTabIndex = this.tabs.length - 1;
      function constrain() {
        if (index > lastTabIndex) {
          index = 0;
        }
        if (index < 0) {
          index = lastTabIndex;
        }
        return index;
      }
      while ($.inArray(constrain(), this.options.disabled) !== -1) {
        index = goingForward ? index + 1 : index - 1;
      }
      return index;
    },
    _focusNextTab: function(index, goingForward) {
      index = this._findNextTab(index, goingForward);
      this.tabs.eq(index).focus();
      return index;
    },
    _setOption: function(key, value) {
      if (key === "active") {
        this._activate(value);
        return;
      }
      if (key === "disabled") {
        this._setupDisabled(value);
        return;
      }
      this._super(key, value);
      if (key === "collapsible") {
        this.element.toggleClass("ui-tabs-collapsible", value);
        if (!value && this.options.active === false) {
          this._activate(0);
        }
      }
      if (key === "event") {
        this._setupEvents(value);
      }
      if (key === "heightStyle") {
        this._setupHeightStyle(value);
      }
    },
    _sanitizeSelector: function(hash) {
      return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
    },
    refresh: function() {
      var options = this.options,
          lis = this.tablist.children(":has(a[href])");
      options.disabled = $.map(lis.filter(".ui-state-disabled"), function(tab) {
        return lis.index(tab);
      });
      this._processTabs();
      if (options.active === false || !this.anchors.length) {
        options.active = false;
        this.active = $();
      } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
        if (this.tabs.length === options.disabled.length) {
          options.active = false;
          this.active = $();
        } else {
          this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
        }
      } else {
        options.active = this.tabs.index(this.active);
      }
      this._refresh();
    },
    _refresh: function() {
      this._setupDisabled(this.options.disabled);
      this._setupEvents(this.options.event);
      this._setupHeightStyle(this.options.heightStyle);
      this.tabs.not(this.active).attr({
        "aria-selected": "false",
        "aria-expanded": "false",
        tabIndex: -1
      });
      this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden": "true"});
      if (!this.active.length) {
        this.tabs.eq(0).attr("tabIndex", 0);
      } else {
        this.active.addClass("ui-tabs-active ui-state-active").attr({
          "aria-selected": "true",
          "aria-expanded": "true",
          tabIndex: 0
        });
        this._getPanelForTab(this.active).show().attr({"aria-hidden": "false"});
      }
    },
    _processTabs: function() {
      var that = this,
          prevTabs = this.tabs,
          prevAnchors = this.anchors,
          prevPanels = this.panels;
      this.tablist = this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role", "tablist").delegate("> li", "mousedown" + this.eventNamespace, function(event) {
        if ($(this).is(".ui-state-disabled")) {
          event.preventDefault();
        }
      }).delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
        if ($(this).closest("li").is(".ui-state-disabled")) {
          this.blur();
        }
      });
      this.tabs = this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({
        role: "tab",
        tabIndex: -1
      });
      this.anchors = this.tabs.map(function() {
        return $("a", this)[0];
      }).addClass("ui-tabs-anchor").attr({
        role: "presentation",
        tabIndex: -1
      });
      this.panels = $();
      this.anchors.each(function(i, anchor) {
        var selector,
            panel,
            panelId,
            anchorId = $(anchor).uniqueId().attr("id"),
            tab = $(anchor).closest("li"),
            originalAriaControls = tab.attr("aria-controls");
        if (that._isLocal(anchor)) {
          selector = anchor.hash;
          panelId = selector.substring(1);
          panel = that.element.find(that._sanitizeSelector(selector));
        } else {
          panelId = tab.attr("aria-controls") || $({}).uniqueId()[0].id;
          selector = "#" + panelId;
          panel = that.element.find(selector);
          if (!panel.length) {
            panel = that._createPanel(panelId);
            panel.insertAfter(that.panels[i - 1] || that.tablist);
          }
          panel.attr("aria-live", "polite");
        }
        if (panel.length) {
          that.panels = that.panels.add(panel);
        }
        if (originalAriaControls) {
          tab.data("ui-tabs-aria-controls", originalAriaControls);
        }
        tab.attr({
          "aria-controls": panelId,
          "aria-labelledby": anchorId
        });
        panel.attr("aria-labelledby", anchorId);
      });
      this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role", "tabpanel");
      if (prevTabs) {
        this._off(prevTabs.not(this.tabs));
        this._off(prevAnchors.not(this.anchors));
        this._off(prevPanels.not(this.panels));
      }
    },
    _getList: function() {
      return this.tablist || this.element.find("ol,ul").eq(0);
    },
    _createPanel: function(id) {
      return $("<div>").attr("id", id).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", true);
    },
    _setupDisabled: function(disabled) {
      if ($.isArray(disabled)) {
        if (!disabled.length) {
          disabled = false;
        } else if (disabled.length === this.anchors.length) {
          disabled = true;
        }
      }
      for (var i = 0,
          li; (li = this.tabs[i]); i++) {
        if (disabled === true || $.inArray(i, disabled) !== -1) {
          $(li).addClass("ui-state-disabled").attr("aria-disabled", "true");
        } else {
          $(li).removeClass("ui-state-disabled").removeAttr("aria-disabled");
        }
      }
      this.options.disabled = disabled;
    },
    _setupEvents: function(event) {
      var events = {};
      if (event) {
        $.each(event.split(" "), function(index, eventName) {
          events[eventName] = "_eventHandler";
        });
      }
      this._off(this.anchors.add(this.tabs).add(this.panels));
      this._on(true, this.anchors, {click: function(event) {
          event.preventDefault();
        }});
      this._on(this.anchors, events);
      this._on(this.tabs, {keydown: "_tabKeydown"});
      this._on(this.panels, {keydown: "_panelKeydown"});
      this._focusable(this.tabs);
      this._hoverable(this.tabs);
    },
    _setupHeightStyle: function(heightStyle) {
      var maxHeight,
          parent = this.element.parent();
      if (heightStyle === "fill") {
        maxHeight = parent.height();
        maxHeight -= this.element.outerHeight() - this.element.height();
        this.element.siblings(":visible").each(function() {
          var elem = $(this),
              position = elem.css("position");
          if (position === "absolute" || position === "fixed") {
            return;
          }
          maxHeight -= elem.outerHeight(true);
        });
        this.element.children().not(this.panels).each(function() {
          maxHeight -= $(this).outerHeight(true);
        });
        this.panels.each(function() {
          $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
        }).css("overflow", "auto");
      } else if (heightStyle === "auto") {
        maxHeight = 0;
        this.panels.each(function() {
          maxHeight = Math.max(maxHeight, $(this).height("").height());
        }).height(maxHeight);
      }
    },
    _eventHandler: function(event) {
      var options = this.options,
          active = this.active,
          anchor = $(event.currentTarget),
          tab = anchor.closest("li"),
          clickedIsActive = tab[0] === active[0],
          collapsing = clickedIsActive && options.collapsible,
          toShow = collapsing ? $() : this._getPanelForTab(tab),
          toHide = !active.length ? $() : this._getPanelForTab(active),
          eventData = {
            oldTab: active,
            oldPanel: toHide,
            newTab: collapsing ? $() : tab,
            newPanel: toShow
          };
      event.preventDefault();
      if (tab.hasClass("ui-state-disabled") || tab.hasClass("ui-tabs-loading") || this.running || (clickedIsActive && !options.collapsible) || (this._trigger("beforeActivate", event, eventData) === false)) {
        return;
      }
      options.active = collapsing ? false : this.tabs.index(tab);
      this.active = clickedIsActive ? $() : tab;
      if (this.xhr) {
        this.xhr.abort();
      }
      if (!toHide.length && !toShow.length) {
        $.error("jQuery UI Tabs: Mismatching fragment identifier.");
      }
      if (toShow.length) {
        this.load(this.tabs.index(tab), event);
      }
      this._toggle(event, eventData);
    },
    _toggle: function(event, eventData) {
      var that = this,
          toShow = eventData.newPanel,
          toHide = eventData.oldPanel;
      this.running = true;
      function complete() {
        that.running = false;
        that._trigger("activate", event, eventData);
      }
      function show() {
        eventData.newTab.closest("li").addClass("ui-tabs-active ui-state-active");
        if (toShow.length && that.options.show) {
          that._show(toShow, that.options.show, complete);
        } else {
          toShow.show();
          complete();
        }
      }
      if (toHide.length && this.options.hide) {
        this._hide(toHide, this.options.hide, function() {
          eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
          show();
        });
      } else {
        eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
        toHide.hide();
        show();
      }
      toHide.attr("aria-hidden", "true");
      eventData.oldTab.attr({
        "aria-selected": "false",
        "aria-expanded": "false"
      });
      if (toShow.length && toHide.length) {
        eventData.oldTab.attr("tabIndex", -1);
      } else if (toShow.length) {
        this.tabs.filter(function() {
          return $(this).attr("tabIndex") === 0;
        }).attr("tabIndex", -1);
      }
      toShow.attr("aria-hidden", "false");
      eventData.newTab.attr({
        "aria-selected": "true",
        "aria-expanded": "true",
        tabIndex: 0
      });
    },
    _activate: function(index) {
      var anchor,
          active = this._findActive(index);
      if (active[0] === this.active[0]) {
        return;
      }
      if (!active.length) {
        active = this.active;
      }
      anchor = active.find(".ui-tabs-anchor")[0];
      this._eventHandler({
        target: anchor,
        currentTarget: anchor,
        preventDefault: $.noop
      });
    },
    _findActive: function(index) {
      return index === false ? $() : this.tabs.eq(index);
    },
    _getIndex: function(index) {
      if (typeof index === "string") {
        index = this.anchors.index(this.anchors.filter("[href$='" + index + "']"));
      }
      return index;
    },
    _destroy: function() {
      if (this.xhr) {
        this.xhr.abort();
      }
      this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible");
      this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role");
      this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId();
      this.tablist.unbind(this.eventNamespace);
      this.tabs.add(this.panels).each(function() {
        if ($.data(this, "ui-tabs-destroy")) {
          $(this).remove();
        } else {
          $(this).removeClass("ui-state-default ui-state-active ui-state-disabled " + "ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role");
        }
      });
      this.tabs.each(function() {
        var li = $(this),
            prev = li.data("ui-tabs-aria-controls");
        if (prev) {
          li.attr("aria-controls", prev).removeData("ui-tabs-aria-controls");
        } else {
          li.removeAttr("aria-controls");
        }
      });
      this.panels.show();
      if (this.options.heightStyle !== "content") {
        this.panels.css("height", "");
      }
    },
    enable: function(index) {
      var disabled = this.options.disabled;
      if (disabled === false) {
        return;
      }
      if (index === undefined) {
        disabled = false;
      } else {
        index = this._getIndex(index);
        if ($.isArray(disabled)) {
          disabled = $.map(disabled, function(num) {
            return num !== index ? num : null;
          });
        } else {
          disabled = $.map(this.tabs, function(li, num) {
            return num !== index ? num : null;
          });
        }
      }
      this._setupDisabled(disabled);
    },
    disable: function(index) {
      var disabled = this.options.disabled;
      if (disabled === true) {
        return;
      }
      if (index === undefined) {
        disabled = true;
      } else {
        index = this._getIndex(index);
        if ($.inArray(index, disabled) !== -1) {
          return;
        }
        if ($.isArray(disabled)) {
          disabled = $.merge([index], disabled).sort();
        } else {
          disabled = [index];
        }
      }
      this._setupDisabled(disabled);
    },
    load: function(index, event) {
      index = this._getIndex(index);
      var that = this,
          tab = this.tabs.eq(index),
          anchor = tab.find(".ui-tabs-anchor"),
          panel = this._getPanelForTab(tab),
          eventData = {
            tab: tab,
            panel: panel
          },
          complete = function(jqXHR, status) {
            if (status === "abort") {
              that.panels.stop(false, true);
            }
            tab.removeClass("ui-tabs-loading");
            panel.removeAttr("aria-busy");
            if (jqXHR === that.xhr) {
              delete that.xhr;
            }
          };
      if (this._isLocal(anchor[0])) {
        return;
      }
      this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));
      if (this.xhr && this.xhr.statusText !== "canceled") {
        tab.addClass("ui-tabs-loading");
        panel.attr("aria-busy", "true");
        this.xhr.done(function(response, status, jqXHR) {
          setTimeout(function() {
            panel.html(response);
            that._trigger("load", event, eventData);
            complete(jqXHR, status);
          }, 1);
        }).fail(function(jqXHR, status) {
          setTimeout(function() {
            complete(jqXHR, status);
          }, 1);
        });
      }
    },
    _ajaxSettings: function(anchor, event, eventData) {
      var that = this;
      return {
        url: anchor.attr("href"),
        beforeSend: function(jqXHR, settings) {
          return that._trigger("beforeLoad", event, $.extend({
            jqXHR: jqXHR,
            ajaxSettings: settings
          }, eventData));
        }
      };
    },
    _getPanelForTab: function(tab) {
      var id = $(tab).attr("aria-controls");
      return this.element.find(this._sanitizeSelector("#" + id));
    }
  });
}));

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
(function(factory) {
  if (typeof define === "function" && define.amd) {
    define("a2", ["84"], factory);
  } else {
    factory(jQuery);
  }
}(function($) {
  $.ui = $.ui || {};
  $.extend($.ui, {
    version: "1.11.4",
    keyCode: {
      BACKSPACE: 8,
      COMMA: 188,
      DELETE: 46,
      DOWN: 40,
      END: 35,
      ENTER: 13,
      ESCAPE: 27,
      HOME: 36,
      LEFT: 37,
      PAGE_DOWN: 34,
      PAGE_UP: 33,
      PERIOD: 190,
      RIGHT: 39,
      SPACE: 32,
      TAB: 9,
      UP: 38
    }
  });
  $.fn.extend({
    scrollParent: function(includeHidden) {
      var position = this.css("position"),
          excludeStaticParent = position === "absolute",
          overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
          scrollParent = this.parents().filter(function() {
            var parent = $(this);
            if (excludeStaticParent && parent.css("position") === "static") {
              return false;
            }
            return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
          }).eq(0);
      return position === "fixed" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
    },
    uniqueId: (function() {
      var uuid = 0;
      return function() {
        return this.each(function() {
          if (!this.id) {
            this.id = "ui-id-" + (++uuid);
          }
        });
      };
    })(),
    removeUniqueId: function() {
      return this.each(function() {
        if (/^ui-id-\d+$/.test(this.id)) {
          $(this).removeAttr("id");
        }
      });
    }
  });
  function focusable(element, isTabIndexNotNaN) {
    var map,
        mapName,
        img,
        nodeName = element.nodeName.toLowerCase();
    if ("area" === nodeName) {
      map = element.parentNode;
      mapName = map.name;
      if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
        return false;
      }
      img = $("img[usemap='#" + mapName + "']")[0];
      return !!img && visible(img);
    }
    return (/^(input|select|textarea|button|object)$/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
  }
  function visible(element) {
    return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function() {
      return $.css(this, "visibility") === "hidden";
    }).length;
  }
  $.extend($.expr[":"], {
    data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
      return function(elem) {
        return !!$.data(elem, dataName);
      };
    }) : function(elem, i, match) {
      return !!$.data(elem, match[3]);
    },
    focusable: function(element) {
      return focusable(element, !isNaN($.attr(element, "tabindex")));
    },
    tabbable: function(element) {
      var tabIndex = $.attr(element, "tabindex"),
          isTabIndexNaN = isNaN(tabIndex);
      return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
    }
  });
  if (!$("<a>").outerWidth(1).jquery) {
    $.each(["Width", "Height"], function(i, name) {
      var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
          type = name.toLowerCase(),
          orig = {
            innerWidth: $.fn.innerWidth,
            innerHeight: $.fn.innerHeight,
            outerWidth: $.fn.outerWidth,
            outerHeight: $.fn.outerHeight
          };
      function reduce(elem, size, border, margin) {
        $.each(side, function() {
          size -= parseFloat($.css(elem, "padding" + this)) || 0;
          if (border) {
            size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
          }
          if (margin) {
            size -= parseFloat($.css(elem, "margin" + this)) || 0;
          }
        });
        return size;
      }
      $.fn["inner" + name] = function(size) {
        if (size === undefined) {
          return orig["inner" + name].call(this);
        }
        return this.each(function() {
          $(this).css(type, reduce(this, size) + "px");
        });
      };
      $.fn["outer" + name] = function(size, margin) {
        if (typeof size !== "number") {
          return orig["outer" + name].call(this, size);
        }
        return this.each(function() {
          $(this).css(type, reduce(this, size, true, margin) + "px");
        });
      };
    });
  }
  if (!$.fn.addBack) {
    $.fn.addBack = function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    };
  }
  if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
    $.fn.removeData = (function(removeData) {
      return function(key) {
        if (arguments.length) {
          return removeData.call(this, $.camelCase(key));
        } else {
          return removeData.call(this);
        }
      };
    })($.fn.removeData);
  }
  $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
  $.fn.extend({
    focus: (function(orig) {
      return function(delay, fn) {
        return typeof delay === "number" ? this.each(function() {
          var elem = this;
          setTimeout(function() {
            $(elem).focus();
            if (fn) {
              fn.call(elem);
            }
          }, delay);
        }) : orig.apply(this, arguments);
      };
    })($.fn.focus),
    disableSelection: (function() {
      var eventType = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
      return function() {
        return this.bind(eventType + ".ui-disableSelection", function(event) {
          event.preventDefault();
        });
      };
    })(),
    enableSelection: function() {
      return this.unbind(".ui-disableSelection");
    },
    zIndex: function(zIndex) {
      if (zIndex !== undefined) {
        return this.css("zIndex", zIndex);
      }
      if (this.length) {
        var elem = $(this[0]),
            position,
            value;
        while (elem.length && elem[0] !== document) {
          position = elem.css("position");
          if (position === "absolute" || position === "relative" || position === "fixed") {
            value = parseInt(elem.css("zIndex"), 10);
            if (!isNaN(value) && value !== 0) {
              return value;
            }
          }
          elem = elem.parent();
        }
      }
      return 0;
    }
  });
  $.ui.plugin = {
    add: function(module, option, set) {
      var i,
          proto = $.ui[module].prototype;
      for (i in set) {
        proto.plugins[i] = proto.plugins[i] || [];
        proto.plugins[i].push([option, set[i]]);
      }
    },
    call: function(instance, name, args, allowDisconnected) {
      var i,
          set = instance.plugins[name];
      if (!set) {
        return;
      }
      if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
        return;
      }
      for (i = 0; i < set.length; i++) {
        if (instance.options[set[i][0]]) {
          set[i][1].apply(instance.element, args);
        }
      }
    }
  };
}));

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
(function(factory) {
  if (typeof define === "function" && define.amd) {
    define("a4", ["84", "a3"], factory);
  } else {
    factory(jQuery);
  }
}(function($) {
  var mouseHandled = false;
  $(document).mouseup(function() {
    mouseHandled = false;
  });
  return $.widget("ui.mouse", {
    version: "1.11.4",
    options: {
      cancel: "input,textarea,button,select,option",
      distance: 1,
      delay: 0
    },
    _mouseInit: function() {
      var that = this;
      this.element.bind("mousedown." + this.widgetName, function(event) {
        return that._mouseDown(event);
      }).bind("click." + this.widgetName, function(event) {
        if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
          $.removeData(event.target, that.widgetName + ".preventClickEvent");
          event.stopImmediatePropagation();
          return false;
        }
      });
      this.started = false;
    },
    _mouseDestroy: function() {
      this.element.unbind("." + this.widgetName);
      if (this._mouseMoveDelegate) {
        this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
      }
    },
    _mouseDown: function(event) {
      if (mouseHandled) {
        return;
      }
      this._mouseMoved = false;
      (this._mouseStarted && this._mouseUp(event));
      this._mouseDownEvent = event;
      var that = this,
          btnIsLeft = (event.which === 1),
          elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
      if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
        return true;
      }
      this.mouseDelayMet = !this.options.delay;
      if (!this.mouseDelayMet) {
        this._mouseDelayTimer = setTimeout(function() {
          that.mouseDelayMet = true;
        }, this.options.delay);
      }
      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = (this._mouseStart(event) !== false);
        if (!this._mouseStarted) {
          event.preventDefault();
          return true;
        }
      }
      if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
        $.removeData(event.target, this.widgetName + ".preventClickEvent");
      }
      this._mouseMoveDelegate = function(event) {
        return that._mouseMove(event);
      };
      this._mouseUpDelegate = function(event) {
        return that._mouseUp(event);
      };
      this.document.bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate);
      event.preventDefault();
      mouseHandled = true;
      return true;
    },
    _mouseMove: function(event) {
      if (this._mouseMoved) {
        if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
          return this._mouseUp(event);
        } else if (!event.which) {
          return this._mouseUp(event);
        }
      }
      if (event.which || event.button) {
        this._mouseMoved = true;
      }
      if (this._mouseStarted) {
        this._mouseDrag(event);
        return event.preventDefault();
      }
      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = (this._mouseStart(this._mouseDownEvent, event) !== false);
        (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
      }
      return !this._mouseStarted;
    },
    _mouseUp: function(event) {
      this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
      if (this._mouseStarted) {
        this._mouseStarted = false;
        if (event.target === this._mouseDownEvent.target) {
          $.data(event.target, this.widgetName + ".preventClickEvent", true);
        }
        this._mouseStop(event);
      }
      mouseHandled = false;
      return false;
    },
    _mouseDistanceMet: function(event) {
      return (Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance);
    },
    _mouseDelayMet: function() {
      return this.mouseDelayMet;
    },
    _mouseStart: function() {},
    _mouseDrag: function() {},
    _mouseStop: function() {},
    _mouseCapture: function() {
      return true;
    }
  });
}));

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
(function(factory) {
  if (typeof define === "function" && define.amd) {
    define("a3", ["84"], factory);
  } else {
    factory(jQuery);
  }
}(function($) {
  var widget_uuid = 0,
      widget_slice = Array.prototype.slice;
  $.cleanData = (function(orig) {
    return function(elems) {
      var events,
          elem,
          i;
      for (i = 0; (elem = elems[i]) != null; i++) {
        try {
          events = $._data(elem, "events");
          if (events && events.remove) {
            $(elem).triggerHandler("remove");
          }
        } catch (e) {}
      }
      orig(elems);
    };
  })($.cleanData);
  $.widget = function(name, base, prototype) {
    var fullName,
        existingConstructor,
        constructor,
        basePrototype,
        proxiedPrototype = {},
        namespace = name.split(".")[0];
    name = name.split(".")[1];
    fullName = namespace + "-" + name;
    if (!prototype) {
      prototype = base;
      base = $.Widget;
    }
    $.expr[":"][fullName.toLowerCase()] = function(elem) {
      return !!$.data(elem, fullName);
    };
    $[namespace] = $[namespace] || {};
    existingConstructor = $[namespace][name];
    constructor = $[namespace][name] = function(options, element) {
      if (!this._createWidget) {
        return new constructor(options, element);
      }
      if (arguments.length) {
        this._createWidget(options, element);
      }
    };
    $.extend(constructor, existingConstructor, {
      version: prototype.version,
      _proto: $.extend({}, prototype),
      _childConstructors: []
    });
    basePrototype = new base();
    basePrototype.options = $.widget.extend({}, basePrototype.options);
    $.each(prototype, function(prop, value) {
      if (!$.isFunction(value)) {
        proxiedPrototype[prop] = value;
        return;
      }
      proxiedPrototype[prop] = (function() {
        var _super = function() {
          return base.prototype[prop].apply(this, arguments);
        },
            _superApply = function(args) {
              return base.prototype[prop].apply(this, args);
            };
        return function() {
          var __super = this._super,
              __superApply = this._superApply,
              returnValue;
          this._super = _super;
          this._superApply = _superApply;
          returnValue = value.apply(this, arguments);
          this._super = __super;
          this._superApply = __superApply;
          return returnValue;
        };
      })();
    });
    constructor.prototype = $.widget.extend(basePrototype, {widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name}, proxiedPrototype, {
      constructor: constructor,
      namespace: namespace,
      widgetName: name,
      widgetFullName: fullName
    });
    if (existingConstructor) {
      $.each(existingConstructor._childConstructors, function(i, child) {
        var childPrototype = child.prototype;
        $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
      });
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push(constructor);
    }
    $.widget.bridge(name, constructor);
    return constructor;
  };
  $.widget.extend = function(target) {
    var input = widget_slice.call(arguments, 1),
        inputIndex = 0,
        inputLength = input.length,
        key,
        value;
    for (; inputIndex < inputLength; inputIndex++) {
      for (key in input[inputIndex]) {
        value = input[inputIndex][key];
        if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
          if ($.isPlainObject(value)) {
            target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value);
          } else {
            target[key] = value;
          }
        }
      }
    }
    return target;
  };
  $.widget.bridge = function(name, object) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[name] = function(options) {
      var isMethodCall = typeof options === "string",
          args = widget_slice.call(arguments, 1),
          returnValue = this;
      if (isMethodCall) {
        this.each(function() {
          var methodValue,
              instance = $.data(this, fullName);
          if (options === "instance") {
            returnValue = instance;
            return false;
          }
          if (!instance) {
            return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
          }
          if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
            return $.error("no such method '" + options + "' for " + name + " widget instance");
          }
          methodValue = instance[options].apply(instance, args);
          if (methodValue !== instance && methodValue !== undefined) {
            returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
            return false;
          }
        });
      } else {
        if (args.length) {
          options = $.widget.extend.apply(null, [options].concat(args));
        }
        this.each(function() {
          var instance = $.data(this, fullName);
          if (instance) {
            instance.option(options || {});
            if (instance._init) {
              instance._init();
            }
          } else {
            $.data(this, fullName, new object(options, this));
          }
        });
      }
      return returnValue;
    };
  };
  $.Widget = function() {};
  $.Widget._childConstructors = [];
  $.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",
    options: {
      disabled: false,
      create: null
    },
    _createWidget: function(options, element) {
      element = $(element || this.defaultElement || this)[0];
      this.element = $(element);
      this.uuid = widget_uuid++;
      this.eventNamespace = "." + this.widgetName + this.uuid;
      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();
      if (element !== this) {
        $.data(element, this.widgetFullName, this);
        this._on(true, this.element, {remove: function(event) {
            if (event.target === element) {
              this.destroy();
            }
          }});
        this.document = $(element.style ? element.ownerDocument : element.document || element);
        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
      }
      this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
      this._create();
      this._trigger("create", null, this._getCreateEventData());
      this._init();
    },
    _getCreateOptions: $.noop,
    _getCreateEventData: $.noop,
    _create: $.noop,
    _init: $.noop,
    destroy: function() {
      this._destroy();
      this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName));
      this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled " + "ui-state-disabled");
      this.bindings.unbind(this.eventNamespace);
      this.hoverable.removeClass("ui-state-hover");
      this.focusable.removeClass("ui-state-focus");
    },
    _destroy: $.noop,
    widget: function() {
      return this.element;
    },
    option: function(key, value) {
      var options = key,
          parts,
          curOption,
          i;
      if (arguments.length === 0) {
        return $.widget.extend({}, this.options);
      }
      if (typeof key === "string") {
        options = {};
        parts = key.split(".");
        key = parts.shift();
        if (parts.length) {
          curOption = options[key] = $.widget.extend({}, this.options[key]);
          for (i = 0; i < parts.length - 1; i++) {
            curOption[parts[i]] = curOption[parts[i]] || {};
            curOption = curOption[parts[i]];
          }
          key = parts.pop();
          if (arguments.length === 1) {
            return curOption[key] === undefined ? null : curOption[key];
          }
          curOption[key] = value;
        } else {
          if (arguments.length === 1) {
            return this.options[key] === undefined ? null : this.options[key];
          }
          options[key] = value;
        }
      }
      this._setOptions(options);
      return this;
    },
    _setOptions: function(options) {
      var key;
      for (key in options) {
        this._setOption(key, options[key]);
      }
      return this;
    },
    _setOption: function(key, value) {
      this.options[key] = value;
      if (key === "disabled") {
        this.widget().toggleClass(this.widgetFullName + "-disabled", !!value);
        if (value) {
          this.hoverable.removeClass("ui-state-hover");
          this.focusable.removeClass("ui-state-focus");
        }
      }
      return this;
    },
    enable: function() {
      return this._setOptions({disabled: false});
    },
    disable: function() {
      return this._setOptions({disabled: true});
    },
    _on: function(suppressDisabledCheck, element, handlers) {
      var delegateElement,
          instance = this;
      if (typeof suppressDisabledCheck !== "boolean") {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }
      if (!handlers) {
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        element = delegateElement = $(element);
        this.bindings = this.bindings.add(element);
      }
      $.each(handlers, function(event, handler) {
        function handlerProxy() {
          if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
            return;
          }
          return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
        }
        if (typeof handler !== "string") {
          handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
        }
        var match = event.match(/^([\w:-]*)\s*(.*)$/),
            eventName = match[1] + instance.eventNamespace,
            selector = match[2];
        if (selector) {
          delegateElement.delegate(selector, eventName, handlerProxy);
        } else {
          element.bind(eventName, handlerProxy);
        }
      });
    },
    _off: function(element, eventName) {
      eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
      element.unbind(eventName).undelegate(eventName);
      this.bindings = $(this.bindings.not(element).get());
      this.focusable = $(this.focusable.not(element).get());
      this.hoverable = $(this.hoverable.not(element).get());
    },
    _delay: function(handler, delay) {
      function handlerProxy() {
        return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
      }
      var instance = this;
      return setTimeout(handlerProxy, delay || 0);
    },
    _hoverable: function(element) {
      this.hoverable = this.hoverable.add(element);
      this._on(element, {
        mouseenter: function(event) {
          $(event.currentTarget).addClass("ui-state-hover");
        },
        mouseleave: function(event) {
          $(event.currentTarget).removeClass("ui-state-hover");
        }
      });
    },
    _focusable: function(element) {
      this.focusable = this.focusable.add(element);
      this._on(element, {
        focusin: function(event) {
          $(event.currentTarget).addClass("ui-state-focus");
        },
        focusout: function(event) {
          $(event.currentTarget).removeClass("ui-state-focus");
        }
      });
    },
    _trigger: function(type, event, data) {
      var prop,
          orig,
          callback = this.options[type];
      data = data || {};
      event = $.Event(event);
      event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
      event.target = this.element[0];
      orig = event.originalEvent;
      if (orig) {
        for (prop in orig) {
          if (!(prop in event)) {
            event[prop] = orig[prop];
          }
        }
      }
      this.element.trigger(event, data);
      return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
    }
  };
  $.each({
    show: "fadeIn",
    hide: "fadeOut"
  }, function(method, defaultEffect) {
    $.Widget.prototype["_" + method] = function(element, options, callback) {
      if (typeof options === "string") {
        options = {effect: options};
      }
      var hasOptions,
          effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
      options = options || {};
      if (typeof options === "number") {
        options = {duration: options};
      }
      hasOptions = !$.isEmptyObject(options);
      options.complete = callback;
      if (options.delay) {
        element.delay(options.delay);
      }
      if (hasOptions && $.effects && $.effects.effect[effectName]) {
        element[method](options);
      } else if (effectName !== method && element[effectName]) {
        element[effectName](options.duration, options.easing, callback);
      } else {
        element.queue(function(next) {
          $(this)[method]();
          if (callback) {
            callback.call(element[0]);
          }
          next();
        });
      }
    };
  });
  return $.widget;
}));

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
(function(factory) {
  if (typeof define === "function" && define.amd) {
    define("a5", ["84", "a2", "a4", "a3"], factory);
  } else {
    factory(jQuery);
  }
}(function($) {
  return $.widget("ui.slider", $.ui.mouse, {
    version: "1.11.4",
    widgetEventPrefix: "slide",
    options: {
      animate: false,
      distance: 0,
      max: 100,
      min: 0,
      orientation: "horizontal",
      range: false,
      step: 1,
      value: 0,
      values: null,
      change: null,
      slide: null,
      start: null,
      stop: null
    },
    numPages: 5,
    _create: function() {
      this._keySliding = false;
      this._mouseSliding = false;
      this._animateOff = true;
      this._handleIndex = null;
      this._detectOrientation();
      this._mouseInit();
      this._calculateNewMax();
      this.element.addClass("ui-slider" + " ui-slider-" + this.orientation + " ui-widget" + " ui-widget-content" + " ui-corner-all");
      this._refresh();
      this._setOption("disabled", this.options.disabled);
      this._animateOff = false;
    },
    _refresh: function() {
      this._createRange();
      this._createHandles();
      this._setupEvents();
      this._refreshValue();
    },
    _createHandles: function() {
      var i,
          handleCount,
          options = this.options,
          existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),
          handle = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",
          handles = [];
      handleCount = (options.values && options.values.length) || 1;
      if (existingHandles.length > handleCount) {
        existingHandles.slice(handleCount).remove();
        existingHandles = existingHandles.slice(0, handleCount);
      }
      for (i = existingHandles.length; i < handleCount; i++) {
        handles.push(handle);
      }
      this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));
      this.handle = this.handles.eq(0);
      this.handles.each(function(i) {
        $(this).data("ui-slider-handle-index", i);
      });
    },
    _createRange: function() {
      var options = this.options,
          classes = "";
      if (options.range) {
        if (options.range === true) {
          if (!options.values) {
            options.values = [this._valueMin(), this._valueMin()];
          } else if (options.values.length && options.values.length !== 2) {
            options.values = [options.values[0], options.values[0]];
          } else if ($.isArray(options.values)) {
            options.values = options.values.slice(0);
          }
        }
        if (!this.range || !this.range.length) {
          this.range = $("<div></div>").appendTo(this.element);
          classes = "ui-slider-range" + " ui-widget-header ui-corner-all";
        } else {
          this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({
            "left": "",
            "bottom": ""
          });
        }
        this.range.addClass(classes + ((options.range === "min" || options.range === "max") ? " ui-slider-range-" + options.range : ""));
      } else {
        if (this.range) {
          this.range.remove();
        }
        this.range = null;
      }
    },
    _setupEvents: function() {
      this._off(this.handles);
      this._on(this.handles, this._handleEvents);
      this._hoverable(this.handles);
      this._focusable(this.handles);
    },
    _destroy: function() {
      this.handles.remove();
      if (this.range) {
        this.range.remove();
      }
      this.element.removeClass("ui-slider" + " ui-slider-horizontal" + " ui-slider-vertical" + " ui-widget" + " ui-widget-content" + " ui-corner-all");
      this._mouseDestroy();
    },
    _mouseCapture: function(event) {
      var position,
          normValue,
          distance,
          closestHandle,
          index,
          allowed,
          offset,
          mouseOverHandle,
          that = this,
          o = this.options;
      if (o.disabled) {
        return false;
      }
      this.elementSize = {
        width: this.element.outerWidth(),
        height: this.element.outerHeight()
      };
      this.elementOffset = this.element.offset();
      position = {
        x: event.pageX,
        y: event.pageY
      };
      normValue = this._normValueFromMouse(position);
      distance = this._valueMax() - this._valueMin() + 1;
      this.handles.each(function(i) {
        var thisDistance = Math.abs(normValue - that.values(i));
        if ((distance > thisDistance) || (distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min))) {
          distance = thisDistance;
          closestHandle = $(this);
          index = i;
        }
      });
      allowed = this._start(event, index);
      if (allowed === false) {
        return false;
      }
      this._mouseSliding = true;
      this._handleIndex = index;
      closestHandle.addClass("ui-state-active").focus();
      offset = closestHandle.offset();
      mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
      this._clickOffset = mouseOverHandle ? {
        left: 0,
        top: 0
      } : {
        left: event.pageX - offset.left - (closestHandle.width() / 2),
        top: event.pageY - offset.top - (closestHandle.height() / 2) - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
      };
      if (!this.handles.hasClass("ui-state-hover")) {
        this._slide(event, index, normValue);
      }
      this._animateOff = true;
      return true;
    },
    _mouseStart: function() {
      return true;
    },
    _mouseDrag: function(event) {
      var position = {
        x: event.pageX,
        y: event.pageY
      },
          normValue = this._normValueFromMouse(position);
      this._slide(event, this._handleIndex, normValue);
      return false;
    },
    _mouseStop: function(event) {
      this.handles.removeClass("ui-state-active");
      this._mouseSliding = false;
      this._stop(event, this._handleIndex);
      this._change(event, this._handleIndex);
      this._handleIndex = null;
      this._clickOffset = null;
      this._animateOff = false;
      return false;
    },
    _detectOrientation: function() {
      this.orientation = (this.options.orientation === "vertical") ? "vertical" : "horizontal";
    },
    _normValueFromMouse: function(position) {
      var pixelTotal,
          pixelMouse,
          percentMouse,
          valueTotal,
          valueMouse;
      if (this.orientation === "horizontal") {
        pixelTotal = this.elementSize.width;
        pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
      } else {
        pixelTotal = this.elementSize.height;
        pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
      }
      percentMouse = (pixelMouse / pixelTotal);
      if (percentMouse > 1) {
        percentMouse = 1;
      }
      if (percentMouse < 0) {
        percentMouse = 0;
      }
      if (this.orientation === "vertical") {
        percentMouse = 1 - percentMouse;
      }
      valueTotal = this._valueMax() - this._valueMin();
      valueMouse = this._valueMin() + percentMouse * valueTotal;
      return this._trimAlignValue(valueMouse);
    },
    _start: function(event, index) {
      var uiHash = {
        handle: this.handles[index],
        value: this.value()
      };
      if (this.options.values && this.options.values.length) {
        uiHash.value = this.values(index);
        uiHash.values = this.values();
      }
      return this._trigger("start", event, uiHash);
    },
    _slide: function(event, index, newVal) {
      var otherVal,
          newValues,
          allowed;
      if (this.options.values && this.options.values.length) {
        otherVal = this.values(index ? 0 : 1);
        if ((this.options.values.length === 2 && this.options.range === true) && ((index === 0 && newVal > otherVal) || (index === 1 && newVal < otherVal))) {
          newVal = otherVal;
        }
        if (newVal !== this.values(index)) {
          newValues = this.values();
          newValues[index] = newVal;
          allowed = this._trigger("slide", event, {
            handle: this.handles[index],
            value: newVal,
            values: newValues
          });
          otherVal = this.values(index ? 0 : 1);
          if (allowed !== false) {
            this.values(index, newVal);
          }
        }
      } else {
        if (newVal !== this.value()) {
          allowed = this._trigger("slide", event, {
            handle: this.handles[index],
            value: newVal
          });
          if (allowed !== false) {
            this.value(newVal);
          }
        }
      }
    },
    _stop: function(event, index) {
      var uiHash = {
        handle: this.handles[index],
        value: this.value()
      };
      if (this.options.values && this.options.values.length) {
        uiHash.value = this.values(index);
        uiHash.values = this.values();
      }
      this._trigger("stop", event, uiHash);
    },
    _change: function(event, index) {
      if (!this._keySliding && !this._mouseSliding) {
        var uiHash = {
          handle: this.handles[index],
          value: this.value()
        };
        if (this.options.values && this.options.values.length) {
          uiHash.value = this.values(index);
          uiHash.values = this.values();
        }
        this._lastChangedValue = index;
        this._trigger("change", event, uiHash);
      }
    },
    value: function(newValue) {
      if (arguments.length) {
        this.options.value = this._trimAlignValue(newValue);
        this._refreshValue();
        this._change(null, 0);
        return;
      }
      return this._value();
    },
    values: function(index, newValue) {
      var vals,
          newValues,
          i;
      if (arguments.length > 1) {
        this.options.values[index] = this._trimAlignValue(newValue);
        this._refreshValue();
        this._change(null, index);
        return;
      }
      if (arguments.length) {
        if ($.isArray(arguments[0])) {
          vals = this.options.values;
          newValues = arguments[0];
          for (i = 0; i < vals.length; i += 1) {
            vals[i] = this._trimAlignValue(newValues[i]);
            this._change(null, i);
          }
          this._refreshValue();
        } else {
          if (this.options.values && this.options.values.length) {
            return this._values(index);
          } else {
            return this.value();
          }
        }
      } else {
        return this._values();
      }
    },
    _setOption: function(key, value) {
      var i,
          valsLength = 0;
      if (key === "range" && this.options.range === true) {
        if (value === "min") {
          this.options.value = this._values(0);
          this.options.values = null;
        } else if (value === "max") {
          this.options.value = this._values(this.options.values.length - 1);
          this.options.values = null;
        }
      }
      if ($.isArray(this.options.values)) {
        valsLength = this.options.values.length;
      }
      if (key === "disabled") {
        this.element.toggleClass("ui-state-disabled", !!value);
      }
      this._super(key, value);
      switch (key) {
        case "orientation":
          this._detectOrientation();
          this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation);
          this._refreshValue();
          this.handles.css(value === "horizontal" ? "bottom" : "left", "");
          break;
        case "value":
          this._animateOff = true;
          this._refreshValue();
          this._change(null, 0);
          this._animateOff = false;
          break;
        case "values":
          this._animateOff = true;
          this._refreshValue();
          for (i = 0; i < valsLength; i += 1) {
            this._change(null, i);
          }
          this._animateOff = false;
          break;
        case "step":
        case "min":
        case "max":
          this._animateOff = true;
          this._calculateNewMax();
          this._refreshValue();
          this._animateOff = false;
          break;
        case "range":
          this._animateOff = true;
          this._refresh();
          this._animateOff = false;
          break;
      }
    },
    _value: function() {
      var val = this.options.value;
      val = this._trimAlignValue(val);
      return val;
    },
    _values: function(index) {
      var val,
          vals,
          i;
      if (arguments.length) {
        val = this.options.values[index];
        val = this._trimAlignValue(val);
        return val;
      } else if (this.options.values && this.options.values.length) {
        vals = this.options.values.slice();
        for (i = 0; i < vals.length; i += 1) {
          vals[i] = this._trimAlignValue(vals[i]);
        }
        return vals;
      } else {
        return [];
      }
    },
    _trimAlignValue: function(val) {
      if (val <= this._valueMin()) {
        return this._valueMin();
      }
      if (val >= this._valueMax()) {
        return this._valueMax();
      }
      var step = (this.options.step > 0) ? this.options.step : 1,
          valModStep = (val - this._valueMin()) % step,
          alignValue = val - valModStep;
      if (Math.abs(valModStep) * 2 >= step) {
        alignValue += (valModStep > 0) ? step : (-step);
      }
      return parseFloat(alignValue.toFixed(5));
    },
    _calculateNewMax: function() {
      var max = this.options.max,
          min = this._valueMin(),
          step = this.options.step,
          aboveMin = Math.floor((+(max - min).toFixed(this._precision())) / step) * step;
      max = aboveMin + min;
      this.max = parseFloat(max.toFixed(this._precision()));
    },
    _precision: function() {
      var precision = this._precisionOf(this.options.step);
      if (this.options.min !== null) {
        precision = Math.max(precision, this._precisionOf(this.options.min));
      }
      return precision;
    },
    _precisionOf: function(num) {
      var str = num.toString(),
          decimal = str.indexOf(".");
      return decimal === -1 ? 0 : str.length - decimal - 1;
    },
    _valueMin: function() {
      return this.options.min;
    },
    _valueMax: function() {
      return this.max;
    },
    _refreshValue: function() {
      var lastValPercent,
          valPercent,
          value,
          valueMin,
          valueMax,
          oRange = this.options.range,
          o = this.options,
          that = this,
          animate = (!this._animateOff) ? o.animate : false,
          _set = {};
      if (this.options.values && this.options.values.length) {
        this.handles.each(function(i) {
          valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
          _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
          $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
          if (that.options.range === true) {
            if (that.orientation === "horizontal") {
              if (i === 0) {
                that.range.stop(1, 1)[animate ? "animate" : "css"]({left: valPercent + "%"}, o.animate);
              }
              if (i === 1) {
                that.range[animate ? "animate" : "css"]({width: (valPercent - lastValPercent) + "%"}, {
                  queue: false,
                  duration: o.animate
                });
              }
            } else {
              if (i === 0) {
                that.range.stop(1, 1)[animate ? "animate" : "css"]({bottom: (valPercent) + "%"}, o.animate);
              }
              if (i === 1) {
                that.range[animate ? "animate" : "css"]({height: (valPercent - lastValPercent) + "%"}, {
                  queue: false,
                  duration: o.animate
                });
              }
            }
          }
          lastValPercent = valPercent;
        });
      } else {
        value = this.value();
        valueMin = this._valueMin();
        valueMax = this._valueMax();
        valPercent = (valueMax !== valueMin) ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;
        _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
        this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
        if (oRange === "min" && this.orientation === "horizontal") {
          this.range.stop(1, 1)[animate ? "animate" : "css"]({width: valPercent + "%"}, o.animate);
        }
        if (oRange === "max" && this.orientation === "horizontal") {
          this.range[animate ? "animate" : "css"]({width: (100 - valPercent) + "%"}, {
            queue: false,
            duration: o.animate
          });
        }
        if (oRange === "min" && this.orientation === "vertical") {
          this.range.stop(1, 1)[animate ? "animate" : "css"]({height: valPercent + "%"}, o.animate);
        }
        if (oRange === "max" && this.orientation === "vertical") {
          this.range[animate ? "animate" : "css"]({height: (100 - valPercent) + "%"}, {
            queue: false,
            duration: o.animate
          });
        }
      }
    },
    _handleEvents: {
      keydown: function(event) {
        var allowed,
            curVal,
            newVal,
            step,
            index = $(event.target).data("ui-slider-handle-index");
        switch (event.keyCode) {
          case $.ui.keyCode.HOME:
          case $.ui.keyCode.END:
          case $.ui.keyCode.PAGE_UP:
          case $.ui.keyCode.PAGE_DOWN:
          case $.ui.keyCode.UP:
          case $.ui.keyCode.RIGHT:
          case $.ui.keyCode.DOWN:
          case $.ui.keyCode.LEFT:
            event.preventDefault();
            if (!this._keySliding) {
              this._keySliding = true;
              $(event.target).addClass("ui-state-active");
              allowed = this._start(event, index);
              if (allowed === false) {
                return;
              }
            }
            break;
        }
        step = this.options.step;
        if (this.options.values && this.options.values.length) {
          curVal = newVal = this.values(index);
        } else {
          curVal = newVal = this.value();
        }
        switch (event.keyCode) {
          case $.ui.keyCode.HOME:
            newVal = this._valueMin();
            break;
          case $.ui.keyCode.END:
            newVal = this._valueMax();
            break;
          case $.ui.keyCode.PAGE_UP:
            newVal = this._trimAlignValue(curVal + ((this._valueMax() - this._valueMin()) / this.numPages));
            break;
          case $.ui.keyCode.PAGE_DOWN:
            newVal = this._trimAlignValue(curVal - ((this._valueMax() - this._valueMin()) / this.numPages));
            break;
          case $.ui.keyCode.UP:
          case $.ui.keyCode.RIGHT:
            if (curVal === this._valueMax()) {
              return;
            }
            newVal = this._trimAlignValue(curVal + step);
            break;
          case $.ui.keyCode.DOWN:
          case $.ui.keyCode.LEFT:
            if (curVal === this._valueMin()) {
              return;
            }
            newVal = this._trimAlignValue(curVal - step);
            break;
        }
        this._slide(event, index, newVal);
      },
      keyup: function(event) {
        var index = $(event.target).data("ui-slider-handle-index");
        if (this._keySliding) {
          this._keySliding = false;
          this._stop(event, index);
          this._change(event, index);
          $(event.target).removeClass("ui-state-active");
        }
      }
    }
  });
}));

_removeDefine();
})();
$__System.registerDynamic("a6", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(factory) {
    if (typeof define === 'function' && define.amd) {
      define(['jquery'], factory);
    } else if (typeof exports === 'object') {
      module.exports = factory;
    } else {
      factory(jQuery);
    }
  }(function($) {
    var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ('onwheel' in document || document.documentMode >= 9) ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice = Array.prototype.slice,
        nullLowestDeltaTimeout,
        lowestDelta;
    if ($.event.fixHooks) {
      for (var i = toFix.length; i; ) {
        $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
      }
    }
    var special = $.event.special.mousewheel = {
      version: '3.1.12',
      setup: function() {
        if (this.addEventListener) {
          for (var i = toBind.length; i; ) {
            this.addEventListener(toBind[--i], handler, false);
          }
        } else {
          this.onmousewheel = handler;
        }
        $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
        $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
      },
      teardown: function() {
        if (this.removeEventListener) {
          for (var i = toBind.length; i; ) {
            this.removeEventListener(toBind[--i], handler, false);
          }
        } else {
          this.onmousewheel = null;
        }
        $.removeData(this, 'mousewheel-line-height');
        $.removeData(this, 'mousewheel-page-height');
      },
      getLineHeight: function(elem) {
        var $elem = $(elem),
            $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
        if (!$parent.length) {
          $parent = $('body');
        }
        return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
      },
      getPageHeight: function(elem) {
        return $(elem).height();
      },
      settings: {
        adjustOldDeltas: true,
        normalizeOffset: true
      }
    };
    $.fn.extend({
      mousewheel: function(fn) {
        return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
      },
      unmousewheel: function(fn) {
        return this.unbind('mousewheel', fn);
      }
    });
    function handler(event) {
      var orgEvent = event || window.event,
          args = slice.call(arguments, 1),
          delta = 0,
          deltaX = 0,
          deltaY = 0,
          absDelta = 0,
          offsetX = 0,
          offsetY = 0;
      event = $.event.fix(orgEvent);
      event.type = 'mousewheel';
      if ('detail' in orgEvent) {
        deltaY = orgEvent.detail * -1;
      }
      if ('wheelDelta' in orgEvent) {
        deltaY = orgEvent.wheelDelta;
      }
      if ('wheelDeltaY' in orgEvent) {
        deltaY = orgEvent.wheelDeltaY;
      }
      if ('wheelDeltaX' in orgEvent) {
        deltaX = orgEvent.wheelDeltaX * -1;
      }
      if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
        deltaX = deltaY * -1;
        deltaY = 0;
      }
      delta = deltaY === 0 ? deltaX : deltaY;
      if ('deltaY' in orgEvent) {
        deltaY = orgEvent.deltaY * -1;
        delta = deltaY;
      }
      if ('deltaX' in orgEvent) {
        deltaX = orgEvent.deltaX;
        if (deltaY === 0) {
          delta = deltaX * -1;
        }
      }
      if (deltaY === 0 && deltaX === 0) {
        return;
      }
      if (orgEvent.deltaMode === 1) {
        var lineHeight = $.data(this, 'mousewheel-line-height');
        delta *= lineHeight;
        deltaY *= lineHeight;
        deltaX *= lineHeight;
      } else if (orgEvent.deltaMode === 2) {
        var pageHeight = $.data(this, 'mousewheel-page-height');
        delta *= pageHeight;
        deltaY *= pageHeight;
        deltaX *= pageHeight;
      }
      absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
      if (!lowestDelta || absDelta < lowestDelta) {
        lowestDelta = absDelta;
        if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
          lowestDelta /= 40;
        }
      }
      if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
        delta /= 40;
        deltaX /= 40;
        deltaY /= 40;
      }
      delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
      deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
      deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta);
      if (special.settings.normalizeOffset && this.getBoundingClientRect) {
        var boundingRect = this.getBoundingClientRect();
        offsetX = event.clientX - boundingRect.left;
        offsetY = event.clientY - boundingRect.top;
      }
      event.deltaX = deltaX;
      event.deltaY = deltaY;
      event.deltaFactor = lowestDelta;
      event.offsetX = offsetX;
      event.offsetY = offsetY;
      event.deltaMode = 0;
      args.unshift(event, delta, deltaX, deltaY);
      if (nullLowestDeltaTimeout) {
        clearTimeout(nullLowestDeltaTimeout);
      }
      nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
      return ($.event.dispatch || $.event.handle).apply(this, args);
    }
    function nullLowestDelta() {
      lowestDelta = null;
    }
    function shouldAdjustOldDeltas(orgEvent, absDelta) {
      return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }
  }));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a7", ["a6"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('a6');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a8", ["84"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(factory) {
    if (typeof define === 'function' && define.amd) {
      define(['jquery'], factory);
    } else if (typeof exports === 'object') {
      module.exports = factory($__require('84'));
    } else {
      factory(jQuery);
    }
  }(function($) {
    $.fn.jScrollPane = function(settings) {
      function JScrollPane(elem, s) {
        var settings,
            jsp = this,
            pane,
            paneWidth,
            paneHeight,
            container,
            contentWidth,
            contentHeight,
            percentInViewH,
            percentInViewV,
            isScrollableV,
            isScrollableH,
            verticalDrag,
            dragMaxY,
            verticalDragPosition,
            horizontalDrag,
            dragMaxX,
            horizontalDragPosition,
            verticalBar,
            verticalTrack,
            scrollbarWidth,
            verticalTrackHeight,
            verticalDragHeight,
            arrowUp,
            arrowDown,
            horizontalBar,
            horizontalTrack,
            horizontalTrackWidth,
            horizontalDragWidth,
            arrowLeft,
            arrowRight,
            reinitialiseInterval,
            originalPadding,
            originalPaddingTotalWidth,
            previousContentWidth,
            wasAtTop = true,
            wasAtLeft = true,
            wasAtBottom = false,
            wasAtRight = false,
            originalElement = elem.clone(false, false).empty(),
            mwEvent = $.fn.mwheelIntent ? 'mwheelIntent.jsp' : 'mousewheel.jsp';
        if (elem.css('box-sizing') === 'border-box') {
          originalPadding = 0;
          originalPaddingTotalWidth = 0;
        } else {
          originalPadding = elem.css('paddingTop') + ' ' + elem.css('paddingRight') + ' ' + elem.css('paddingBottom') + ' ' + elem.css('paddingLeft');
          originalPaddingTotalWidth = (parseInt(elem.css('paddingLeft'), 10) || 0) + (parseInt(elem.css('paddingRight'), 10) || 0);
        }
        function initialise(s) {
          var isMaintainingPositon,
              lastContentX,
              lastContentY,
              hasContainingSpaceChanged,
              originalScrollTop,
              originalScrollLeft,
              maintainAtBottom = false,
              maintainAtRight = false;
          settings = s;
          if (pane === undefined) {
            originalScrollTop = elem.scrollTop();
            originalScrollLeft = elem.scrollLeft();
            elem.css({
              overflow: 'hidden',
              padding: 0
            });
            paneWidth = elem.innerWidth() + originalPaddingTotalWidth;
            paneHeight = elem.innerHeight();
            elem.width(paneWidth);
            pane = $('<div class="jspPane" />').css('padding', originalPadding).append(elem.children());
            container = $('<div class="jspContainer" />').css({
              'width': paneWidth + 'px',
              'height': paneHeight + 'px'
            }).append(pane).appendTo(elem);
          } else {
            elem.css('width', '');
            maintainAtBottom = settings.stickToBottom && isCloseToBottom();
            maintainAtRight = settings.stickToRight && isCloseToRight();
            hasContainingSpaceChanged = elem.innerWidth() + originalPaddingTotalWidth != paneWidth || elem.outerHeight() != paneHeight;
            if (hasContainingSpaceChanged) {
              paneWidth = elem.innerWidth() + originalPaddingTotalWidth;
              paneHeight = elem.innerHeight();
              container.css({
                width: paneWidth + 'px',
                height: paneHeight + 'px'
              });
            }
            if (!hasContainingSpaceChanged && previousContentWidth == contentWidth && pane.outerHeight() == contentHeight) {
              elem.width(paneWidth);
              return;
            }
            previousContentWidth = contentWidth;
            pane.css('width', '');
            elem.width(paneWidth);
            container.find('>.jspVerticalBar,>.jspHorizontalBar').remove().end();
          }
          pane.css('overflow', 'auto');
          if (s.contentWidth) {
            contentWidth = s.contentWidth;
          } else {
            contentWidth = pane[0].scrollWidth;
          }
          contentHeight = pane[0].scrollHeight;
          pane.css('overflow', '');
          percentInViewH = contentWidth / paneWidth;
          percentInViewV = contentHeight / paneHeight;
          isScrollableV = percentInViewV > 1;
          isScrollableH = percentInViewH > 1;
          if (!(isScrollableH || isScrollableV)) {
            elem.removeClass('jspScrollable');
            pane.css({
              top: 0,
              left: 0,
              width: container.width() - originalPaddingTotalWidth
            });
            removeMousewheel();
            removeFocusHandler();
            removeKeyboardNav();
            removeClickOnTrack();
          } else {
            elem.addClass('jspScrollable');
            isMaintainingPositon = settings.maintainPosition && (verticalDragPosition || horizontalDragPosition);
            if (isMaintainingPositon) {
              lastContentX = contentPositionX();
              lastContentY = contentPositionY();
            }
            initialiseVerticalScroll();
            initialiseHorizontalScroll();
            resizeScrollbars();
            if (isMaintainingPositon) {
              scrollToX(maintainAtRight ? (contentWidth - paneWidth) : lastContentX, false);
              scrollToY(maintainAtBottom ? (contentHeight - paneHeight) : lastContentY, false);
            }
            initFocusHandler();
            initMousewheel();
            initTouch();
            if (settings.enableKeyboardNavigation) {
              initKeyboardNav();
            }
            if (settings.clickOnTrack) {
              initClickOnTrack();
            }
            observeHash();
            if (settings.hijackInternalLinks) {
              hijackInternalLinks();
            }
          }
          if (settings.autoReinitialise && !reinitialiseInterval) {
            reinitialiseInterval = setInterval(function() {
              initialise(settings);
            }, settings.autoReinitialiseDelay);
          } else if (!settings.autoReinitialise && reinitialiseInterval) {
            clearInterval(reinitialiseInterval);
          }
          originalScrollTop && elem.scrollTop(0) && scrollToY(originalScrollTop, false);
          originalScrollLeft && elem.scrollLeft(0) && scrollToX(originalScrollLeft, false);
          elem.trigger('jsp-initialised', [isScrollableH || isScrollableV]);
        }
        function initialiseVerticalScroll() {
          if (isScrollableV) {
            container.append($('<div class="jspVerticalBar" />').append($('<div class="jspCap jspCapTop" />'), $('<div class="jspTrack" />').append($('<div class="jspDrag" />').append($('<div class="jspDragTop" />'), $('<div class="jspDragBottom" />'))), $('<div class="jspCap jspCapBottom" />')));
            verticalBar = container.find('>.jspVerticalBar');
            verticalTrack = verticalBar.find('>.jspTrack');
            verticalDrag = verticalTrack.find('>.jspDrag');
            if (settings.showArrows) {
              arrowUp = $('<a class="jspArrow jspArrowUp" />').bind('mousedown.jsp', getArrowScroll(0, -1)).bind('click.jsp', nil);
              arrowDown = $('<a class="jspArrow jspArrowDown" />').bind('mousedown.jsp', getArrowScroll(0, 1)).bind('click.jsp', nil);
              if (settings.arrowScrollOnHover) {
                arrowUp.bind('mouseover.jsp', getArrowScroll(0, -1, arrowUp));
                arrowDown.bind('mouseover.jsp', getArrowScroll(0, 1, arrowDown));
              }
              appendArrows(verticalTrack, settings.verticalArrowPositions, arrowUp, arrowDown);
            }
            verticalTrackHeight = paneHeight;
            container.find('>.jspVerticalBar>.jspCap:visible,>.jspVerticalBar>.jspArrow').each(function() {
              verticalTrackHeight -= $(this).outerHeight();
            });
            verticalDrag.hover(function() {
              verticalDrag.addClass('jspHover');
            }, function() {
              verticalDrag.removeClass('jspHover');
            }).bind('mousedown.jsp', function(e) {
              $('html').bind('dragstart.jsp selectstart.jsp', nil);
              verticalDrag.addClass('jspActive');
              var startY = e.pageY - verticalDrag.position().top;
              $('html').bind('mousemove.jsp', function(e) {
                positionDragY(e.pageY - startY, false);
              }).bind('mouseup.jsp mouseleave.jsp', cancelDrag);
              return false;
            });
            sizeVerticalScrollbar();
          }
        }
        function sizeVerticalScrollbar() {
          verticalTrack.height(verticalTrackHeight + 'px');
          verticalDragPosition = 0;
          scrollbarWidth = settings.verticalGutter + verticalTrack.outerWidth();
          pane.width(paneWidth - scrollbarWidth - originalPaddingTotalWidth);
          try {
            if (verticalBar.position().left === 0) {
              pane.css('margin-left', scrollbarWidth + 'px');
            }
          } catch (err) {}
        }
        function initialiseHorizontalScroll() {
          if (isScrollableH) {
            container.append($('<div class="jspHorizontalBar" />').append($('<div class="jspCap jspCapLeft" />'), $('<div class="jspTrack" />').append($('<div class="jspDrag" />').append($('<div class="jspDragLeft" />'), $('<div class="jspDragRight" />'))), $('<div class="jspCap jspCapRight" />')));
            horizontalBar = container.find('>.jspHorizontalBar');
            horizontalTrack = horizontalBar.find('>.jspTrack');
            horizontalDrag = horizontalTrack.find('>.jspDrag');
            if (settings.showArrows) {
              arrowLeft = $('<a class="jspArrow jspArrowLeft" />').bind('mousedown.jsp', getArrowScroll(-1, 0)).bind('click.jsp', nil);
              arrowRight = $('<a class="jspArrow jspArrowRight" />').bind('mousedown.jsp', getArrowScroll(1, 0)).bind('click.jsp', nil);
              if (settings.arrowScrollOnHover) {
                arrowLeft.bind('mouseover.jsp', getArrowScroll(-1, 0, arrowLeft));
                arrowRight.bind('mouseover.jsp', getArrowScroll(1, 0, arrowRight));
              }
              appendArrows(horizontalTrack, settings.horizontalArrowPositions, arrowLeft, arrowRight);
            }
            horizontalDrag.hover(function() {
              horizontalDrag.addClass('jspHover');
            }, function() {
              horizontalDrag.removeClass('jspHover');
            }).bind('mousedown.jsp', function(e) {
              $('html').bind('dragstart.jsp selectstart.jsp', nil);
              horizontalDrag.addClass('jspActive');
              var startX = e.pageX - horizontalDrag.position().left;
              $('html').bind('mousemove.jsp', function(e) {
                positionDragX(e.pageX - startX, false);
              }).bind('mouseup.jsp mouseleave.jsp', cancelDrag);
              return false;
            });
            horizontalTrackWidth = container.innerWidth();
            sizeHorizontalScrollbar();
          }
        }
        function sizeHorizontalScrollbar() {
          container.find('>.jspHorizontalBar>.jspCap:visible,>.jspHorizontalBar>.jspArrow').each(function() {
            horizontalTrackWidth -= $(this).outerWidth();
          });
          horizontalTrack.width(horizontalTrackWidth + 'px');
          horizontalDragPosition = 0;
        }
        function resizeScrollbars() {
          if (isScrollableH && isScrollableV) {
            var horizontalTrackHeight = horizontalTrack.outerHeight(),
                verticalTrackWidth = verticalTrack.outerWidth();
            verticalTrackHeight -= horizontalTrackHeight;
            $(horizontalBar).find('>.jspCap:visible,>.jspArrow').each(function() {
              horizontalTrackWidth += $(this).outerWidth();
            });
            horizontalTrackWidth -= verticalTrackWidth;
            paneHeight -= verticalTrackWidth;
            paneWidth -= horizontalTrackHeight;
            horizontalTrack.parent().append($('<div class="jspCorner" />').css('width', horizontalTrackHeight + 'px'));
            sizeVerticalScrollbar();
            sizeHorizontalScrollbar();
          }
          if (isScrollableH) {
            pane.width((container.outerWidth() - originalPaddingTotalWidth) + 'px');
          }
          contentHeight = pane.outerHeight();
          percentInViewV = contentHeight / paneHeight;
          if (isScrollableH) {
            horizontalDragWidth = Math.ceil(1 / percentInViewH * horizontalTrackWidth);
            if (horizontalDragWidth > settings.horizontalDragMaxWidth) {
              horizontalDragWidth = settings.horizontalDragMaxWidth;
            } else if (horizontalDragWidth < settings.horizontalDragMinWidth) {
              horizontalDragWidth = settings.horizontalDragMinWidth;
            }
            horizontalDrag.width(horizontalDragWidth + 'px');
            dragMaxX = horizontalTrackWidth - horizontalDragWidth;
            _positionDragX(horizontalDragPosition);
          }
          if (isScrollableV) {
            verticalDragHeight = Math.ceil(1 / percentInViewV * verticalTrackHeight);
            if (verticalDragHeight > settings.verticalDragMaxHeight) {
              verticalDragHeight = settings.verticalDragMaxHeight;
            } else if (verticalDragHeight < settings.verticalDragMinHeight) {
              verticalDragHeight = settings.verticalDragMinHeight;
            }
            verticalDrag.height(verticalDragHeight + 'px');
            dragMaxY = verticalTrackHeight - verticalDragHeight;
            _positionDragY(verticalDragPosition);
          }
        }
        function appendArrows(ele, p, a1, a2) {
          var p1 = "before",
              p2 = "after",
              aTemp;
          if (p == "os") {
            p = /Mac/.test(navigator.platform) ? "after" : "split";
          }
          if (p == p1) {
            p2 = p;
          } else if (p == p2) {
            p1 = p;
            aTemp = a1;
            a1 = a2;
            a2 = aTemp;
          }
          ele[p1](a1)[p2](a2);
        }
        function getArrowScroll(dirX, dirY, ele) {
          return function() {
            arrowScroll(dirX, dirY, this, ele);
            this.blur();
            return false;
          };
        }
        function arrowScroll(dirX, dirY, arrow, ele) {
          arrow = $(arrow).addClass('jspActive');
          var eve,
              scrollTimeout,
              isFirst = true,
              doScroll = function() {
                if (dirX !== 0) {
                  jsp.scrollByX(dirX * settings.arrowButtonSpeed);
                }
                if (dirY !== 0) {
                  jsp.scrollByY(dirY * settings.arrowButtonSpeed);
                }
                scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.arrowRepeatFreq);
                isFirst = false;
              };
          doScroll();
          eve = ele ? 'mouseout.jsp' : 'mouseup.jsp';
          ele = ele || $('html');
          ele.bind(eve, function() {
            arrow.removeClass('jspActive');
            scrollTimeout && clearTimeout(scrollTimeout);
            scrollTimeout = null;
            ele.unbind(eve);
          });
        }
        function initClickOnTrack() {
          removeClickOnTrack();
          if (isScrollableV) {
            verticalTrack.bind('mousedown.jsp', function(e) {
              if (e.originalTarget === undefined || e.originalTarget == e.currentTarget) {
                var clickedTrack = $(this),
                    offset = clickedTrack.offset(),
                    direction = e.pageY - offset.top - verticalDragPosition,
                    scrollTimeout,
                    isFirst = true,
                    doScroll = function() {
                      var offset = clickedTrack.offset(),
                          pos = e.pageY - offset.top - verticalDragHeight / 2,
                          contentDragY = paneHeight * settings.scrollPagePercent,
                          dragY = dragMaxY * contentDragY / (contentHeight - paneHeight);
                      if (direction < 0) {
                        if (verticalDragPosition - dragY > pos) {
                          jsp.scrollByY(-contentDragY);
                        } else {
                          positionDragY(pos);
                        }
                      } else if (direction > 0) {
                        if (verticalDragPosition + dragY < pos) {
                          jsp.scrollByY(contentDragY);
                        } else {
                          positionDragY(pos);
                        }
                      } else {
                        cancelClick();
                        return;
                      }
                      scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.trackClickRepeatFreq);
                      isFirst = false;
                    },
                    cancelClick = function() {
                      scrollTimeout && clearTimeout(scrollTimeout);
                      scrollTimeout = null;
                      $(document).unbind('mouseup.jsp', cancelClick);
                    };
                doScroll();
                $(document).bind('mouseup.jsp', cancelClick);
                return false;
              }
            });
          }
          if (isScrollableH) {
            horizontalTrack.bind('mousedown.jsp', function(e) {
              if (e.originalTarget === undefined || e.originalTarget == e.currentTarget) {
                var clickedTrack = $(this),
                    offset = clickedTrack.offset(),
                    direction = e.pageX - offset.left - horizontalDragPosition,
                    scrollTimeout,
                    isFirst = true,
                    doScroll = function() {
                      var offset = clickedTrack.offset(),
                          pos = e.pageX - offset.left - horizontalDragWidth / 2,
                          contentDragX = paneWidth * settings.scrollPagePercent,
                          dragX = dragMaxX * contentDragX / (contentWidth - paneWidth);
                      if (direction < 0) {
                        if (horizontalDragPosition - dragX > pos) {
                          jsp.scrollByX(-contentDragX);
                        } else {
                          positionDragX(pos);
                        }
                      } else if (direction > 0) {
                        if (horizontalDragPosition + dragX < pos) {
                          jsp.scrollByX(contentDragX);
                        } else {
                          positionDragX(pos);
                        }
                      } else {
                        cancelClick();
                        return;
                      }
                      scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.trackClickRepeatFreq);
                      isFirst = false;
                    },
                    cancelClick = function() {
                      scrollTimeout && clearTimeout(scrollTimeout);
                      scrollTimeout = null;
                      $(document).unbind('mouseup.jsp', cancelClick);
                    };
                doScroll();
                $(document).bind('mouseup.jsp', cancelClick);
                return false;
              }
            });
          }
        }
        function removeClickOnTrack() {
          if (horizontalTrack) {
            horizontalTrack.unbind('mousedown.jsp');
          }
          if (verticalTrack) {
            verticalTrack.unbind('mousedown.jsp');
          }
        }
        function cancelDrag() {
          $('html').unbind('dragstart.jsp selectstart.jsp mousemove.jsp mouseup.jsp mouseleave.jsp');
          if (verticalDrag) {
            verticalDrag.removeClass('jspActive');
          }
          if (horizontalDrag) {
            horizontalDrag.removeClass('jspActive');
          }
        }
        function positionDragY(destY, animate) {
          if (!isScrollableV) {
            return;
          }
          if (destY < 0) {
            destY = 0;
          } else if (destY > dragMaxY) {
            destY = dragMaxY;
          }
          if (animate === undefined) {
            animate = settings.animateScroll;
          }
          if (animate) {
            jsp.animate(verticalDrag, 'top', destY, _positionDragY);
          } else {
            verticalDrag.css('top', destY);
            _positionDragY(destY);
          }
        }
        function _positionDragY(destY) {
          if (destY === undefined) {
            destY = verticalDrag.position().top;
          }
          container.scrollTop(0);
          verticalDragPosition = destY || 0;
          var isAtTop = verticalDragPosition === 0,
              isAtBottom = verticalDragPosition == dragMaxY,
              percentScrolled = destY / dragMaxY,
              destTop = -percentScrolled * (contentHeight - paneHeight);
          if (wasAtTop != isAtTop || wasAtBottom != isAtBottom) {
            wasAtTop = isAtTop;
            wasAtBottom = isAtBottom;
            elem.trigger('jsp-arrow-change', [wasAtTop, wasAtBottom, wasAtLeft, wasAtRight]);
          }
          updateVerticalArrows(isAtTop, isAtBottom);
          pane.css('top', destTop);
          elem.trigger('jsp-scroll-y', [-destTop, isAtTop, isAtBottom]).trigger('scroll');
        }
        function positionDragX(destX, animate) {
          if (!isScrollableH) {
            return;
          }
          if (destX < 0) {
            destX = 0;
          } else if (destX > dragMaxX) {
            destX = dragMaxX;
          }
          if (animate === undefined) {
            animate = settings.animateScroll;
          }
          if (animate) {
            jsp.animate(horizontalDrag, 'left', destX, _positionDragX);
          } else {
            horizontalDrag.css('left', destX);
            _positionDragX(destX);
          }
        }
        function _positionDragX(destX) {
          if (destX === undefined) {
            destX = horizontalDrag.position().left;
          }
          container.scrollTop(0);
          horizontalDragPosition = destX || 0;
          var isAtLeft = horizontalDragPosition === 0,
              isAtRight = horizontalDragPosition == dragMaxX,
              percentScrolled = destX / dragMaxX,
              destLeft = -percentScrolled * (contentWidth - paneWidth);
          if (wasAtLeft != isAtLeft || wasAtRight != isAtRight) {
            wasAtLeft = isAtLeft;
            wasAtRight = isAtRight;
            elem.trigger('jsp-arrow-change', [wasAtTop, wasAtBottom, wasAtLeft, wasAtRight]);
          }
          updateHorizontalArrows(isAtLeft, isAtRight);
          pane.css('left', destLeft);
          elem.trigger('jsp-scroll-x', [-destLeft, isAtLeft, isAtRight]).trigger('scroll');
        }
        function updateVerticalArrows(isAtTop, isAtBottom) {
          if (settings.showArrows) {
            arrowUp[isAtTop ? 'addClass' : 'removeClass']('jspDisabled');
            arrowDown[isAtBottom ? 'addClass' : 'removeClass']('jspDisabled');
          }
        }
        function updateHorizontalArrows(isAtLeft, isAtRight) {
          if (settings.showArrows) {
            arrowLeft[isAtLeft ? 'addClass' : 'removeClass']('jspDisabled');
            arrowRight[isAtRight ? 'addClass' : 'removeClass']('jspDisabled');
          }
        }
        function scrollToY(destY, animate) {
          var percentScrolled = destY / (contentHeight - paneHeight);
          positionDragY(percentScrolled * dragMaxY, animate);
        }
        function scrollToX(destX, animate) {
          var percentScrolled = destX / (contentWidth - paneWidth);
          positionDragX(percentScrolled * dragMaxX, animate);
        }
        function scrollToElement(ele, stickToTop, animate) {
          var e,
              eleHeight,
              eleWidth,
              eleTop = 0,
              eleLeft = 0,
              viewportTop,
              viewportLeft,
              maxVisibleEleTop,
              maxVisibleEleLeft,
              destY,
              destX;
          try {
            e = $(ele);
          } catch (err) {
            return;
          }
          eleHeight = e.outerHeight();
          eleWidth = e.outerWidth();
          container.scrollTop(0);
          container.scrollLeft(0);
          while (!e.is('.jspPane')) {
            eleTop += e.position().top;
            eleLeft += e.position().left;
            e = e.offsetParent();
            if (/^body|html$/i.test(e[0].nodeName)) {
              return;
            }
          }
          viewportTop = contentPositionY();
          maxVisibleEleTop = viewportTop + paneHeight;
          if (eleTop < viewportTop || stickToTop) {
            destY = eleTop - settings.horizontalGutter;
          } else if (eleTop + eleHeight > maxVisibleEleTop) {
            destY = eleTop - paneHeight + eleHeight + settings.horizontalGutter;
          }
          if (!isNaN(destY)) {
            scrollToY(destY, animate);
          }
          viewportLeft = contentPositionX();
          maxVisibleEleLeft = viewportLeft + paneWidth;
          if (eleLeft < viewportLeft || stickToTop) {
            destX = eleLeft - settings.horizontalGutter;
          } else if (eleLeft + eleWidth > maxVisibleEleLeft) {
            destX = eleLeft - paneWidth + eleWidth + settings.horizontalGutter;
          }
          if (!isNaN(destX)) {
            scrollToX(destX, animate);
          }
        }
        function contentPositionX() {
          return -pane.position().left;
        }
        function contentPositionY() {
          return -pane.position().top;
        }
        function isCloseToBottom() {
          var scrollableHeight = contentHeight - paneHeight;
          return (scrollableHeight > 20) && (scrollableHeight - contentPositionY() < 10);
        }
        function isCloseToRight() {
          var scrollableWidth = contentWidth - paneWidth;
          return (scrollableWidth > 20) && (scrollableWidth - contentPositionX() < 10);
        }
        function initMousewheel() {
          container.unbind(mwEvent).bind(mwEvent, function(event, delta, deltaX, deltaY) {
            if (!horizontalDragPosition)
              horizontalDragPosition = 0;
            if (!verticalDragPosition)
              verticalDragPosition = 0;
            var dX = horizontalDragPosition,
                dY = verticalDragPosition,
                factor = event.deltaFactor || settings.mouseWheelSpeed;
            jsp.scrollBy(deltaX * factor, -deltaY * factor, false);
            return dX == horizontalDragPosition && dY == verticalDragPosition;
          });
        }
        function removeMousewheel() {
          container.unbind(mwEvent);
        }
        function nil() {
          return false;
        }
        function initFocusHandler() {
          pane.find(':input,a').unbind('focus.jsp').bind('focus.jsp', function(e) {
            scrollToElement(e.target, false);
          });
        }
        function removeFocusHandler() {
          pane.find(':input,a').unbind('focus.jsp');
        }
        function initKeyboardNav() {
          var keyDown,
              elementHasScrolled,
              validParents = [];
          isScrollableH && validParents.push(horizontalBar[0]);
          isScrollableV && validParents.push(verticalBar[0]);
          pane.bind('focus.jsp', function() {
            elem.focus();
          });
          elem.attr('tabindex', 0).unbind('keydown.jsp keypress.jsp').bind('keydown.jsp', function(e) {
            if (e.target !== this && !(validParents.length && $(e.target).closest(validParents).length)) {
              return;
            }
            var dX = horizontalDragPosition,
                dY = verticalDragPosition;
            switch (e.keyCode) {
              case 40:
              case 38:
              case 34:
              case 32:
              case 33:
              case 39:
              case 37:
                keyDown = e.keyCode;
                keyDownHandler();
                break;
              case 35:
                scrollToY(contentHeight - paneHeight);
                keyDown = null;
                break;
              case 36:
                scrollToY(0);
                keyDown = null;
                break;
            }
            elementHasScrolled = e.keyCode == keyDown && dX != horizontalDragPosition || dY != verticalDragPosition;
            return !elementHasScrolled;
          }).bind('keypress.jsp', function(e) {
            if (e.keyCode == keyDown) {
              keyDownHandler();
            }
            if (e.target !== this && !(validParents.length && $(e.target).closest(validParents).length)) {
              return;
            }
            return !elementHasScrolled;
          });
          if (settings.hideFocus) {
            elem.css('outline', 'none');
            if ('hideFocus' in container[0]) {
              elem.attr('hideFocus', true);
            }
          } else {
            elem.css('outline', '');
            if ('hideFocus' in container[0]) {
              elem.attr('hideFocus', false);
            }
          }
          function keyDownHandler() {
            var dX = horizontalDragPosition,
                dY = verticalDragPosition;
            switch (keyDown) {
              case 40:
                jsp.scrollByY(settings.keyboardSpeed, false);
                break;
              case 38:
                jsp.scrollByY(-settings.keyboardSpeed, false);
                break;
              case 34:
              case 32:
                jsp.scrollByY(paneHeight * settings.scrollPagePercent, false);
                break;
              case 33:
                jsp.scrollByY(-paneHeight * settings.scrollPagePercent, false);
                break;
              case 39:
                jsp.scrollByX(settings.keyboardSpeed, false);
                break;
              case 37:
                jsp.scrollByX(-settings.keyboardSpeed, false);
                break;
            }
            elementHasScrolled = dX != horizontalDragPosition || dY != verticalDragPosition;
            return elementHasScrolled;
          }
        }
        function removeKeyboardNav() {
          elem.attr('tabindex', '-1').removeAttr('tabindex').unbind('keydown.jsp keypress.jsp');
          pane.unbind('.jsp');
        }
        function observeHash() {
          if (location.hash && location.hash.length > 1) {
            var e,
                retryInt,
                hash = escape(location.hash.substr(1));
            ;
            try {
              e = $('#' + hash + ', a[name="' + hash + '"]');
            } catch (err) {
              return;
            }
            if (e.length && pane.find(hash)) {
              if (container.scrollTop() === 0) {
                retryInt = setInterval(function() {
                  if (container.scrollTop() > 0) {
                    scrollToElement(e, true);
                    $(document).scrollTop(container.position().top);
                    clearInterval(retryInt);
                  }
                }, 50);
              } else {
                scrollToElement(e, true);
                $(document).scrollTop(container.position().top);
              }
            }
          }
        }
        function hijackInternalLinks() {
          if ($(document.body).data('jspHijack')) {
            return;
          }
          $(document.body).data('jspHijack', true);
          $(document.body).delegate('a[href*=#]', 'click', function(event) {
            var href = this.href.substr(0, this.href.indexOf('#')),
                locationHref = location.href,
                hash,
                element,
                container,
                jsp,
                scrollTop,
                elementTop;
            if (location.href.indexOf('#') !== -1) {
              locationHref = location.href.substr(0, location.href.indexOf('#'));
            }
            if (href !== locationHref) {
              return;
            }
            hash = escape(this.href.substr(this.href.indexOf('#') + 1));
            element;
            try {
              element = $('#' + hash + ', a[name="' + hash + '"]');
            } catch (e) {
              return;
            }
            if (!element.length) {
              return;
            }
            container = element.closest('.jspScrollable');
            jsp = container.data('jsp');
            jsp.scrollToElement(element, true);
            if (container[0].scrollIntoView) {
              scrollTop = $(window).scrollTop();
              elementTop = element.offset().top;
              if (elementTop < scrollTop || elementTop > scrollTop + $(window).height()) {
                container[0].scrollIntoView();
              }
            }
            event.preventDefault();
          });
        }
        function initTouch() {
          var startX,
              startY,
              touchStartX,
              touchStartY,
              moved,
              moving = false;
          container.unbind('touchstart.jsp touchmove.jsp touchend.jsp click.jsp-touchclick').bind('touchstart.jsp', function(e) {
            var touch = e.originalEvent.touches[0];
            startX = contentPositionX();
            startY = contentPositionY();
            touchStartX = touch.pageX;
            touchStartY = touch.pageY;
            moved = false;
            moving = true;
          }).bind('touchmove.jsp', function(ev) {
            if (!moving) {
              return;
            }
            var touchPos = ev.originalEvent.touches[0],
                dX = horizontalDragPosition,
                dY = verticalDragPosition;
            jsp.scrollTo(startX + touchStartX - touchPos.pageX, startY + touchStartY - touchPos.pageY);
            moved = moved || Math.abs(touchStartX - touchPos.pageX) > 5 || Math.abs(touchStartY - touchPos.pageY) > 5;
            return dX == horizontalDragPosition && dY == verticalDragPosition;
          }).bind('touchend.jsp', function(e) {
            moving = false;
          }).bind('click.jsp-touchclick', function(e) {
            if (moved) {
              moved = false;
              return false;
            }
          });
        }
        function destroy() {
          var currentY = contentPositionY(),
              currentX = contentPositionX();
          elem.removeClass('jspScrollable').unbind('.jsp');
          pane.unbind('.jsp');
          elem.replaceWith(originalElement.append(pane.children()));
          originalElement.scrollTop(currentY);
          originalElement.scrollLeft(currentX);
          if (reinitialiseInterval) {
            clearInterval(reinitialiseInterval);
          }
        }
        $.extend(jsp, {
          reinitialise: function(s) {
            s = $.extend({}, settings, s);
            initialise(s);
          },
          scrollToElement: function(ele, stickToTop, animate) {
            scrollToElement(ele, stickToTop, animate);
          },
          scrollTo: function(destX, destY, animate) {
            scrollToX(destX, animate);
            scrollToY(destY, animate);
          },
          scrollToX: function(destX, animate) {
            scrollToX(destX, animate);
          },
          scrollToY: function(destY, animate) {
            scrollToY(destY, animate);
          },
          scrollToPercentX: function(destPercentX, animate) {
            scrollToX(destPercentX * (contentWidth - paneWidth), animate);
          },
          scrollToPercentY: function(destPercentY, animate) {
            scrollToY(destPercentY * (contentHeight - paneHeight), animate);
          },
          scrollBy: function(deltaX, deltaY, animate) {
            jsp.scrollByX(deltaX, animate);
            jsp.scrollByY(deltaY, animate);
          },
          scrollByX: function(deltaX, animate) {
            var destX = contentPositionX() + Math[deltaX < 0 ? 'floor' : 'ceil'](deltaX),
                percentScrolled = destX / (contentWidth - paneWidth);
            positionDragX(percentScrolled * dragMaxX, animate);
          },
          scrollByY: function(deltaY, animate) {
            var destY = contentPositionY() + Math[deltaY < 0 ? 'floor' : 'ceil'](deltaY),
                percentScrolled = destY / (contentHeight - paneHeight);
            positionDragY(percentScrolled * dragMaxY, animate);
          },
          positionDragX: function(x, animate) {
            positionDragX(x, animate);
          },
          positionDragY: function(y, animate) {
            positionDragY(y, animate);
          },
          animate: function(ele, prop, value, stepCallback) {
            var params = {};
            params[prop] = value;
            ele.animate(params, {
              'duration': settings.animateDuration,
              'easing': settings.animateEase,
              'queue': false,
              'step': stepCallback
            });
          },
          getContentPositionX: function() {
            return contentPositionX();
          },
          getContentPositionY: function() {
            return contentPositionY();
          },
          getContentWidth: function() {
            return contentWidth;
          },
          getContentHeight: function() {
            return contentHeight;
          },
          getPercentScrolledX: function() {
            return contentPositionX() / (contentWidth - paneWidth);
          },
          getPercentScrolledY: function() {
            return contentPositionY() / (contentHeight - paneHeight);
          },
          getIsScrollableH: function() {
            return isScrollableH;
          },
          getIsScrollableV: function() {
            return isScrollableV;
          },
          getContentPane: function() {
            return pane;
          },
          scrollToBottom: function(animate) {
            positionDragY(dragMaxY, animate);
          },
          hijackInternalLinks: $.noop,
          destroy: function() {
            destroy();
          }
        });
        initialise(s);
      }
      settings = $.extend({}, $.fn.jScrollPane.defaults, settings);
      $.each(['arrowButtonSpeed', 'trackClickSpeed', 'keyboardSpeed'], function() {
        settings[this] = settings[this] || settings.speed;
      });
      return this.each(function() {
        var elem = $(this),
            jspApi = elem.data('jsp');
        if (jspApi) {
          jspApi.reinitialise(settings);
        } else {
          $("script", elem).filter('[type="text/javascript"],:not([type])').remove();
          jspApi = new JScrollPane(elem, settings);
          elem.data('jsp', jspApi);
        }
      });
    };
    $.fn.jScrollPane.defaults = {
      showArrows: false,
      maintainPosition: true,
      stickToBottom: false,
      stickToRight: false,
      clickOnTrack: true,
      autoReinitialise: false,
      autoReinitialiseDelay: 500,
      verticalDragMinHeight: 0,
      verticalDragMaxHeight: 99999,
      horizontalDragMinWidth: 0,
      horizontalDragMaxWidth: 99999,
      contentWidth: undefined,
      animateScroll: false,
      animateDuration: 300,
      animateEase: 'linear',
      hijackInternalLinks: false,
      verticalGutter: 4,
      horizontalGutter: 4,
      mouseWheelSpeed: 3,
      arrowButtonSpeed: 0,
      arrowRepeatFreq: 50,
      arrowScrollOnHover: false,
      trackClickSpeed: 0,
      trackClickRepeatFreq: 70,
      verticalArrowPositions: 'split',
      horizontalArrowPositions: 'split',
      enableKeyboardNavigation: true,
      hideFocus: false,
      keyboardSpeed: 0,
      initialDelay: 300,
      speed: 30,
      scrollPagePercent: .8
    };
  }));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a9", ["a8"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('a8');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("aa", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(options) {
    var getState = options.stateHandler.getState;
    function isDetectable(element) {
      return !!getState(element).isDetectable;
    }
    function markAsDetectable(element) {
      getState(element).isDetectable = true;
    }
    function isBusy(element) {
      return !!getState(element).busy;
    }
    function markBusy(element, busy) {
      getState(element).busy = !!busy;
    }
    return {
      isDetectable: isDetectable,
      markAsDetectable: markAsDetectable,
      isBusy: isBusy,
      markBusy: markBusy
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ab", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(idHandler) {
    var eventListeners = {};
    function getListeners(element) {
      return eventListeners[idHandler.get(element)] || [];
    }
    function addListener(element, listener) {
      var id = idHandler.get(element);
      if (!eventListeners[id]) {
        eventListeners[id] = [];
      }
      eventListeners[id].push(listener);
    }
    function removeListener(element, listener) {
      var listeners = getListeners(element);
      for (var i = 0,
          len = listeners.length; i < len; ++i) {
        if (listeners[i] === listener) {
          listeners.splice(i, 1);
          break;
        }
      }
    }
    function removeAllListeners(element) {
      var listeners = eventListeners[idHandler.get(element)];
      if (!listeners) {
        return;
      }
      listeners.length = 0;
    }
    return {
      get: getListeners,
      add: addListener,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ac", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function() {
    var idCount = 1;
    function generate() {
      return idCount++;
    }
    return {generate: generate};
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ad", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(options) {
    var idGenerator = options.idGenerator;
    var getState = options.stateHandler.getState;
    function getId(element, readonly) {
      if (!readonly && !hasId(element)) {
        setId(element);
      }
      return getState(element).id;
    }
    function setId(element) {
      var id = idGenerator.generate();
      getState(element).id = id;
      return id;
    }
    function hasId(element) {
      return getState(element).id !== undefined;
    }
    function removeId(element) {
      delete getState(element).id;
    }
    return {
      get: getId,
      remove: removeId
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ae", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(quiet) {
    function noop() {}
    var reporter = {
      log: noop,
      warn: noop,
      error: noop
    };
    if (!quiet && window.console) {
      var attachFunction = function(reporter, name) {
        reporter[name] = function reporterProxy() {
          console[name].apply(console, arguments);
        };
      };
      attachFunction(reporter, "log");
      attachFunction(reporter, "warn");
      attachFunction(reporter, "error");
    }
    return reporter;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("af", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var utils = module.exports = {};
  utils.getOption = getOption;
  function getOption(options, name, defaultValue) {
    var value = options[name];
    if ((value === undefined || value === null) && defaultValue !== undefined) {
      return defaultValue;
    }
    return value;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b0", ["af", "5a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var utils = $__require('af');
    module.exports = function batchProcessorMaker(options) {
      options = options || {};
      var reporter = options.reporter;
      var asyncProcess = utils.getOption(options, "async", true);
      var autoProcess = utils.getOption(options, "auto", true);
      if (autoProcess && !asyncProcess) {
        reporter && reporter.warn("Invalid options combination. auto=true and async=false is invalid. Setting async=true.");
        asyncProcess = true;
      }
      var batch;
      var batchSize;
      var topLevel;
      var bottomLevel;
      clearBatch();
      var asyncFrameHandler;
      function addFunction(level, fn) {
        if (!fn) {
          fn = level;
          level = 0;
        }
        if (level > topLevel) {
          topLevel = level;
        } else if (level < bottomLevel) {
          bottomLevel = level;
        }
        if (!batch[level]) {
          batch[level] = [];
        }
        if (autoProcess && asyncProcess && batchSize === 0) {
          processBatchAsync();
        }
        batch[level].push(fn);
        batchSize++;
      }
      function forceProcessBatch(localAsyncProcess) {
        if (localAsyncProcess === undefined) {
          localAsyncProcess = asyncProcess;
        }
        if (asyncFrameHandler) {
          cancelFrame(asyncFrameHandler);
          asyncFrameHandler = null;
        }
        if (localAsyncProcess) {
          processBatchAsync();
        } else {
          processBatch();
        }
      }
      function processBatch() {
        for (var level = bottomLevel; level <= topLevel; level++) {
          var fns = batch[level];
          for (var i = 0; i < fns.length; i++) {
            var fn = fns[i];
            fn();
          }
        }
        clearBatch();
      }
      function processBatchAsync() {
        asyncFrameHandler = requestFrame(processBatch);
      }
      function clearBatch() {
        batch = {};
        batchSize = 0;
        topLevel = 0;
        bottomLevel = 0;
      }
      function cancelFrame(listener) {
        var cancel = window.clearTimeout;
        return cancel(listener);
      }
      function requestFrame(callback) {
        var raf = function(fn) {
          return window.setTimeout(fn, 0);
        };
        return raf(callback);
      }
      return {
        add: addFunction,
        force: forceProcessBatch
      };
    };
  })($__require('5a'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b1", ["b0"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('b0');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b2", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var prop = "_erd";
  function initState(element) {
    element[prop] = {};
    return getState(element);
  }
  function getState(element) {
    return element[prop] || initState(element);
  }
  function cleanState(element) {
    delete element[prop];
  }
  module.exports = {
    initState: initState,
    getState: getState,
    cleanState: cleanState
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b3", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var detector = module.exports = {};
  detector.isIE = function(version) {
    function isAnyIeVersion() {
      var agent = navigator.userAgent.toLowerCase();
      return agent.indexOf("msie") !== -1 || agent.indexOf("trident") !== -1 || agent.indexOf(" edge/") !== -1;
    }
    if (!isAnyIeVersion()) {
      return false;
    }
    if (!version) {
      return true;
    }
    var ieVersion = (function() {
      var undef,
          v = 3,
          div = document.createElement("div"),
          all = div.getElementsByTagName("i");
      do {
        div.innerHTML = "<!--[if gt IE " + (++v) + "]><i></i><![endif]-->";
      } while (all[0]);
      return v > 4 ? v : undef;
    }());
    return version === ieVersion;
  };
  detector.isLegacyOpera = function() {
    return !!window.opera;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b4", ["b3"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var browserDetector = $__require('b3');
  module.exports = function(options) {
    options = options || {};
    var reporter = options.reporter;
    var batchProcessor = options.batchProcessor;
    var getState = options.stateHandler.getState;
    if (!reporter) {
      throw new Error("Missing required dependency: reporter.");
    }
    function addListener(element, listener) {
      if (!getObject(element)) {
        throw new Error("Element is not detectable by this strategy.");
      }
      function listenerProxy() {
        listener(element);
      }
      if (browserDetector.isIE(8)) {
        getState(element).object = {proxy: listenerProxy};
        element.attachEvent("onresize", listenerProxy);
      } else {
        var object = getObject(element);
        object.contentDocument.defaultView.addEventListener("resize", listenerProxy);
      }
    }
    function makeDetectable(options, element, callback) {
      if (!callback) {
        callback = element;
        element = options;
        options = null;
      }
      options = options || {};
      var debug = options.debug;
      function injectObject(element, callback) {
        var OBJECT_STYLE = "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; padding: 0; margin: 0; opacity: 0; z-index: -1000; pointer-events: none;";
        var positionCheckPerformed = false;
        var style = getComputedStyle(element);
        getState(element).startSizeStyle = {
          width: style.width,
          height: style.height
        };
        function mutateDom() {
          function alterPositionStyles() {
            if (style.position === "static") {
              element.style.position = "relative";
              var removeRelativeStyles = function(reporter, element, style, property) {
                function getNumericalValue(value) {
                  return value.replace(/[^-\d\.]/g, "");
                }
                var value = style[property];
                if (value !== "auto" && getNumericalValue(value) !== "0") {
                  reporter.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element);
                  element.style[property] = 0;
                }
              };
              removeRelativeStyles(reporter, element, style, "top");
              removeRelativeStyles(reporter, element, style, "right");
              removeRelativeStyles(reporter, element, style, "bottom");
              removeRelativeStyles(reporter, element, style, "left");
            }
          }
          function onObjectLoad() {
            if (!positionCheckPerformed) {
              alterPositionStyles();
            }
            function getDocument(element, callback) {
              if (!element.contentDocument) {
                setTimeout(function checkForObjectDocument() {
                  getDocument(element, callback);
                }, 100);
                return;
              }
              callback(element.contentDocument);
            }
            var objectElement = this;
            getDocument(objectElement, function onObjectDocumentReady(objectDocument) {
              callback(element);
            });
          }
          if (style.position !== "") {
            alterPositionStyles(style);
            positionCheckPerformed = true;
          }
          var object = document.createElement("object");
          object.style.cssText = OBJECT_STYLE;
          object.type = "text/html";
          object.onload = onObjectLoad;
          if (!browserDetector.isIE()) {
            object.data = "about:blank";
          }
          element.appendChild(object);
          getState(element).object = object;
          if (browserDetector.isIE()) {
            object.data = "about:blank";
          }
        }
        if (batchProcessor) {
          batchProcessor.add(mutateDom);
        } else {
          mutateDom();
        }
      }
      if (browserDetector.isIE(8)) {
        callback(element);
      } else {
        injectObject(element, callback);
      }
    }
    function getObject(element) {
      return getState(element).object;
    }
    function uninstall(element) {
      if (browserDetector.isIE(8)) {
        element.detachEvent("onresize", getState(element).object.proxy);
      } else {
        element.removeChild(getObject(element));
      }
      delete getState(element).object;
    }
    return {
      makeDetectable: makeDetectable,
      addListener: addListener,
      uninstall: uninstall
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b5", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var utils = module.exports = {};
  utils.forEach = function(collection, callback) {
    for (var i = 0; i < collection.length; i++) {
      var result = callback(collection[i]);
      if (result) {
        return result;
      }
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b6", ["b5"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var forEach = $__require('b5').forEach;
  module.exports = function(options) {
    options = options || {};
    var reporter = options.reporter;
    var batchProcessor = options.batchProcessor;
    var getState = options.stateHandler.getState;
    var idHandler = options.idHandler;
    var detectionContainerClass = "erd_scroll_detection_container";
    if (!reporter) {
      throw new Error("Missing required dependency: reporter.");
    }
    var scrollbarSizes = getScrollbarSizes();
    var styleId = "erd_scroll_detection_scrollbar_style";
    injectScrollStyle(styleId, detectionContainerClass);
    function addListener(element, listener) {
      var listeners = getState(element).listeners;
      if (!listeners.push) {
        throw new Error("Cannot add listener to an element that is not detectable.");
      }
      getState(element).listeners.push(listener);
    }
    function makeDetectable(options, element, callback) {
      if (!callback) {
        callback = element;
        element = options;
        options = null;
      }
      options = options || {};
      function debug() {
        if (options.debug) {
          var args = Array.prototype.slice.call(arguments);
          args.unshift(idHandler.get(element), "Scroll: ");
          reporter.log.apply(null, args);
        }
      }
      function isStyleResolved() {
        function isPxValue(length) {
          return length.indexOf("px") !== -1;
        }
        var style = getComputedStyle(element);
        return style.position && isPxValue(style.width) && isPxValue(style.height);
      }
      function install() {
        function getStyle() {
          var style = {};
          var elementStyle = getComputedStyle(element);
          style.position = elementStyle.position;
          style.width = parseSize(elementStyle.width);
          style.height = parseSize(elementStyle.height);
          style.top = elementStyle.top;
          style.right = elementStyle.right;
          style.bottom = elementStyle.bottom;
          style.left = elementStyle.left;
          style.widthStyle = elementStyle.width;
          style.heightStyle = elementStyle.height;
          return style;
        }
        function storeStartSize() {
          var style = getStyle();
          getState(element).startSizeStyle = {
            width: style.widthStyle,
            height: style.heightStyle
          };
        }
        function initListeners() {
          getState(element).listeners = [];
        }
        debug("Installing scroll elements...");
        storeStartSize();
        initListeners();
        debug("Element start size", getState(element).startSizeStyle);
        function storeStyle() {
          debug("storeStyle invoked.");
          var style = getStyle();
          getState(element).style = style;
        }
        function mutateDom() {
          debug("mutateDom invoked.");
          var style = getState(element).style;
          function alterPositionStyles() {
            if (style.position === "static") {
              element.style.position = "relative";
              var removeRelativeStyles = function(reporter, element, style, property) {
                function getNumericalValue(value) {
                  return value.replace(/[^-\d\.]/g, "");
                }
                var value = style[property];
                if (value !== "auto" && getNumericalValue(value) !== "0") {
                  reporter.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element);
                  element.style[property] = 0;
                }
              };
              removeRelativeStyles(reporter, element, style, "top");
              removeRelativeStyles(reporter, element, style, "right");
              removeRelativeStyles(reporter, element, style, "bottom");
              removeRelativeStyles(reporter, element, style, "left");
            }
          }
          function getContainerCssText(left, top, bottom, right) {
            left = (!left ? "0" : (left + "px"));
            top = (!top ? "0" : (top + "px"));
            bottom = (!bottom ? "0" : (bottom + "px"));
            right = (!right ? "0" : (right + "px"));
            return "position: absolute; left: " + left + "; top: " + top + "; right: " + right + "; bottom: " + bottom + "; overflow: scroll; z-index: -1; visibility: hidden;";
          }
          alterPositionStyles(style);
          var scrollbarWidth = scrollbarSizes.width;
          var scrollbarHeight = scrollbarSizes.height;
          var containerStyle = getContainerCssText(-(1 + scrollbarWidth), -(1 + scrollbarHeight), -scrollbarHeight, -scrollbarWidth);
          var shrinkExpandstyle = getContainerCssText(0, 0, -scrollbarHeight, -scrollbarWidth);
          var shrinkExpandChildStyle = "position: absolute; left: 0; top: 0;";
          var container = document.createElement("div");
          var expand = document.createElement("div");
          var expandChild = document.createElement("div");
          var shrink = document.createElement("div");
          var shrinkChild = document.createElement("div");
          container.className = detectionContainerClass;
          container.style.cssText = containerStyle;
          expand.style.cssText = shrinkExpandstyle;
          expandChild.style.cssText = shrinkExpandChildStyle;
          shrink.style.cssText = shrinkExpandstyle;
          shrinkChild.style.cssText = shrinkExpandChildStyle + " width: 200%; height: 200%;";
          expand.appendChild(expandChild);
          shrink.appendChild(shrinkChild);
          container.appendChild(expand);
          container.appendChild(shrink);
          element.appendChild(container);
          getState(element).element = container;
          function handleScroll() {
            function changed() {
              var elementStyle = getComputedStyle(element);
              var width = parseSize(elementStyle.width);
              var height = parseSize(elementStyle.height);
              debug("Storing current size", width, height);
              storeCurrentSize(element, width, height);
              batchProcessor.add(function updateDetectorElements() {
                if (options.debug) {
                  var style = getComputedStyle(element);
                  var w = parseSize(style.width);
                  var h = parseSize(style.height);
                  if (w !== width || h !== height) {
                    reporter.warn(idHandler.get(element), "Scroll: Size changed before updating detector elements.");
                  }
                }
                updateChildSizes(element, width, height);
              });
              batchProcessor.add(1, function updateScrollbars() {
                positionScrollbars(element, width, height);
                forEach(getState(element).listeners, function(listener) {
                  listener(element);
                });
              });
            }
            debug("Scroll detected.");
            var style = getComputedStyle(element);
            var width = parseSize(style.width);
            var height = parseSize(style.height);
            if (width !== element.lastWidth || height !== element.lastHeight) {
              debug("Element size changed.");
              changed();
            }
          }
          addEvent(expand, "scroll", function onExpand() {
            handleScroll();
          });
          addEvent(shrink, "scroll", function onShrink() {
            handleScroll();
          });
          updateChildSizes(element, style.width, style.height);
        }
        function finalizeDomMutation() {
          debug("finalizeDomMutation invoked.");
          var style = getState(element).style;
          storeCurrentSize(element, style.width, style.height);
          positionScrollbars(element, style.width, style.height);
        }
        function ready() {
          callback(element);
        }
        if (batchProcessor) {
          batchProcessor.add(0, storeStyle);
          batchProcessor.add(1, mutateDom);
          batchProcessor.add(2, finalizeDomMutation);
          batchProcessor.add(3, ready);
        } else {
          storeStyle();
          mutateDom();
          finalizeDomMutation();
          ready();
        }
      }
      debug("Making detectable...");
      if (isStyleResolved()) {
        debug("Style resolved");
        install();
      } else {
        debug("Style not resolved");
        debug("Polling for style resolution...");
        var timeout = setInterval(function() {
          if (isStyleResolved()) {
            debug("Poll. Style resolved.");
            install();
            clearTimeout(timeout);
          } else {
            debug("Poll. Style not resolved.");
          }
        }, 50);
      }
    }
    function getExpandElement(element) {
      return getState(element).element.childNodes[0];
    }
    function getExpandChildElement(element) {
      return getExpandElement(element).childNodes[0];
    }
    function getShrinkElement(element) {
      return getState(element).element.childNodes[1];
    }
    function getWidthOffset() {
      return 2 * scrollbarSizes.width + 1;
    }
    function getHeightOffset() {
      return 2 * scrollbarSizes.height + 1;
    }
    function getExpandWidth(width) {
      return width + 10 + getWidthOffset();
    }
    function getExpandHeight(height) {
      return height + 10 + getHeightOffset();
    }
    function getShrinkWidth(width) {
      return width * 2 + getWidthOffset();
    }
    function getShrinkHeight(height) {
      return height * 2 + getHeightOffset();
    }
    function updateChildSizes(element, width, height) {
      var expandChild = getExpandChildElement(element);
      var expandWidth = getExpandWidth(width);
      var expandHeight = getExpandHeight(height);
      expandChild.style.width = expandWidth + "px";
      expandChild.style.height = expandHeight + "px";
    }
    function storeCurrentSize(element, width, height) {
      element.lastWidth = width;
      element.lastHeight = height;
    }
    function positionScrollbars(element, width, height) {
      var expand = getExpandElement(element);
      var shrink = getShrinkElement(element);
      var expandWidth = getExpandWidth(width);
      var expandHeight = getExpandHeight(height);
      var shrinkWidth = getShrinkWidth(width);
      var shrinkHeight = getShrinkHeight(height);
      expand.scrollLeft = expandWidth;
      expand.scrollTop = expandHeight;
      shrink.scrollLeft = shrinkWidth;
      shrink.scrollTop = shrinkHeight;
    }
    function addEvent(el, name, cb) {
      if (el.attachEvent) {
        el.attachEvent("on" + name, cb);
      } else {
        el.addEventListener(name, cb);
      }
    }
    function removeEvent(el, name, cb) {
      if (el.attachEvent) {
        el.detachEvent("on" + name, cb);
      } else {
        el.removeEventListener(name, cb);
      }
    }
    function parseSize(size) {
      return parseFloat(size.replace(/px/, ""));
    }
    function getScrollbarSizes() {
      var width = 500;
      var height = 500;
      var child = document.createElement("div");
      child.style.cssText = "position: absolute; width: " + width * 2 + "px; height: " + height * 2 + "px; visibility: hidden;";
      var container = document.createElement("div");
      container.style.cssText = "position: absolute; width: " + width + "px; height: " + height + "px; overflow: scroll; visibility: none; top: " + -width * 3 + "px; left: " + -height * 3 + "px; visibility: hidden;";
      container.appendChild(child);
      document.body.insertBefore(container, document.body.firstChild);
      var widthSize = width - container.clientWidth;
      var heightSize = height - container.clientHeight;
      document.body.removeChild(container);
      return {
        width: widthSize,
        height: heightSize
      };
    }
    function injectScrollStyle(styleId, containerClass) {
      function injectStyle(style, method) {
        method = method || function(element) {
          document.head.appendChild(element);
        };
        var styleElement = document.createElement("style");
        styleElement.innerHTML = style;
        styleElement.id = styleId;
        method(styleElement);
        return styleElement;
      }
      if (!document.getElementById(styleId)) {
        var style = "/* Created by the element-resize-detector library. */\n";
        style += "." + containerClass + " > div::-webkit-scrollbar { display: none; }";
        injectStyle(style);
      }
    }
    function uninstall(element) {
      var state = getState(element);
      element.removeChild(state.element);
      delete state.element;
    }
    return {
      makeDetectable: makeDetectable,
      addListener: addListener,
      uninstall: uninstall
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b7", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b8", ["b7"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('b7');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b9", ["b8"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? process : $__require('b8');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5a", ["b9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('b9');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ba", ["b5", "aa", "ab", "ac", "ad", "ae", "b3", "b1", "b2", "b4", "b6", "5a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var forEach = $__require('b5').forEach;
    var elementUtilsMaker = $__require('aa');
    var listenerHandlerMaker = $__require('ab');
    var idGeneratorMaker = $__require('ac');
    var idHandlerMaker = $__require('ad');
    var reporterMaker = $__require('ae');
    var browserDetector = $__require('b3');
    var batchProcessorMaker = $__require('b1');
    var stateHandler = $__require('b2');
    var objectStrategyMaker = $__require('b4');
    var scrollStrategyMaker = $__require('b6');
    module.exports = function(options) {
      options = options || {};
      var idHandler = options.idHandler;
      if (!idHandler) {
        var idGenerator = idGeneratorMaker();
        var defaultIdHandler = idHandlerMaker({
          idGenerator: idGenerator,
          stateHandler: stateHandler
        });
        idHandler = defaultIdHandler;
      }
      var reporter = options.reporter;
      if (!reporter) {
        var quiet = reporter === false;
        reporter = reporterMaker(quiet);
      }
      var batchProcessor = getOption(options, "batchProcessor", batchProcessorMaker({reporter: reporter}));
      var globalOptions = {};
      globalOptions.callOnAdd = !!getOption(options, "callOnAdd", true);
      globalOptions.debug = !!getOption(options, "debug", false);
      var eventListenerHandler = listenerHandlerMaker(idHandler);
      var elementUtils = elementUtilsMaker({stateHandler: stateHandler});
      var detectionStrategy;
      var desiredStrategy = getOption(options, "strategy", "object");
      var strategyOptions = {
        reporter: reporter,
        batchProcessor: batchProcessor,
        stateHandler: stateHandler,
        idHandler: idHandler
      };
      if (desiredStrategy === "scroll" && browserDetector.isLegacyOpera()) {
        reporter.warn("Scroll strategy is not supported on legacy Opera. Changing to object strategy.");
        desiredStrategy = "object";
      }
      if (desiredStrategy === "scroll") {
        detectionStrategy = scrollStrategyMaker(strategyOptions);
      } else if (desiredStrategy === "object") {
        detectionStrategy = objectStrategyMaker(strategyOptions);
      } else {
        throw new Error("Invalid strategy name: " + desiredStrategy);
      }
      var onReadyCallbacks = {};
      function listenTo(options, elements, listener) {
        function onResizeCallback(element) {
          var listeners = eventListenerHandler.get(element);
          forEach(listeners, function callListenerProxy(listener) {
            listener(element);
          });
        }
        function addListener(callOnAdd, element, listener) {
          eventListenerHandler.add(element, listener);
          if (callOnAdd) {
            listener(element);
          }
        }
        function isCollection(obj) {
          return Array.isArray(obj) || obj.length !== undefined;
        }
        function toArray(collection) {
          if (!Array.isArray(collection)) {
            var array = [];
            forEach(elements, function(element) {
              array.push(element);
            });
            return array;
          } else {
            return collection;
          }
        }
        function isElement(obj) {
          return obj && obj.nodeType === 1;
        }
        if (!listener) {
          listener = elements;
          elements = options;
          options = {};
        }
        if (!elements) {
          throw new Error("At least one element required.");
        }
        if (!listener) {
          throw new Error("Listener required.");
        }
        if (isElement(elements)) {
          elements = [elements];
        } else if (isCollection(elements)) {
          elements = toArray(elements);
        } else {
          return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
        }
        var elementsReady = 0;
        var callOnAdd = getOption(options, "callOnAdd", globalOptions.callOnAdd);
        var onReadyCallback = getOption(options, "onReady", function noop() {});
        var debug = getOption(options, "debug", globalOptions.debug);
        forEach(elements, function attachListenerToElement(element) {
          var id = idHandler.get(element);
          debug && reporter.log("Attaching listener to element", id, element);
          if (!elementUtils.isDetectable(element)) {
            debug && reporter.log(id, "Not detectable.");
            if (elementUtils.isBusy(element)) {
              debug && reporter.log(id, "System busy making it detectable");
              addListener(callOnAdd, element, listener);
              onReadyCallbacks[id] = onReadyCallbacks[id] || [];
              onReadyCallbacks[id].push(function onReady() {
                elementsReady++;
                if (elementsReady === elements.length) {
                  onReadyCallback();
                }
              });
              return;
            }
            debug && reporter.log(id, "Making detectable...");
            elementUtils.markBusy(element, true);
            return detectionStrategy.makeDetectable({debug: debug}, element, function onElementDetectable(element) {
              debug && reporter.log(id, "onElementDetectable");
              elementUtils.markAsDetectable(element);
              elementUtils.markBusy(element, false);
              detectionStrategy.addListener(element, onResizeCallback);
              addListener(callOnAdd, element, listener);
              var style = getComputedStyle(element);
              if (stateHandler.getState(element).startSizeStyle.width !== style.width || stateHandler.getState(element).startSizeStyle.height !== style.height) {
                onResizeCallback(element);
              }
              elementsReady++;
              if (elementsReady === elements.length) {
                onReadyCallback();
              }
              if (onReadyCallbacks[id]) {
                forEach(onReadyCallbacks[id], function(callback) {
                  callback();
                });
                delete onReadyCallbacks[id];
              }
            });
          }
          debug && reporter.log(id, "Already detecable, adding listener.");
          addListener(callOnAdd, element, listener);
          elementsReady++;
        });
        if (elementsReady === elements.length) {
          onReadyCallback();
        }
      }
      function uninstall(element) {
        eventListenerHandler.removeAllListeners(element);
        detectionStrategy.uninstall(element);
        stateHandler.cleanState(element);
      }
      return {
        listenTo: listenTo,
        removeListener: eventListenerHandler.removeListener,
        removeAllListeners: eventListenerHandler.removeAllListeners,
        uninstall: uninstall
      };
    };
    function getOption(options, name, defaultValue) {
      var value = options[name];
      if ((value === undefined || value === null) && defaultValue !== undefined) {
        return defaultValue;
      }
      return value;
    }
  })($__require('5a'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bb", ["ba"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('ba');
  global.define = __define;
  return module.exports;
});

$__System.register('6b', ['1', '5', '6', '7', '8', '9', '83', '84', '87', '88', '89', '93', '94', '95', '96', '97', 'b', 'd', 'e', '7e', '8a', 'a1', 'a5', 'a7', 'a9', 'bb'], function (_export) {
  var SCMAP, hasLocalStorage, hasSessionStorage, StarSystem, settings, _createClass, _classCallCheck, MapSymbols, $, MapSymbol, displayInfo, createInfoLink, markdown, partials, routeListingTemplate, systemInfoTemplate, listingsTemplate, uiTemplate, config, renderer, RouteUI, toggleFullScreen, helpers, tabs, slider, jqueryMousewheel, jscrollpane, resizeListener, sessionStorage, oldRenderStats, UI;

  return {
    setters: [function (_3) {
      SCMAP = _3['default'];
    }, function (_8) {
      hasLocalStorage = _8.hasLocalStorage;
      hasSessionStorage = _8.hasSessionStorage;
    }, function (_4) {
      StarSystem = _4['default'];
    }, function (_7) {
      settings = _7['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_6) {
      MapSymbols = _6['default'];
    }, function (_16) {
      $ = _16['default'];
    }, function (_5) {
      MapSymbol = _5['default'];
    }, function (_9) {
      displayInfo = _9.displayInfo;
      createInfoLink = _9.createInfoLink;
    }, function (_15) {
      markdown = _15['default'];
    }, function (_10) {
      partials = _10['default'];
    }, function (_14) {
      routeListingTemplate = _14['default'];
    }, function (_12) {
      systemInfoTemplate = _12['default'];
    }, function (_13) {
      listingsTemplate = _13['default'];
    }, function (_11) {
      uiTemplate = _11['default'];
    }, function (_b) {
      config = _b['default'];
    }, function (_d) {
      renderer = _d.renderer;
    }, function (_e) {
      RouteUI = _e['default'];
    }, function (_e2) {
      toggleFullScreen = _e2['default'];
    }, function (_a) {
      helpers = _a['default'];
    }, function (_a1) {
      tabs = _a1['default'];
    }, function (_a5) {
      slider = _a5['default'];
    }, function (_a7) {
      jqueryMousewheel = _a7['default'];
    }, function (_a9) {
      jscrollpane = _a9['default'];
    }, function (_bb) {
      resizeListener = _bb['default'];
    }],
    execute: function () {
      /**
        * @author Lianna Eeftinck / https://github.com/Leeft
        */

      // Import the templates
      'use strict';

      $.fn.outerHtml = function () {
        return $('<div />').append(this.eq(0).clone()).html();
      };

      sessionStorage = hasSessionStorage() ? window.sessionStorage : {};
      oldRenderStats = {
        render: {
          calls: 0,
          faces: 0,
          points: 0,
          vertices: 0
        },
        memory: {
          geometries: 0,
          textures: 0
        }
      };

      UI = (function () {
        function UI(map) {
          var _this = this;

          _classCallCheck(this, UI);

          this.map = map;

          var selectedSystem = null;
          if ('selectedSystem' in settings.storage) {
            selectedSystem = StarSystem.getById(settings.storage.selectedSystem);
            if (selectedSystem instanceof StarSystem) {
              map.setSelectionTo(selectedSystem);
            } else {
              selectedSystem = null;
            }
          }

          var icons = [];
          for (var _name in MapSymbols) {
            var icon = MapSymbols[_name];
            icons.push($('<span><i class="fa-li fa ' + icon.cssClass + '"></i>' + icon.description + '</span>').css('color', icon.color).outerHtml());
          }

          var ui = this;

          $('#sc-map-interface').empty().append(UI.Templates.mapUI({
            instructions: ['Left-click (or tap) and release to select a system.', 'Left-click (or tap) and drag from system to system to map a route between them.', 'Left-click (or tap) and drag any waypoint on the route to move it. It moves an existing waypoint or creates new waypoints as needed.', 'Left-click (or tap) and drag on the background of the map to rotate the camera around the current center.', 'Mousewheel (or two-finger pinch) to zoom in and out; middle-click and drag can also be used.', 'Right-click (or three-finger swipe) to pan the camera along the map.', 'Right-click plus alt (or four-finger swipe) to pan the camera up and down.'],
            shortcuts: [{ key: 'R', description: 'Reset camera angle (virtual north)' }, { key: 'C', description: 'Camera to center (Sol)' }, { key: 'T', description: 'Top-down camera' }, { key: 'L', description: 'Lock/unlock camera rotation' }, { key: '2', description: 'Switch to 2D mode' }, { key: '3', description: 'Switch to 3D mode' }, { key: 'Esc', description: 'Deselect target' }],
            icons: icons,
            systemGroups: UI.buildDynamicLists(),
            system: selectedSystem,
            settings: {
              glow: settings.glow,
              labels: settings.labels,
              labelIcons: settings.labelIcons,
              effect: {
                Antialias: settings.effect.Antialias,
                FXAA: settings.effect.FXAA,
                Bloom: settings.effect.Bloom
              }
            },
            route: RouteUI.templateData(map.route())
          }));

          $(UI.menuBar).each(function (i, menuItem) {
            $('#sc-map-interface ul.menubar').append(menuItem);
          });

          $('#sc-map-3d-mode').prop('checked', settings.mode === '3d').on('change', function () {
            if (this.checked) {
              map.displayState.to3d();
            } else {
              map.displayState.to2d();
            }
          });

          $('#sc-map-lock-rotation').prop('checked', settings.control.rotationLocked).on('change', function () {
            renderer.controls.enableRotate = !this.checked;
            settings.storage['control.rotationLocked'] = this.checked ? '1' : '0';
            settings.save('control');
          });

          $('#sc-map-resetCamera').on('click', function () {
            renderer.controls.cameraTo(settings.cameraDefaults.target, settings.cameraDefaults.orientation.theta, settings.cameraDefaults.orientation.phi, settings.cameraDefaults.orientation.radius);
          });

          $('#sc-map-centreCamera').on('click', function () {
            renderer.controls.moveTo(settings.cameraDefaults.target);
          });

          $('#sc-map-northCamera').on('click', function () {
            renderer.controls.rotateTo(0, undefined, undefined);
          });

          $('#sc-map-topCamera').on('click', function () {
            renderer.controls.rotateTo(0, 0, 180);
          });

          $('#sc-map-top2D').on('click', function () {
            renderer.controls.enableRotate = false;
            $('#sc-map-lock-rotation').prop('checked', true);
            map.displayState.to2d();
            renderer.controls.rotateTo(0, 0, 180);
          });

          $('#sc-map-toggleFullScreen').on('click', function () {
            toggleFullScreen();
          });

          var tabIndex = 0;
          if ('scMapTab' in sessionStorage) {
            var defaultTab = UI.Tab(sessionStorage.scMapTab);
            if (defaultTab) {
              tabIndex = defaultTab.index;
            }
          }

          $('#sc-map-interface').tabs({
            active: tabIndex,
            activate: function activate(event, ui) {
              event.preventDefault();
              var clicked_on = ui.newTab.find('a').data('tab');
              var tab = UI.Tab(clicked_on);

              switch (clicked_on) {

                case 'systems':
                  UI.updateSystemsList();
                  break;

                default:
                  $('#sc-map-webgl-container').removeClass('edit');
                  break;
              }

              if (config.debug) {
                $('.sc-map-debug .hide').removeClass('hide');
              }

              sessionStorage.scMapTab = clicked_on;

              /* Browsers show an ugly URL bar if href is set to #, this
               * makes the HTML invalid but removes the ugly URL bar */
              $('#sc-map-interface a[href="#"]').removeAttr('href');

              UI.toTabTop();
            }
          });

          $('#sc-map-toggle-glow').prop('checked', settings.glow);
          $('#sc-map-toggle-labels').prop('checked', settings.labels);
          $('#sc-map-toggle-label-icons').prop('checked', settings.labelIcons);

          // Some simple UI stuff

          $('#sc-map-interface').on('change', '.sc-map-avoid-hostile', function () {
            settings.route.avoidHostile = this.checked;
            settings.save('route');
            map.route().update();
            map.route().storeToSession();
          });

          $('#sc-map-interface').on('change', '.sc-map-avoid-unknown-jumppoints', function () {
            settings.route.avoidUnknownJumppoints = this.checked;
            settings.save('route');
            map.route().update();
            map.route().storeToSession();
          });

          $('#sc-map-interface').on('change', '.sc-map-avoid-off-limits', function () {
            settings.route.avoidOffLimits = this.checked;
            settings.save('route');
            map.route().update();
            map.route().storeToSession();
          });

          // UI width slider / settings handling
          settings.storage.uiWidth = UI.widthClasses[UI.widthClassToIndex(settings.storage.uiWidth)];
          $('#sc-map-interface').removeClass(UI.widthClasses.join(' ')).addClass(settings.storage.uiWidth);

          //
          $('#sc-map-interface .sc-map-slider-uiwidth').slider({
            min: 0,
            max: UI.widthClasses.length - 1,
            range: 'min',
            value: settings.storage.uiWidth ? UI.widthClassToIndex(settings.storage.uiWidth) : UI.defaultWidthIndex,
            change: function change(event, ui) {
              var value = ui.value;
              $('#sc-map-interface').removeClass(UI.widthClasses.join(' ')).addClass(UI.widthClasses[value]);
              settings.storage.uiWidth = UI.widthClasses[value];
              UI.jScrollPane().reinitialise();
            }
          });

          var updateLabelSize = function updateLabelSize(event, slider) {
            settings.labelScale = slider.value / 100;
            map.geometry.labels.refreshScale();
          };
          $('#sc-map-interface .sc-map-slider-label-size').slider({
            min: Number(config.minLabelScale) * 100,
            max: Number(config.maxLabelScale) * 100,
            value: settings.labelScale * 100,
            change: updateLabelSize,
            slide: updateLabelSize
          });

          var updateLabelOffset = function updateLabelOffset(event, slider) {
            settings.labelOffset = slider.value / 100;
            map.geometry.labels.matchRotation(renderer.cameraRotationMatrix());
          };
          $('#sc-map-interface .sc-map-slider-label-offset').slider({
            min: Number(config.minLabelOffset) * 100,
            max: Number(config.maxLabelOffset) * 100,
            value: settings.labelOffset * 100,
            change: updateLabelOffset,
            slide: updateLabelOffset
          });

          var updateSystemScale = function updateSystemScale(event, slider) {
            settings.systemScale = slider.value / 100;
            map.geometry.systems.refreshScale();
            map.geometry.glow.refreshScale();
          };
          // UI width slider / settings handling
          $('#sc-map-interface .sc-map-slider-system-size').slider({
            min: Number(config.minSystemScale) * 100,
            max: Number(config.maxSystemScale) * 100,
            value: settings.systemScale * 100,
            change: updateSystemScale,
            slide: updateSystemScale
          });

          $('#sc-map-toggle-stats').prop('checked', settings.storage['renderer.Stats'] === '1' ? true : false).on('change', function () {
            if (this.checked) {
              $('#stats').show();
            } else {
              $('#stats').hide();
            }
            settings.storage['renderer.Stats'] = this.checked ? '1' : '0';
            settings.save('renderer');
          });

          //$('#sc-map-toggle-antialias')
          //  .on( 'change', function() {
          //    settings.effect.Antialias = this.checked;
          //    settings.save( 'effect' );
          //    window.location.reload( false );
          //  });

          //$('#sc-map-toggle-fxaa')
          //  .prop( 'disabled', settings.effect.Antialias )
          //  .on( 'change', function() {
          //    settings.effect.FXAA = this.checked;
          //    settings.save( 'effect' );
          //    if ( renderer.FXAA ) {
          //      renderer.FXAA.enabled = this.checked;
          //    }
          //  });

          //$('#sc-map-toggle-bloom')
          //  .prop( 'disabled', settings.effect.Antialias )
          //  .on( 'change', function() {
          //    settings.effect.Bloom = this.checked;
          //    settings.save( 'effect' );
          //    if ( renderer.composer ) {
          //      for ( let i = 0; i < renderer.composer.passes.length; i++ ) {
          //        if ( renderer.composer.passes[i] instanceof THREE.BloomPass ) {
          //          renderer.composer.passes[i].enabled = this.checked;
          //        }
          //      }
          //    }
          //  });

          $('#sc-map-toggle-glow').on('change', function () {
            settings.glow = this.checked;
            map.geometry.glow.refreshVisibility();
          });

          $('#sc-map-toggle-labels').on('change', function () {
            settings.labels = this.checked;
            map.geometry.labels.refreshVisibility();
          });

          $('#sc-map-toggle-label-icons').prop('disabled', !settings.labels).on('change', function () {
            settings.labelIcons = this.checked;
            map.geometry.labels.refreshIcons();
          });

          // FIXME: These currently don't have any effect
          $('#sc-map-toggle-antialias').prop('disabled', true);
          $('#sc-map-toggle-fxaa').prop('disabled', true);
          $('#sc-map-toggle-bloom').prop('disabled', true);

          $('.quick-button.with-checkbox').on('click', function (event) {
            var $this = $(this);
            $this.find('input[type=checkbox]').click();
          });

          $('#sc-map-interface').on('click', 'a[data-toggle-next]', function (event) {
            var $this = $(this);
            event.preventDefault();
            var $element = $this.parent().next();
            $element.toggle();
            var title = $this.data('title');

            if ($element.is(':visible')) {
              $this.parent().find('> a > i').first().removeClass('fa-caret-right').addClass('fa-caret-down');
              sessionStorage[title] = '1';
            } else {
              $this.parent().find('> a > i').first().addClass('fa-caret-right').removeClass('fa-caret-down');
              sessionStorage[title] = '0';
            }
          });

          $('#sc-map-interface').on('click', 'a[data-toggle-child]', function (event) {
            var $this = $(this);
            event.preventDefault();
            var $element = $this.parent().find($this.data('toggle-child'));
            $element.toggle();
            if ($element.is(':visible')) {
              $this.parent().find('> a > i').removeClass('fa-caret-right').addClass('fa-caret-down');
            } else {
              $this.parent().find('> a > i').addClass('fa-caret-right').removeClass('fa-caret-down');
            }
          });

          $('#sc-map-interface').on('click', 'a[data-goto="system"]', function (event) {
            event.preventDefault();
            var $this = $(this);
            var system = StarSystem.getById($this.data('system'));
            displayInfo(system);
            renderer.controls.moveTo(system);
          });

          $('#sc-map-interface').on('click', 'table.routelist .remove-waypoint', function (event) {
            event.preventDefault();
            var $this = $(this);
            var system = StarSystem.getById($this.data('system'));
            map.route().removeWaypoint(system);
            map.route().update();
            map.route().storeToSession();
          });

          $('#sc-map-interface').on('click', 'button.delete-route', function (event) {
            map.route().destroy();
            map.route().storeToSession();
          });

          var updateComments = function updateComments(event) {
            event.preventDefault();
            var system = StarSystem.getById($(this).data('system'));
            var text = $(this).val();
            if (typeof text === 'string' && text.length > 0) {
              system.setComments(text);
              $('#sc-map-interface .user-system-comments-md').html($(markdown.markdown.toHTML(text)));
            } else {
              system.setComments();
              $('#sc-map-interface .user-system-comments-md').empty();
            }
            system.refreshIcons();
          };

          $('#sc-map-interface').on('keyup', '.user-system-comments', updateComments);
          $('#sc-map-interface').on('blur', '.user-system-comments', updateComments);
          $('#sc-map-interface').on('change', '.user-system-comments', updateComments);

          $('#sc-map-interface').on('click', '.remove-system-comments', function (event) {
            event.preventDefault();
            var system = StarSystem.getById($(this).data('system'));
            system.setComments();
            $('.comment-editing .user-system-comments').empty().val('');
            $('.comment-editing .user-system-comments-md').empty();
            system.refreshIcons();
          });

          $('#sc-map-interface').on('change', '.user-system-bookmarked', function () {
            StarSystem.getById($(this).data('system')).setBookmarkedState(this.checked).refreshIcons();
            settings.save('systems');
          });

          $('#sc-map-interface').on('change', '.user-system-ishangar', function () {
            StarSystem.getById($(this).data('system')).setHangarState(this.checked).refreshIcons();
            settings.save('systems');
          });

          $('#sc-map-interface').on('change', '.user-system-avoid', function () {
            StarSystem.getById($(this).data('system')).setToBeAvoidedState(this.checked).refreshIcons();
            settings.save('systems');
            map.route().rebuildCurrentRoute();
          });

          // Init the mousewheel plugin ("import" alone doesn't cut it)
          jqueryMousewheel($);

          /* jScrollPane */
          $('#sc-map-interface').jScrollPane({
            showArrows: false,
            horizontalGutter: 6,
            mouseWheelSpeed: 4
          });

          this.oldWidth = 0;
          this.oldHeight = 0;

          renderer.resize();

          resizeListener().listenTo($('#sc-map-interface .sc-map-ui-padding')[0], function (element) {
            var width = $(element).width();
            var height = $(element).height();
            if (width !== _this.oldWidth || height !== _this.oldHeight) {
              UI.jScrollPane().reinitialise();
              renderer.resize();
              _this.oldWidth = width;
              _this.oldHeight = height;
            }
          });
        }

        _createClass(UI, null, [{
          key: 'displayInfoOn',
          value: function displayInfoOn(system, doNotSwitch) {
            displayInfo(system, doNotSwitch);
          }
        }, {
          key: 'toTab',
          value: function toTab(index) {
            var tab = UI.Tab(index);
            $('#sc-map-interface').tabs('option', 'active', tab.index);
          }
        }, {
          key: 'toTabTop',
          value: function toTabTop() {
            UI.jScrollPane().scrollToPercentY(0);
          }
        }, {
          key: 'loadedSystems',
          value: function loadedSystems(number) {
            $('#debug-systems').html(number + ' systems loaded');
          }
        }, {
          key: 'rotationLocked',
          value: function rotationLocked() {
            $('#sc-map-lock-rotation').prop('checked', true);
          }
        }, {
          key: 'rotationUnlocked',
          value: function rotationUnlocked() {
            $('#sc-map-lock-rotation').prop('checked', false);
          }
        }, {
          key: 'rotationLockToggle',
          value: function rotationLockToggle() {
            $('#sc-map-lock-rotation').click();
          }
        }, {
          key: 'startHoverOverStarSystem',
          value: function startHoverOverStarSystem() {
            $('#sc-map-webgl-container canvas').addClass('mouseover');
          }
        }, {
          key: 'endHoverOverStarSystem',
          value: function endHoverOverStarSystem() {
            $('#sc-map-webgl-container canvas').removeClass('mouseover');
          }
        }, {
          key: 'entered2D',
          value: function entered2D() {
            $('#sc-map-3d-mode').prop('checked', false);
          }
        }, {
          key: 'entered3D',
          value: function entered3D() {
            $('#sc-map-3d-mode').prop('checked', true);
          }
        }, {
          key: 'jScrollPane',
          value: function jScrollPane() {
            if ($('#sc-map-interface').data('jsp')) {
              return $('#sc-map-interface').data('jsp');
            }
          }
        }, {
          key: 'updateSystemsList',
          value: function updateSystemsList() {
            var tab = UI.Tab('systems');
            $(tab.id).empty().append(UI.Templates.listings({ systemGroups: UI.buildDynamicLists() }));
          }
        }, {
          key: 'htmlEscape',
          value: function htmlEscape(str) {
            return String(str).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
          }
        }, {
          key: 'makeSafeForCSS',
          value: function makeSafeForCSS(name) {
            if (typeof name !== 'string') {
              return;
            }

            return name.replace(/[^a-zA-Z0-9]/g, function (s) {
              var c = s.charCodeAt(0);
              if (c == 32) return '-';
              if (c >= 65 && c <= 90) return '_' + s.toLowerCase();
              return c.toString(16).slice(-4);
            });
          }
        }, {
          key: 'buildDynamicLists',
          value: function buildDynamicLists() {
            var hangars = [];
            var bookmarked = [];
            var withComments = [];
            var byFaction = [];
            var everything = [];
            var data = [];

            var factionsById = {};
            for (var factionId in SCMAP.data.factions) {
              var faction = SCMAP.data.factions[factionId];
              factionsById[faction.id] = {
                faction: faction.name,
                items: []
              };
            }

            var factions = [];

            SCMAP.allSystems.forEach(function (system) {
              var link = createInfoLink(system).outerHtml(); // TODO replace with template

              if (system.hasHangar()) {
                hangars.push(link);
              }
              if (system.isBookmarked()) {
                bookmarked.push(link);
              }
              if (system.hasComments()) {
                withComments.push(link);
              }

              factionsById[system.faction.id].items.push(link);
              everything.push(link);
            });

            if (hangars.length) {
              data.push({
                title: 'Hangar locations&nbsp;' + MapSymbol.getTag(MapSymbols.HANGAR).addClass('fa-lg').outerHtml(),
                items: hangars
              });
            }

            if (bookmarked.length) {
              data.push({
                title: 'Bookmarked&nbsp;' + MapSymbol.getTag(MapSymbols.BOOKMARK).addClass('fa-lg').outerHtml(),
                items: bookmarked
              });
            }

            if (withComments.length) {
              data.push({
                title: 'With your comments&nbsp;' + MapSymbol.getTag(MapSymbols.COMMENTS).addClass('fa-lg').outerHtml(),
                items: withComments
              });
            }

            data.push({
              title: 'By faction',
              factions: factionsById
            }, {
              title: 'Everything',
              items: everything
            });

            return data;
          }
        }, {
          key: 'debugRenderer',
          value: function debugRenderer(renderStats) {
            var $elem = $('#debug-renderer');

            ['calls', 'faces', 'points', 'vertices'].forEach(function (property) {
              if (renderStats.render[property] !== oldRenderStats.render[property]) {
                $elem.find('dd.' + property).text(renderStats.render[property]);
                oldRenderStats.render[property] = renderStats.render[property];
              }
            });

            ['geometries', 'textures'].forEach(function (property) {
              if (renderStats.memory[property] !== oldRenderStats.memory[property]) {
                $elem.find('dd.' + property).text(renderStats.memory[property]);
                oldRenderStats.memory[property] = renderStats.memory[property];
              }
            });
          }
        }, {
          key: 'containerWidth',
          value: function containerWidth() {
            return $('#sc-map-interface').width();
          }
        }]);

        return UI;
      })();

      ;

      UI.menuBar = []; // Populated by template code

      UI.widthClasses = ['widthXS', 'widthS', 'widthN', 'widthL', 'widthXL'];
      UI.defaultWidthIndex = 2;
      UI.widthClassToIndex = function widthClassToIndex(name) {
        if (typeof name === 'string') {
          for (var i = 0; i < UI.widthClasses.length; i += 1) {
            if (name === UI.widthClasses[i]) {
              return i;
            }
          }
        }
        return UI.defaultWidthIndex;
      };

      UI.Tabs = [];
      UI.Tab = function Tab(name) {
        for (var i = 0; i < UI.Tabs.length; i += 1) {
          if (typeof name === 'string' && UI.Tabs[i].name === name) {
            return UI.Tabs[i];
          } else if (typeof name === 'number' && UI.Tabs[i].id === name) {
            return UI.Tabs[i];
          }
        }
        return;
      };

      UI.ActiveTab = function ActiveTab() {
        var activeTabIndex = $('#sc-map-interface').tabs('option', 'active');
        for (var i = 0; i < UI.Tabs.length; i += 1) {
          if (i === activeTabIndex) {
            return UI.Tabs[i];
          }
        }
        return;
      };

      UI.Templates = {
        mapUI: uiTemplate,
        systemInfo: systemInfoTemplate,
        listings: listingsTemplate,
        routeList: routeListingTemplate
      };

      // Workaround for a Chrome (WebKit) issue where the
      // scrollable area can vanish when scrolling it
      if (/webkit/i.test(navigator.userAgent)) {
        document.getElementById('sc-map-interface').addEventListener('scroll', function () /* event */{
          document.getElementById('sc-map-interface').style.width = UI.containerWidth() + 0.1;
        }, false);
      }

      _export('default', UI);
    }
  };
});
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
var _createClass = (function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ('value' in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
})();
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError('Cannot call a class as a function');
  }
}
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define("bc", [], factory) : global.threeSpriteAtlasTextureManager = factory();
})(this, function() {
  'use strict';
  var KnapsackRectangle = (function() {
    function KnapsackRectangle(left, top, right, bottom) {
      _classCallCheck(this, KnapsackRectangle);
      this.left = Math.floor(typeof left === 'number' && isFinite(left) ? left : 0);
      this.top = Math.floor(typeof top === 'number' && isFinite(top) ? top : 0);
      this.right = Math.floor(typeof right === 'number' && isFinite(right) ? right : 0);
      this.bottom = Math.floor(typeof bottom === 'number' && isFinite(bottom) ? bottom : 0);
    }
    _createClass(KnapsackRectangle, [{
      key: 'Xcentre',
      get: function get() {
        return Math.floor((this.right - this.left) / 2 + this.left) - 0.5;
      }
    }, {
      key: 'Ycentre',
      get: function get() {
        return Math.floor((this.bottom - this.top) / 2 + this.top) - 0.5;
      }
    }, {
      key: 'width',
      get: function get() {
        return this.right - this.left;
      }
    }, {
      key: 'height',
      get: function get() {
        return this.bottom - this.top;
      }
    }]);
    return KnapsackRectangle;
  })();
  var KnapsackNode = (function() {
    function KnapsackNode(knapsack) {
      _classCallCheck(this, KnapsackNode);
      this.knapsack = knapsack;
      this.leftChild = null;
      this.rightChild = null;
      this.rectangle = null;
      this.rectangle = new KnapsackRectangle(0, 0, knapsack.textureSize, knapsack.textureSize);
      this.imageID = null;
      this._texture = null;
    }
    _createClass(KnapsackNode, [{
      key: 'hasChildren',
      value: function hasChildren() {
        return this.leftChild !== null || this.rightChild !== null;
      }
    }, {
      key: 'isOccupied',
      value: function isOccupied() {
        return this.imageID !== null;
      }
    }, {
      key: 'uvCoordinates',
      value: function uvCoordinates() {
        var size = this.knapsack.textureSize;
        return [this.rectangle.left / size, 1 - this.rectangle.bottom / size, this.rectangle.right / size, 1 - this.rectangle.top / size];
      }
    }, {
      key: 'release',
      value: function release() {
        if (this.hasChildren()) {
          throw new Error('Can not release tree node, still has children');
        }
        if (this._texture !== null) {
          this._texture.dispose();
          this._texture = null;
        }
        this.clear();
        this.imageID = null;
        return;
      }
    }, {
      key: 'clear',
      value: function clear() {
        this.context.clearRect(this.rectangle.left, this.rectangle.top, this.width - 1, this.height - 1);
      }
    }, {
      key: 'clipContext',
      value: function clipContext() {
        var ctx = this.context;
        ctx.save();
        ctx.beginPath();
        ctx.rect(this.rectangle.left + 1, this.rectangle.top + 1, this.width - 2, this.height - 2);
        ctx.clip();
        ctx.translate(this.rectangle.Xcentre, this.rectangle.Ycentre);
        return ctx;
      }
    }, {
      key: 'restoreContext',
      value: function restoreContext() {
        this.context.restore();
      }
    }, {
      key: 'allocate',
      value: function allocate(width, height) {
        if (this.hasChildren()) {
          var newNode = this.leftChild.allocate(width, height);
          if (newNode instanceof KnapsackNode) {
            newNode.claim();
            return newNode;
          }
          return this.rightChild.allocate(width, height);
        } else {
          if (this.isOccupied()) {
            return null;
          }
          if (width > this.width || height > this.height) {
            return null;
          }
          if (width === this.width && height === this.height) {
            this.claim();
            return this;
          }
          this.leftChild = new KnapsackNode(this.knapsack);
          this.rightChild = new KnapsackNode(this.knapsack);
          var remainingWidth = this.width - width;
          var remainingHeight = this.height - height;
          if (remainingWidth > remainingHeight) {
            this.leftChild.rectangle = new KnapsackRectangle(this.rectangle.left, this.rectangle.top, this.rectangle.left + width, this.rectangle.bottom);
            this.rightChild.rectangle = new KnapsackRectangle(this.rectangle.left + width, this.rectangle.top, this.rectangle.right, this.rectangle.bottom);
          } else {
            this.leftChild.rectangle = new KnapsackRectangle(this.rectangle.left, this.rectangle.top, this.rectangle.right, this.rectangle.top + height);
            this.rightChild.rectangle = new KnapsackRectangle(this.rectangle.left, this.rectangle.top + height, this.rectangle.right, this.rectangle.bottom);
          }
          if (this.knapsack.textureManager.debug) {
            var context = this.context;
            context.lineWidth = 4.0;
            context.strokeStyle = 'rgba(255,0,0,1)';
            context.strokeRect(this.leftChild.rectangle.left, this.leftChild.rectangle.top, this.leftChild.width, this.leftChild.height);
            context.lineWidth = 4.0;
            context.strokeStyle = 'rgba(0,255,0,1)';
            context.strokeRect(this.rightChild.rectangle.left, this.rightChild.rectangle.top, this.rightChild.width, this.rightChild.height);
          }
          return this.leftChild.allocate(width, height);
        }
      }
    }, {
      key: 'claim',
      value: function claim() {
        this.imageID = THREE.Math.generateUUID();
        if (this.knapsack.textureManager.debug) {
          var context = this.context;
          context.lineWidth = 2.0;
          context.strokeStyle = 'rgba( 0, 0, 255, 1 )';
          context.strokeRect(this.rectangle.left + 0.5, this.rectangle.top + 0.5, this.width - 1, this.height - 1);
        }
      }
    }, {
      key: 'canvas',
      get: function get() {
        return this.knapsack.canvas;
      }
    }, {
      key: 'context',
      get: function get() {
        return this.knapsack.canvas.getContext('2d');
      }
    }, {
      key: 'width',
      get: function get() {
        return this.rectangle.width;
      }
    }, {
      key: 'height',
      get: function get() {
        return this.rectangle.height;
      }
    }, {
      key: 'texture',
      get: function get() {
        if (!this._texture) {
          this._texture = this.knapsack.rootTexture.clone();
          this._texture.uuid = this.knapsack.rootTexture.uuid;
          var uvs = this.uvCoordinates();
          this.texture.offset.x = uvs[0];
          this.texture.offset.y = uvs[1];
          this.texture.repeat.x = uvs[2] - uvs[0];
          this.texture.repeat.y = uvs[3] - uvs[1];
        }
        return this._texture;
      }
    }]);
    return KnapsackNode;
  })();
  var Knapsack = (function() {
    function Knapsack(textureManager, size) {
      _classCallCheck(this, Knapsack);
      this.textureManager = textureManager;
      this.textureSize = size;
      this.textureLoaded = false;
      this.rootNode = new KnapsackNode(this);
      this._rootTexture = null;
      this._canvas = null;
    }
    _createClass(Knapsack, [{
      key: 'allocateNode',
      value: function allocateNode(width, height) {
        return this.rootNode.allocate(width, height);
      }
    }, {
      key: 'canvas',
      get: function get() {
        if (!this._canvas) {
          this._canvas = document.createElement('canvas');
          this._canvas.width = this.textureSize;
          this._canvas.height = this.textureSize;
        }
        return this._canvas;
      }
    }, {
      key: 'rootTexture',
      get: function get() {
        if (!this._rootTexture) {
          this._rootTexture = new THREE.Texture(this.canvas, THREE.UVMapping);
        }
        return this._rootTexture;
      }
    }]);
    return Knapsack;
  })();
  var TextureManager = (function() {
    function TextureManager(size) {
      _classCallCheck(this, TextureManager);
      this.size = typeof size === 'number' && /^(128|256|512|1024|2048|4096|8192|16384)$/.test(size) ? size : 1024;
      this.knapsacks = [];
      this.debug = false;
    }
    _createClass(TextureManager, [{
      key: '_addKnapsack',
      value: function _addKnapsack(size) {
        var knapsack = new Knapsack(this, size);
        this.knapsacks.push(knapsack);
        if (this.debug) {
          console.log('TextureManager: allocated ' + this.textureSize + 'px texture map #' + this.knapsacks.length);
        }
        return knapsack;
      }
    }, {
      key: 'allocate',
      value: function allocate(width, height) {
        var node = null;
        this._validateSize(width, height);
        return this._allocate(width, height);
      }
    }, {
      key: 'allocateNode',
      value: function allocateNode(width, height) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          try {
            _this._validateSize(width, height);
            resolve(_this._allocate(width, height));
          } catch (error) {
            reject(error);
          }
          ;
        });
      }
    }, {
      key: 'allocateASync',
      value: function allocateASync(width, height) {
        var _this2 = this;
        if (!Array.isArray(this._queue)) {
          this._queue = [];
        }
        var queueEntry = undefined;
        var promise = new Promise(function(resolve, reject) {
          try {
            _this2._validateSize(width, height);
            queueEntry = {
              resolve: resolve,
              reject: reject,
              width: width,
              height: height
            };
          } catch (error) {
            reject(error);
          }
          ;
        });
        if (queueEntry) {
          queueEntry.promise = promise;
          this._queue.push(queueEntry);
        }
        return promise;
      }
    }, {
      key: 'solveASync',
      value: function solveASync() {
        var _this3 = this;
        if (!Array.isArray(this._queue)) {
          throw new Error('You\'re trying to resolve a queue which hasn\'t been set up. Call allocateASync before using this.');
        }
        var promises = [];
        this._queue.forEach(function(entry) {
          var promise = entry.promise;
          var resolve = entry.resolve;
          var reject = entry.reject;
          var width = entry.width;
          var height = entry.height;
          var node = _this3._allocate(width, height);
          resolve(node);
          promises.push(promise);
        });
        this._queue = [];
        return Promise.all(promises);
      }
    }, {
      key: '_validateSize',
      value: function _validateSize(width, height) {
        if (width > this.textureSize) {
          throw new Error('Width of ' + width + ' is too large for these textures');
        }
        if (height > this.textureSize) {
          throw new Error('Height of ' + height + ' is too large for these textures');
        }
      }
    }, {
      key: '_allocate',
      value: function _allocate(width, height) {
        var node = null;
        this.knapsacks.forEach(function(knapsack) {
          if (node === null || node === undefined) {
            node = knapsack.allocateNode(width, height);
          }
        });
        if (node === null) {
          var knapsack = this._addKnapsack(this.textureSize);
          node = knapsack.allocateNode(width, height);
        }
        return node;
      }
    }, {
      key: 'release',
      value: function release(node) {
        if (node) {
          node.release();
        }
      }
    }, {
      key: 'textureSize',
      get: function get() {
        return this.size;
      }
    }]);
    return TextureManager;
  })();
  return TextureManager;
});

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("bd", ["bc"], function(main) {
  return main;
});

_removeDefine();
})();
$__System.registerDynamic("be", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function() {
    if ('performance' in window === false) {
      window.performance = {};
    }
    Date.now = (Date.now || function() {
      return new Date().getTime();
    });
    if ('now' in window.performance === false) {
      var offset = window.performance.timing && window.performance.timing.navigationStart ? window.performance.timing.navigationStart : Date.now();
      window.performance.now = function() {
        return Date.now() - offset;
      };
    }
  })();
  var TWEEN = TWEEN || (function() {
    var _tweens = [];
    return {
      getAll: function() {
        return _tweens;
      },
      removeAll: function() {
        _tweens = [];
      },
      add: function(tween) {
        _tweens.push(tween);
      },
      remove: function(tween) {
        var i = _tweens.indexOf(tween);
        if (i !== -1) {
          _tweens.splice(i, 1);
        }
      },
      update: function(time) {
        if (_tweens.length === 0) {
          return false;
        }
        var i = 0;
        time = time !== undefined ? time : window.performance.now();
        while (i < _tweens.length) {
          if (_tweens[i].update(time)) {
            i++;
          } else {
            _tweens.splice(i, 1);
          }
        }
        return true;
      }
    };
  })();
  TWEEN.Tween = function(object) {
    var _object = object;
    var _valuesStart = {};
    var _valuesEnd = {};
    var _valuesStartRepeat = {};
    var _duration = 1000;
    var _repeat = 0;
    var _yoyo = false;
    var _isPlaying = false;
    var _reversed = false;
    var _delayTime = 0;
    var _startTime = null;
    var _easingFunction = TWEEN.Easing.Linear.None;
    var _interpolationFunction = TWEEN.Interpolation.Linear;
    var _chainedTweens = [];
    var _onStartCallback = null;
    var _onStartCallbackFired = false;
    var _onUpdateCallback = null;
    var _onCompleteCallback = null;
    var _onStopCallback = null;
    for (var field in object) {
      _valuesStart[field] = parseFloat(object[field], 10);
    }
    this.to = function(properties, duration) {
      if (duration !== undefined) {
        _duration = duration;
      }
      _valuesEnd = properties;
      return this;
    };
    this.start = function(time) {
      TWEEN.add(this);
      _isPlaying = true;
      _onStartCallbackFired = false;
      _startTime = time !== undefined ? time : window.performance.now();
      _startTime += _delayTime;
      for (var property in _valuesEnd) {
        if (_valuesEnd[property] instanceof Array) {
          if (_valuesEnd[property].length === 0) {
            continue;
          }
          _valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);
        }
        _valuesStart[property] = _object[property];
        if ((_valuesStart[property] instanceof Array) === false) {
          _valuesStart[property] *= 1.0;
        }
        _valuesStartRepeat[property] = _valuesStart[property] || 0;
      }
      return this;
    };
    this.stop = function() {
      if (!_isPlaying) {
        return this;
      }
      TWEEN.remove(this);
      _isPlaying = false;
      if (_onStopCallback !== null) {
        _onStopCallback.call(_object);
      }
      this.stopChainedTweens();
      return this;
    };
    this.stopChainedTweens = function() {
      for (var i = 0,
          numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
        _chainedTweens[i].stop();
      }
    };
    this.delay = function(amount) {
      _delayTime = amount;
      return this;
    };
    this.repeat = function(times) {
      _repeat = times;
      return this;
    };
    this.yoyo = function(yoyo) {
      _yoyo = yoyo;
      return this;
    };
    this.easing = function(easing) {
      _easingFunction = easing;
      return this;
    };
    this.interpolation = function(interpolation) {
      _interpolationFunction = interpolation;
      return this;
    };
    this.chain = function() {
      _chainedTweens = arguments;
      return this;
    };
    this.onStart = function(callback) {
      _onStartCallback = callback;
      return this;
    };
    this.onUpdate = function(callback) {
      _onUpdateCallback = callback;
      return this;
    };
    this.onComplete = function(callback) {
      _onCompleteCallback = callback;
      return this;
    };
    this.onStop = function(callback) {
      _onStopCallback = callback;
      return this;
    };
    this.update = function(time) {
      var property;
      var elapsed;
      var value;
      if (time < _startTime) {
        return true;
      }
      if (_onStartCallbackFired === false) {
        if (_onStartCallback !== null) {
          _onStartCallback.call(_object);
        }
        _onStartCallbackFired = true;
      }
      elapsed = (time - _startTime) / _duration;
      elapsed = elapsed > 1 ? 1 : elapsed;
      value = _easingFunction(elapsed);
      for (property in _valuesEnd) {
        var start = _valuesStart[property] || 0;
        var end = _valuesEnd[property];
        if (end instanceof Array) {
          _object[property] = _interpolationFunction(end, value);
        } else {
          if (typeof(end) === 'string') {
            end = start + parseFloat(end, 10);
          }
          if (typeof(end) === 'number') {
            _object[property] = start + (end - start) * value;
          }
        }
      }
      if (_onUpdateCallback !== null) {
        _onUpdateCallback.call(_object, value);
      }
      if (elapsed === 1) {
        if (_repeat > 0) {
          if (isFinite(_repeat)) {
            _repeat--;
          }
          for (property in _valuesStartRepeat) {
            if (typeof(_valuesEnd[property]) === 'string') {
              _valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property], 10);
            }
            if (_yoyo) {
              var tmp = _valuesStartRepeat[property];
              _valuesStartRepeat[property] = _valuesEnd[property];
              _valuesEnd[property] = tmp;
            }
            _valuesStart[property] = _valuesStartRepeat[property];
          }
          if (_yoyo) {
            _reversed = !_reversed;
          }
          _startTime = time + _delayTime;
          return true;
        } else {
          if (_onCompleteCallback !== null) {
            _onCompleteCallback.call(_object);
          }
          for (var i = 0,
              numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
            _chainedTweens[i].start(_startTime + _duration);
          }
          return false;
        }
      }
      return true;
    };
  };
  TWEEN.Easing = {
    Linear: {None: function(k) {
        return k;
      }},
    Quadratic: {
      In: function(k) {
        return k * k;
      },
      Out: function(k) {
        return k * (2 - k);
      },
      InOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k;
        }
        return -0.5 * (--k * (k - 2) - 1);
      }
    },
    Cubic: {
      In: function(k) {
        return k * k * k;
      },
      Out: function(k) {
        return --k * k * k + 1;
      },
      InOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k + 2);
      }
    },
    Quartic: {
      In: function(k) {
        return k * k * k * k;
      },
      Out: function(k) {
        return 1 - (--k * k * k * k);
      },
      InOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k * k;
        }
        return -0.5 * ((k -= 2) * k * k * k - 2);
      }
    },
    Quintic: {
      In: function(k) {
        return k * k * k * k * k;
      },
      Out: function(k) {
        return --k * k * k * k * k + 1;
      },
      InOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k * k * k + 2);
      }
    },
    Sinusoidal: {
      In: function(k) {
        return 1 - Math.cos(k * Math.PI / 2);
      },
      Out: function(k) {
        return Math.sin(k * Math.PI / 2);
      },
      InOut: function(k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
      }
    },
    Exponential: {
      In: function(k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
      },
      Out: function(k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
      },
      InOut: function(k) {
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if ((k *= 2) < 1) {
          return 0.5 * Math.pow(1024, k - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
      }
    },
    Circular: {
      In: function(k) {
        return 1 - Math.sqrt(1 - k * k);
      },
      Out: function(k) {
        return Math.sqrt(1 - (--k * k));
      },
      InOut: function(k) {
        if ((k *= 2) < 1) {
          return -0.5 * (Math.sqrt(1 - k * k) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
      }
    },
    Elastic: {
      In: function(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      },
      Out: function(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return (a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1);
      },
      InOut: function(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        if ((k *= 2) < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        }
        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
      }
    },
    Back: {
      In: function(k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
      },
      Out: function(k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
      },
      InOut: function(k) {
        var s = 1.70158 * 1.525;
        if ((k *= 2) < 1) {
          return 0.5 * (k * k * ((s + 1) * k - s));
        }
        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
      }
    },
    Bounce: {
      In: function(k) {
        return 1 - TWEEN.Easing.Bounce.Out(1 - k);
      },
      Out: function(k) {
        if (k < (1 / 2.75)) {
          return 7.5625 * k * k;
        } else if (k < (2 / 2.75)) {
          return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
        } else if (k < (2.5 / 2.75)) {
          return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
        } else {
          return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
        }
      },
      InOut: function(k) {
        if (k < 0.5) {
          return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
        }
        return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
      }
    }
  };
  TWEEN.Interpolation = {
    Linear: function(v, k) {
      var m = v.length - 1;
      var f = m * k;
      var i = Math.floor(f);
      var fn = TWEEN.Interpolation.Utils.Linear;
      if (k < 0) {
        return fn(v[0], v[1], f);
      }
      if (k > 1) {
        return fn(v[m], v[m - 1], m - f);
      }
      return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function(v, k) {
      var b = 0;
      var n = v.length - 1;
      var pw = Math.pow;
      var bn = TWEEN.Interpolation.Utils.Bernstein;
      for (var i = 0; i <= n; i++) {
        b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
      }
      return b;
    },
    CatmullRom: function(v, k) {
      var m = v.length - 1;
      var f = m * k;
      var i = Math.floor(f);
      var fn = TWEEN.Interpolation.Utils.CatmullRom;
      if (v[0] === v[m]) {
        if (k < 0) {
          i = Math.floor(f = m * (1 + k));
        }
        return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
      } else {
        if (k < 0) {
          return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
        }
        if (k > 1) {
          return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
        }
        return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
      }
    },
    Utils: {
      Linear: function(p0, p1, t) {
        return (p1 - p0) * t + p0;
      },
      Bernstein: function(n, i) {
        var fc = TWEEN.Interpolation.Utils.Factorial;
        return fc(n) / fc(i) / fc(n - i);
      },
      Factorial: (function() {
        var a = [1];
        return function(n) {
          var s = 1;
          if (a[n]) {
            return a[n];
          }
          for (var i = n; i > 1; i--) {
            s *= i;
          }
          a[n] = s;
          return s;
        };
      })(),
      CatmullRom: function(p0, p1, p2, p3, t) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
      }
    }
  };
  (function(root) {
    if (typeof define === 'function' && define.amd) {
      define([], function() {
        return TWEEN;
      });
    } else if (typeof exports === 'object') {
      module.exports = TWEEN;
    } else {
      root.TWEEN = TWEEN;
    }
  })(this);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13", ["be"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('be');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bf", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Stats = function() {
    var now = (self.performance && self.performance.now) ? self.performance.now.bind(performance) : Date.now;
    var startTime = now(),
        prevTime = startTime;
    var frames = 0,
        mode = 0;
    function createElement(tag, id, css) {
      var element = document.createElement(tag);
      element.id = id;
      element.style.cssText = css;
      return element;
    }
    function createPanel(id, fg, bg) {
      var div = createElement('div', id, 'padding:0 0 3px 3px;text-align:left;background:' + bg);
      var text = createElement('div', id + 'Text', 'font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px;color:' + fg);
      text.innerHTML = id.toUpperCase();
      div.appendChild(text);
      var graph = createElement('div', id + 'Graph', 'width:74px;height:30px;background:' + fg);
      div.appendChild(graph);
      for (var i = 0; i < 74; i++) {
        graph.appendChild(createElement('span', '', 'width:1px;height:30px;float:left;opacity:0.9;background:' + bg));
      }
      return div;
    }
    function setMode(value) {
      var children = container.children;
      for (var i = 0; i < children.length; i++) {
        children[i].style.display = i === value ? 'block' : 'none';
      }
      mode = value;
    }
    function updateGraph(dom, value) {
      var child = dom.appendChild(dom.firstChild);
      child.style.height = Math.min(30, 30 - value * 30) + 'px';
    }
    var container = createElement('div', 'stats', 'width:80px;opacity:0.9;cursor:pointer');
    container.addEventListener('mousedown', function(event) {
      event.preventDefault();
      setMode(++mode % container.children.length);
    }, false);
    var fps = 0,
        fpsMin = Infinity,
        fpsMax = 0;
    var fpsDiv = createPanel('fps', '#0ff', '#002');
    var fpsText = fpsDiv.children[0];
    var fpsGraph = fpsDiv.children[1];
    container.appendChild(fpsDiv);
    var ms = 0,
        msMin = Infinity,
        msMax = 0;
    var msDiv = createPanel('ms', '#0f0', '#020');
    var msText = msDiv.children[0];
    var msGraph = msDiv.children[1];
    container.appendChild(msDiv);
    if (self.performance && self.performance.memory) {
      var mem = 0,
          memMin = Infinity,
          memMax = 0;
      var memDiv = createPanel('mb', '#f08', '#201');
      var memText = memDiv.children[0];
      var memGraph = memDiv.children[1];
      container.appendChild(memDiv);
    }
    setMode(mode);
    return {
      REVISION: 14,
      domElement: container,
      setMode: setMode,
      begin: function() {
        startTime = now();
      },
      end: function() {
        var time = now();
        ms = time - startTime;
        msMin = Math.min(msMin, ms);
        msMax = Math.max(msMax, ms);
        msText.textContent = (ms | 0) + ' MS (' + (msMin | 0) + '-' + (msMax | 0) + ')';
        updateGraph(msGraph, ms / 200);
        frames++;
        if (time > prevTime + 1000) {
          fps = Math.round((frames * 1000) / (time - prevTime));
          fpsMin = Math.min(fpsMin, fps);
          fpsMax = Math.max(fpsMax, fps);
          fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
          updateGraph(fpsGraph, fps / 100);
          prevTime = time;
          frames = 0;
          if (mem !== undefined) {
            var heapSize = performance.memory.usedJSHeapSize;
            var heapSizeLimit = performance.memory.jsHeapSizeLimit;
            mem = Math.round(heapSize * 0.000000954);
            memMin = Math.min(memMin, mem);
            memMax = Math.max(memMax, mem);
            memText.textContent = mem + ' MB (' + memMin + '-' + memMax + ')';
            updateGraph(memGraph, heapSize / heapSizeLimit);
          }
        }
        return time;
      },
      update: function() {
        startTime = this.end();
      }
    };
  };
  if (typeof module === 'object') {
    module.exports = Stats;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c0", ["bf"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('bf');
  global.define = __define;
  return module.exports;
});

$__System.register('c1', ['7', '8', '9', '13', 'b', '7d', '6b', '1e', '6c', 'bd', 'c0'], function (_export) {
  var settings, _createClass, _classCallCheck, TWEEN, config, OrbitControls, UI, PerspectiveCamera, WebGLRenderer, Euler, Matrix4, degToRad, TextureManager, Stats, Renderer;

  return {
    setters: [function (_3) {
      settings = _3['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_4) {
      TWEEN = _4['default'];
    }, function (_b) {
      config = _b['default'];
    }, function (_d) {
      OrbitControls = _d['default'];
    }, function (_b2) {
      UI = _b2['default'];
    }, function (_e) {
      PerspectiveCamera = _e.PerspectiveCamera;
      WebGLRenderer = _e.WebGLRenderer;
      Euler = _e.Euler;
      Matrix4 = _e.Matrix4;
    }, function (_c) {
      degToRad = _c.degToRad;
    }, function (_bd) {
      TextureManager = _bd['default'];
    }, function (_c0) {
      Stats = _c0['default'];
    }],
    execute: function () {
      /**
        * @author Lianna Eeftinck / https://github.com/Leeft
        */

      'use strict';

      Renderer = (function () {
        function Renderer(map) {
          _classCallCheck(this, Renderer);

          this.map = map;

          this.composer = null;
          this.FXAA = null;
          this.camera = null;

          if (config.debug) {
            console.info('Additional debugging enabled');
          }

          if (config.quality === 'low') {
            console.info('Low quality mode enabled');
          }

          this.textureManager = new TextureManager(config.quality === 'low' ? 1024 : 2048);
          //this.textureManager.debug = ( config.debug ) ? true : false;

          this.width = window.innerWidth;
          this.height = window.innerHeight;

          this.dpr = 1;
          if (window.devicePixelRatio !== undefined) {
            this.dpr = window.devicePixelRatio;
          }

          this.container = document.getElementById('sc-map-webgl-container');

          this.camera = new PerspectiveCamera(45, this.width / this.height, 10, 1600);
          this.camera.position.copy(settings.camera.camera);
          this.camera.setViewOffset(this.width, this.height, -(UI.containerWidth() / 2), 0, this.width, this.height);

          this.controls = new OrbitControls(this);
          this.controls.target.copy(settings.camera.target);
          this.controls.rotateSpeed = config.rotateSpeed;
          this.controls.zoomSpeed = config.zoomSpeed;
          this.controls.panSpeed = config.panSpeed;
          this.controls.enableRotate = !settings.control.rotationLocked;
          this.controls.enableDamping = true;
          this.controls.damingFactor = 0.5;
          this.controls.minPolarAngle = 0;
          this.controls.maxPolarAngle = degToRad(85);
          this.controls.minDistance = 20;
          this.controls.maxDistance = 800;
          this.controls.keyPanSpeed = 40;

          this.threeRenderer = new WebGLRenderer({ antialias: config.quality !== 'low' });
          this.threeRenderer.shadowMap.enabled = false;

          if (config.debug) {
            console.info('SCMAP renderer:', this);
            console.info('THREE renderer:', this.threeRenderer);
          }

          if (!settings.effect.Antialias) {
            this.threeRenderer.autoClear = false;
          }

          this.threeRenderer.setClearColor(0x000000, 1);
          this.threeRenderer.setSize(this.width, this.height);

          this.container.appendChild(this.threeRenderer.domElement);

          // Stats

          this.stats = new Stats();

          // Event handlers

          window.addEventListener('resize', this.resize.bind(this), false);
          document.addEventListener('change', this.render.bind(this), false);

          // FIXME: Bring in these classes again, re-enable the feature?
          //if ( ! settings.effect.Antialias )
          //{
          //  let renderModel = new THREE.RenderPass( map.scene, this.camera );

          //  this.FXAA = new THREE.ShaderPass( THREE.FXAAShader );
          //  this.FXAA.uniforms.resolution.value.set( 1 / (this.width * this.dpr), 1 / (this.height * this.dpr) );
          //  this.FXAA.enabled = settings.effect.FXAA;

          //  let effectBloom = new THREE.BloomPass( 0.6 );
          //  effectBloom.enabled = settings.effect.Bloom;

          //  let effectCopy = new THREE.ShaderPass( THREE.CopyShader );
          //  effectCopy.renderToScreen = true;

          //  this.composer = new THREE.EffectComposer( this.threeRenderer );
          //  this.composer.setSize( this.width * this.dpr, this.height * this.dpr );
          //  this.composer.addPass( renderModel );
          //  this.composer.addPass( this.FXAA );
          //  this.composer.addPass( effectBloom );
          //  this.composer.addPass( effectCopy );
          //}
        }

        _createClass(Renderer, [{
          key: 'cameraRotationMatrix',
          value: function cameraRotationMatrix() {
            var euler = new Euler(this.controls.getPolarAngle() + Math.PI / 2, this.controls.getAzimuthalAngle(), 0, 'YXZ');
            return new Matrix4().makeRotationFromEuler(euler);
          }
        }, {
          key: 'resize',
          value: function resize() {
            this.width = window.innerWidth;
            this.height = window.innerHeight;

            this.camera.aspect = this.width / this.height;
            this.camera.setViewOffset(this.width, this.height, -(UI.containerWidth() / 2), 0, this.width, this.height);
            this.camera.updateProjectionMatrix();

            if (this.FXAA) {
              this.FXAA.uniforms.resolution.value.set(1 / (this.width * this.dpr), 1 / (this.height * this.dpr));
            }

            this.threeRenderer.setSize(this.width, this.height);

            if (this.composer) {
              this.composer.reset();
            }

            UI.jScrollPane().reinitialise();
          }
        }, {
          key: 'render',
          value: function render() {
            this.controls.update();
            this.map.animate();

            TWEEN.update();

            if (config.debug) {
              UI.debugRenderer(this.threeRenderer.info);
            }

            this.stats.update();

            if (this.composer) {
              this.threeRenderer.clear();
              this.composer.render();
            } else {
              this.threeRenderer.render(this.map.scene, this.camera);
            }
          }
        }, {
          key: 'stats',
          get: function get() {
            return this._stats;
          },
          set: function set(stats) {
            this._stats = stats;
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            stats.domElement.style.right = '0px';
            stats.domElement.style.display = settings.renderer.Stats ? 'block' : 'none';
            stats.domElement.style.zIndex = '100';
            this.container.appendChild(stats.domElement);
          }
        }]);

        return Renderer;
      })();

      _export('default', Renderer);
    }
  };
});
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
(function(global, factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ? factory(global, true) : function(w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  var arr = [];
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};
  var document = window.document,
      version = "2.1.4",
      jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      },
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      rmsPrefix = /^-ms-/,
      rdashAlpha = /-([\da-z])/gi,
      fcamelCase = function(all, letter) {
        return letter.toUpperCase();
      };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    selector: "",
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      return num != null ? (num < 0 ? this[num + this.length] : this[num]) : slice.call(this);
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function(callback, args) {
      return jQuery.each(this, callback, args);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor(null);
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray,
    isWindow: function(obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function(obj) {
      return !jQuery.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
    },
    isPlainObject: function(obj) {
      if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }
      return true;
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    },
    globalEval: function(code) {
      var script,
          indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf("use strict") === 1) {
          script = document.createElement("script");
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function(obj, callback, args) {
      var value,
          i = 0,
          length = obj.length,
          isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }
      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var value,
          i = 0,
          length = elems.length,
          isArray = isArraylike(elems),
          ret = [];
      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function(fn, context) {
      var tmp,
          args,
          proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support
  });
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArraylike(obj) {
    var length = "length" in obj && obj.length,
        type = jQuery.type(obj);
    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle = (function(window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        MAX_NEGATIVE = 1 << 31,
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
              len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        identifier = characterEncoding.replace("w", "w#"),
        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + characterEncoding + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + characterEncoding + ")"),
          "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
          "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        rescape = /'|\\/g,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        unloadHandler = function() {
          setDocument();
        };
    try {
      push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {apply: arr.length ? function(target, els) {
          push_native.apply(target, slice.call(els));
        } : function(target, els) {
          var j = target.length,
              i = 0;
          while ((target[j++] = els[i++])) {}
          target.length = j - 1;
        }};
    }
    function Sizzle(selector, context, results, seed) {
      var match,
          elem,
          m,
          nodeType,
          i,
          groups,
          old,
          nid,
          newContext,
          newSelector;
      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }
      context = context || document;
      results = results || [];
      nodeType = context.nodeType;
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed && documentIsHTML) {
        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
          if ((m = match[1])) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              if (elem && elem.parentNode) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }
          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results;
          } else if ((m = match[3]) && support.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType !== 1 && selector;
          if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
            groups = tokenize(selector);
            if ((old = context.getAttribute("id"))) {
              nid = old.replace(rescape, "\\$&");
            } else {
              context.setAttribute("id", nid);
            }
            nid = "[id='" + nid + "'] ";
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            newSelector = groups.join(",");
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {} finally {
              if (!old) {
                context.removeAttribute("id");
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement("div");
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = attrs.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare,
          parent,
          doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = doc.documentElement;
      parent = doc.defaultView;
      if (parent && parent !== parent.top) {
        if (parent.addEventListener) {
          parent.addEventListener("unload", unloadHandler, false);
        } else if (parent.attachEvent) {
          parent.attachEvent("onunload", unloadHandler);
        }
      }
      documentIsHTML = !isXML(doc);
      support.attributes = assert(function(div) {
        div.className = "i";
        return !div.getAttribute("className");
      });
      support.getElementsByTagName = assert(function(div) {
        div.appendChild(doc.createComment(""));
        return !div.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
      support.getById = assert(function(div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var m = context.getElementById(id);
            return m && m.parentNode ? [m] : [];
          }
        };
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
      } else {
        delete Expr.find["ID"];
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function(tag, context) {
        var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while ((elem = results[i++])) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
        if (documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if ((support.qsa = rnative.test(doc.querySelectorAll))) {
        assert(function(div) {
          docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>";
          if (div.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!div.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!div.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!div.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function(div) {
          var input = doc.createElement("input");
          input.setAttribute("type", "hidden");
          div.appendChild(input).setAttribute("name", "D");
          if (div.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (!div.querySelectorAll(":enabled").length) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          div.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
        assert(function(div) {
          support.disconnectedMatch = matches.call(div, "div");
          matches.call(div, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while ((b = b.parentNode)) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
          if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];
        if (!aup || !bup) {
          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        while ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function(elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
      if (!nodeType) {
        while ((node = elem[i++])) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {dir: "parentNode"},
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {dir: "previousSibling"}
      },
      preFilter: {
        "ATTR": function(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +((match[7] + match[8]) || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function(match) {
          var excess,
              unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function(name, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? function(elem) {
            return !!elem.parentNode;
          } : function(elem, context, xml) {
            var cache,
                outerCache,
                node,
                diff,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while ((node = node[dir])) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                outerCache = parent[expando] || (parent[expando] = {});
                cache = outerCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = cache[0] === dirruns && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    outerCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                diff = cache[1];
              } else {
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    if (useCache) {
                      (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || (diff % first === 0 && diff / first >= 0);
            }
          };
        },
        "PSEUDO": function(pseudo, argument) {
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function(elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function(selector) {
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;
            while (i--) {
              if ((elem = unmatched[i])) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function(elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function(text) {
          text = text.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "lang": markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        "target": function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function(elem) {
          return elem === docElem;
        },
        "focus": function(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "enabled": function(elem) {
          return elem.disabled === false;
        },
        "disabled": function(elem) {
          return elem.disabled === true;
        },
        "checked": function(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },
        "selected": function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        "empty": function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "header": function(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        "first": createPositionalPseudo(function() {
          return [0];
        }),
        "last": createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }
        matched = false;
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          checkNonElements = base && dir === "parentNode",
          doneName = done++;
      return combinator.first ? function(elem, context, xml) {
        while ((elem = elem[dir])) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function(elem, context, xml) {
        var oldCache,
            outerCache,
            newCache = [dirruns, doneName];
        if (xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return (newCache[2] = oldCache[2]);
              } else {
                outerCache[dir] = newCache;
                if ((newCache[2] = matcher(elem, context, xml))) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;
            if (outermost) {
              outermostContext = context !== document && context;
            }
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function(selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function(div1) {
      return div1.compareDocumentPosition(document.createElement("div")) & 1;
    });
    if (!assert(function(div) {
      div.innerHTML = "<a href='#'></a>";
      return div.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function(div) {
      div.innerHTML = "<input/>";
      div.firstChild.setAttribute("value", "");
      return div.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function(elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function(div) {
      return div.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);
  var risSimple = /^.[^:#\[\.,]*$/;
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier === "string") {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function(elem) {
      return (indexOf.call(qualifier, elem) >= 0) !== not;
    });
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
          len = this.length,
          ret = [],
          self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
  var rootjQuery,
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
      init = jQuery.fn.init = function(selector, context) {
        var match,
            elem;
        if (!selector) {
          return this;
        }
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (jQuery.isFunction(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document.getElementById(match[2]);
              if (elem && elem.parentNode) {
                this.length = 1;
                this[0] = elem;
              }
              this.context = document;
              this.selector = selector;
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || rootjQuery).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this.context = this[0] = selector;
          this.length = 1;
          return this;
        } else if (jQuery.isFunction(selector)) {
          return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
          this.selector = selector.selector;
          this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
      };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
  jQuery.extend({
    dir: function(elem, dir, until) {
      var matched = [],
          truncate = until !== undefined;
      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },
    sibling: function(n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    }
  });
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function(selector, context) {
      return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return jQuery.dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return jQuery.dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return jQuery.dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return jQuery.dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return jQuery.dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return jQuery.dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function(elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.unique(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnotwhite = (/\S+/g);
  var optionsCache = {};
  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ? (optionsCache[options] || createOptions(options)) : jQuery.extend({}, options);
    var memory,
        fired,
        firing,
        firingStart,
        firingLength,
        firingIndex,
        list = [],
        stack = !options.once && [],
        fire = function(data) {
          memory = options.memory && data;
          fired = true;
          firingIndex = firingStart || 0;
          firingStart = 0;
          firingLength = list.length;
          firing = true;
          for (; list && firingIndex < firingLength; firingIndex++) {
            if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
              memory = false;
              break;
            }
          }
          firing = false;
          if (list) {
            if (stack) {
              if (stack.length) {
                fire(stack.shift());
              }
            } else if (memory) {
              list = [];
            } else {
              self.disable();
            }
          }
        },
        self = {
          add: function() {
            if (list) {
              var start = list.length;
              (function add(args) {
                jQuery.each(args, function(_, arg) {
                  var type = jQuery.type(arg);
                  if (type === "function") {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && type !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (firing) {
                firingLength = list.length;
              } else if (memory) {
                firingStart = start;
                fire(memory);
              }
            }
            return this;
          },
          remove: function() {
            if (list) {
              jQuery.each(arguments, function(_, arg) {
                var index;
                while ((index = jQuery.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  if (firing) {
                    if (index <= firingLength) {
                      firingLength--;
                    }
                    if (index <= firingIndex) {
                      firingIndex--;
                    }
                  }
                }
              });
            }
            return this;
          },
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
          },
          empty: function() {
            list = [];
            firingLength = 0;
            return this;
          },
          disable: function() {
            list = stack = memory = undefined;
            return this;
          },
          disabled: function() {
            return !list;
          },
          lock: function() {
            stack = undefined;
            if (!memory) {
              self.disable();
            }
            return this;
          },
          locked: function() {
            return !stack;
          },
          fireWith: function(context, args) {
            if (list && (!fired || stack)) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              if (firing) {
                stack.push(args);
              } else {
                fire(args);
              }
            }
            return this;
          },
          fire: function() {
            self.fireWith(this, arguments);
            return this;
          },
          fired: function() {
            return !!fired;
          }
        };
    return self;
  };
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
          state = "pending",
          promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            then: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(i, tuple) {
                  var fn = jQuery.isFunction(fns[i]) && fns[i];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && jQuery.isFunction(returned.promise)) {
                      returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                    } else {
                      newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          },
          deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
            stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(subordinate) {
      var i = 0,
          resolveValues = slice.call(arguments),
          length = resolveValues.length,
          remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
          deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
          updateFunc = function(i, contexts, values) {
            return function(value) {
              contexts[i] = this;
              values[i] = arguments.length > 1 ? slice.call(arguments) : value;
              if (values === progressValues) {
                deferred.notifyWith(contexts, values);
              } else if (!(--remaining)) {
                deferred.resolveWith(contexts, values);
              }
            };
          },
          progressValues,
          progressContexts,
          resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  var readyList;
  jQuery.fn.ready = function(fn) {
    jQuery.ready.promise().done(fn);
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    }
  });
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed, false);
    window.removeEventListener("load", completed, false);
    jQuery.ready();
  }
  jQuery.ready.promise = function(obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === "complete") {
        setTimeout(jQuery.ready);
      } else {
        document.addEventListener("DOMContentLoaded", completed, false);
        window.addEventListener("load", completed, false);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.ready.promise();
  var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null;
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!jQuery.isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
  };
  jQuery.acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };
  function Data() {
    Object.defineProperty(this.cache = {}, 0, {get: function() {
        return {};
      }});
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.accepts = jQuery.acceptData;
  Data.prototype = {
    key: function(owner) {
      if (!Data.accepts(owner)) {
        return 0;
      }
      var descriptor = {},
          unlock = owner[this.expando];
      if (!unlock) {
        unlock = Data.uid++;
        try {
          descriptor[this.expando] = {value: unlock};
          Object.defineProperties(owner, descriptor);
        } catch (e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }
      if (!this.cache[unlock]) {
        this.cache[unlock] = {};
      }
      return unlock;
    },
    set: function(owner, data, value) {
      var prop,
          unlock = this.key(owner),
          cache = this.cache[unlock];
      if (typeof data === "string") {
        cache[data] = value;
      } else {
        if (jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);
        } else {
          for (prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function(owner, key) {
      var cache = this.cache[this.key(owner)];
      return key === undefined ? cache : cache[key];
    },
    access: function(owner, key, value) {
      var stored;
      if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i,
          name,
          camel,
          unlock = this.key(owner),
          cache = this.cache[unlock];
      if (key === undefined) {
        this.cache[unlock] = {};
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [key, camel];
          } else {
            name = camel;
            name = name in cache ? [name] : (name.match(rnotwhite) || []);
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function(owner) {
      return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
    },
    discard: function(owner) {
      if (owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    }
  };
  var data_priv = new Data();
  var data_user = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /([A-Z])/g;
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
        } catch (e) {}
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },
    data: function(elem, name, data) {
      return data_user.access(elem, name, data);
    },
    removeData: function(elem, name) {
      data_user.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return data_priv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      data_priv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = data_user.get(elem);
          if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            data_priv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          data_user.set(this, key);
        });
      }
      return access(this, function(value) {
        var data,
            camelKey = jQuery.camelCase(key);
        if (elem && value === undefined) {
          data = data_user.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = data_user.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function() {
          var data = data_user.get(this, camelKey);
          data_user.set(this, camelKey, value);
          if (key.indexOf("-") !== -1 && data !== undefined) {
            data_user.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        data_user.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = data_priv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function() {
            jQuery.dequeue(elem, type);
          };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return data_priv.get(elem, key) || data_priv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
          data_priv.remove(elem, [type + "queue", key]);
        })});
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function() {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if (!(--count)) {
              defer.resolveWith(elements, [elements]);
            }
          };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = data_priv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHidden = function(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
  };
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  (function() {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var strundefined = typeof undefined;
  support.focusinBubbles = "onfocusin" in window;
  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
      rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = data_priv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = data_priv.hasData(elem) && data_priv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, "events");
      }
    },
    trigger: function(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") >= 0) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && jQuery.acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function(event) {
      event = jQuery.event.fix(event);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue = [],
          args = slice.call(arguments),
          handlers = (data_priv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i,
          matches,
          sel,
          handleObj,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target;
      if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.disabled !== true || event.type !== "click") {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(event, original) {
        var eventDoc,
            doc,
            body,
            button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
        }
        return event;
      }
    },
    fix: function(event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i,
          prop,
          copy,
          type = event.type,
          originalEvent = event,
          fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: {noBubble: true},
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return jQuery.nodeName(event.target, "a");
        }
      },
      beforeunload: {postDispatch: function(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }}
    },
    simulate: function(type, elem, event, bubble) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true,
        originalEvent: {}
      });
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;
        if (!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  if (!support.focusinBubbles) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
              attaches = data_priv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          data_priv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
              attaches = data_priv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            data_priv.remove(doc, fix);
          } else {
            data_priv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  jQuery.fn.extend({
    on: function(types, selector, data, fn, one) {
      var origFn,
          type;
      if (typeof types === "object") {
        if (typeof selector !== "string") {
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function(event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function() {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function(types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj,
          type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
      rtagName = /<([\w:]+)/,
      rhtml = /<|&#?\w+;/,
      rnoInnerhtml = /<(?:script|style|link)/i,
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rscriptType = /^$|\/(?:java|ecma)script/i,
      rscriptTypeMasked = /^true\/(.*)/,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
      wrapMap = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;
    for (; i < l; i++) {
      data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
    }
  }
  function cloneCopyEvent(src, dest) {
    var i,
        l,
        type,
        pdataOld,
        pdataCur,
        udataOld,
        udataCur,
        events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);
      data_user.set(dest, udataCur);
    }
  }
  function getAll(context, tag) {
    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.extend({
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    buildFragment: function(elems, context, scripts, selection) {
      var elem,
          tmp,
          tag,
          wrap,
          contains,
          j,
          fragment = context.createDocumentFragment(),
          nodes = [],
          i = 0,
          l = elems.length;
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (jQuery.type(elem) === "object") {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i = 0;
      while ((elem = nodes[i++])) {
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while ((elem = tmp[j++])) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    },
    cleanData: function(elems) {
      var data,
          elem,
          type,
          key,
          special = jQuery.event.special,
          i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (jQuery.acceptData(elem)) {
          key = elem[data_priv.expando];
          if (key && (data = data_priv.cache[key])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if (data_priv.cache[key]) {
              delete data_priv.cache[key];
            }
          }
        }
        delete data_user.cache[elem[data_user.expando]];
      }
    }
  });
  jQuery.fn.extend({
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function() {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function() {
      return this.domManip(arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return this.domManip(arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return this.domManip(arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return this.domManip(arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function(selector, keepData) {
      var elem,
          elems = selector ? jQuery.filter(selector, this) : this,
          i = 0;
      for (; (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, "script"));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function() {
      var elem,
          i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, "<$1></$2>");
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var arg = arguments[0];
      this.domManip(arguments, function(elem) {
        arg = this.parentNode;
        jQuery.cleanData(getAll(this));
        if (arg) {
          arg.replaceChild(elem, this);
        }
      });
      return arg && (arg.length || arg.nodeType) ? this : this.remove();
    },
    detach: function(selector) {
      return this.remove(selector, true);
    },
    domManip: function(args, callback) {
      args = concat.apply([], args);
      var fragment,
          first,
          scripts,
          hasScripts,
          node,
          doc,
          i = 0,
          l = this.length,
          set = this,
          iNoClone = l - 1,
          value = args[0],
          isFunction = jQuery.isFunction(value);
      if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
        return this.each(function(index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                if (node.src) {
                  if (jQuery._evalUrl) {
                    jQuery._evalUrl(node.src);
                  }
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                }
              }
            }
          }
        }
      }
      return this;
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var iframe,
      elemdisplay = {};
  function actualDisplay(name, doc) {
    var style,
        elem = jQuery(doc.createElement(name)).appendTo(doc.body),
        display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
    elem.detach();
    return display;
  }
  function defaultDisplay(nodeName) {
    var doc = document,
        display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === "none" || !display) {
        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
        doc = iframe[0].contentDocument;
        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  var rmargin = (/^margin/);
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    if (elem.ownerDocument.defaultView.opener) {
      return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    }
    return window.getComputedStyle(elem, null);
  };
  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        style = elem.style;
    computed = computed || getStyles(elem);
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
    }
    if (computed) {
      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {get: function() {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      }};
  }
  (function() {
    var pixelPositionVal,
        boxSizingReliableVal,
        docElem = document.documentElement,
        container = document.createElement("div"),
        div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
    container.appendChild(div);
    function computePixelPositionAndBoxSizingReliable() {
      div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
      div.innerHTML = "";
      docElem.appendChild(container);
      var divStyle = window.getComputedStyle(div, null);
      pixelPositionVal = divStyle.top !== "1%";
      boxSizingReliableVal = divStyle.width === "4px";
      docElem.removeChild(container);
    }
    if (window.getComputedStyle) {
      jQuery.extend(support, {
        pixelPosition: function() {
          computePixelPositionAndBoxSizingReliable();
          return pixelPositionVal;
        },
        boxSizingReliable: function() {
          if (boxSizingReliableVal == null) {
            computePixelPositionAndBoxSizingReliable();
          }
          return boxSizingReliableVal;
        },
        reliableMarginRight: function() {
          var ret,
              marginDiv = div.appendChild(document.createElement("div"));
          marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
          marginDiv.style.marginRight = marginDiv.style.width = "0";
          div.style.width = "1px";
          docElem.appendChild(container);
          ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
          docElem.removeChild(container);
          div.removeChild(marginDiv);
          return ret;
        }
      });
    }
  })();
  jQuery.swap = function(elem, options, callback, args) {
    var ret,
        name,
        old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
      rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
      cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
      cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      },
      cssPrefixes = ["Webkit", "O", "Moz", "ms"];
  function vendorPropName(style, name) {
    if (name in style) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
        origName = name,
        i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0,
        val = 0;
    for (; i < 4; i += 2) {
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true,
        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles(elem),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
  }
  function showHide(elements, show) {
    var display,
        elem,
        hidden,
        values = [],
        index = 0,
        length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = data_priv.get(elem, "olddisplay");
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === "none") {
          elem.style.display = "";
        }
        if (elem.style.display === "" && isHidden(elem)) {
          values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);
        if (display !== "none" || !hidden) {
          data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }
    return elements;
  }
  jQuery.extend({
    cssHooks: {opacity: {get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }}},
    cssNumber: {
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {"float": "cssFloat"},
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret,
          type,
          hooks,
          origName = jQuery.camelCase(name),
          style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number" && !jQuery.cssNumber[origName]) {
          value += "px";
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function(elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
      }
    };
  });
  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
    if (computed) {
      return jQuery.swap(elem, {"display": "inline-block"}, curCSS, [elem, "marginRight"]);
    }
  });
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
        var i = 0,
            expanded = {},
            parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }};
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || "swing";
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {_default: {
      get: function(tween) {
        var result;
        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }};
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }};
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow,
      timerId,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
      rrun = /queueHooks$/,
      animationPrefilters = [defaultPrefilter],
      tweeners = {"*": [function(prop, value) {
          var tween = this.createTween(prop, value),
              target = tween.cur(),
              parts = rfxnum.exec(value),
              unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
              start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
              scale = 1,
              maxIterations = 20;
          if (start && start[3] !== unit) {
            unit = unit || start[3];
            parts = parts || [];
            start = +target || 1;
            do {
              scale = scale || ".5";
              start = start / scale;
              jQuery.style(tween.elem, prop, start + unit);
            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
          }
          if (parts) {
            start = tween.start = +start || +target || 0;
            tween.unit = unit;
            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
          }
          return tween;
        }]};
  function createFxNow() {
    setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }
  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {height: type};
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
        collection = (tweeners[prop] || []).concat(tweeners["*"]),
        index = 0,
        length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        tween,
        hooks,
        oldfire,
        display,
        checkDisplay,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHidden(elem),
        dataShow = data_priv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      display = jQuery.css(elem, "display");
      checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
      if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
        style.display = "inline-block";
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      } else {
        display = undefined;
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, "fxshow", {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function() {
          jQuery(elem).hide();
        });
      }
      anim.done(function() {
        var prop;
        data_priv.remove(elem, "fxshow");
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }
    } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
      style.display = display;
    }
  }
  function propFilter(props, specialEasing) {
    var index,
        name,
        easing,
        value,
        hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = animationPrefilters.length,
        deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }),
        tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;
          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length) {
            return remaining;
          } else {
            deferred.resolveWith(elem, [animation]);
            return false;
          }
        },
        animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {specialEasing: {}}, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index = 0,
                length = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index < length; index++) {
              animation.tweens[index].run(1);
            }
            if (gotoEnd) {
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }),
        props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.split(" ");
      }
      var prop,
          index = 0,
          length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function(callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHidden).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || data_priv.get(this, "finish")) {
              anim.stop(true);
            }
          };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = data_priv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
            data = data_priv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {opacity: "show"},
    fadeOut: {opacity: "hide"},
    fadeToggle: {opacity: "toggle"}
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function() {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = setTimeout(next, time);
      hooks.stop = function() {
        clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var nodeHook,
      boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var hooks,
          ret,
          nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === strundefined) {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + "");
          return value;
        }
      } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        return ret == null ? undefined : ret;
      }
    },
    removeAttr: function(elem, value) {
      var name,
          propName,
          i = 0,
          attrNames = value && value.match(rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    },
    attrHooks: {type: {set: function(elem, value) {
          if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }}}
  });
  boolHook = {set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }};
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret,
          handle;
      if (!isXML) {
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
        attrHandle[name] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    propFix: {
      "for": "htmlFor",
      "class": "className"
    },
    prop: function(elem, name, value) {
      var ret,
          hooks,
          notxml,
          nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : (elem[name] = value);
      } else {
        return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
      }
    },
    propHooks: {tabIndex: {get: function(elem) {
          return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
        }}}
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {get: function(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }};
  }
  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  var rclass = /[\t\r\n\f]/g;
  jQuery.fn.extend({
    addClass: function(value) {
      var classes,
          elem,
          cur,
          clazz,
          j,
          finalValue,
          proceed = typeof value === "string" && value,
          i = 0,
          len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = jQuery.trim(cur);
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes,
          elem,
          cur,
          clazz,
          j,
          finalValue,
          proceed = arguments.length === 0 || typeof value === "string" && value,
          i = 0,
          len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") >= 0) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = value ? jQuery.trim(cur) : "";
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }
      return this.each(function() {
        if (type === "string") {
          var className,
              i = 0,
              self = jQuery(this),
              classNames = value.match(rnotwhite) || [];
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (type === strundefined || type === "boolean") {
          if (this.className) {
            data_priv.set(this, "__className__", this.className);
          }
          this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
        }
      });
    },
    hasClass: function(selector) {
      var className = " " + selector + " ",
          i = 0,
          l = this.length;
      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({val: function(value) {
      var hooks,
          ret,
          isFunction,
          elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }});
  jQuery.extend({valHooks: {
      option: {get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : jQuery.trim(jQuery.text(elem));
        }},
      select: {
        get: function(elem) {
          var value,
              option,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one" || index < 0,
              values = one ? null : [],
              max = one ? index + 1 : options.length,
              i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;
          while (i--) {
            option = options[i];
            if ((option.selected = jQuery.inArray(option.value, values) >= 0)) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }});
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {set: function(elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
        }
      }};
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });
  var nonce = jQuery.now();
  var rquery = (/\?/);
  jQuery.parseJSON = function(data) {
    return JSON.parse(data + "");
  };
  jQuery.parseXML = function(data) {
    var xml,
        tmp;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      tmp = new DOMParser();
      xml = tmp.parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rhash = /#.*$/,
      rts = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
      prefilters = {},
      transports = {},
      allTypes = "*/".concat("*"),
      ajaxLocation = window.location.href,
      ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = (structure === transports);
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }
  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s["throws"]) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: "GET",
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": jQuery.parseJSON,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
          cacheURL,
          responseHeadersString,
          responseHeaders,
          timeoutTimer,
          parts,
          fireGlobals,
          i,
          s = jQuery.ajaxSetup({}, options),
          callbackContext = s.context || s,
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          statusCode = s.statusCode || {},
          requestHeaders = {},
          requestHeadersNames = {},
          state = 0,
          strAbort = "canceled",
          jqXHR = {
            readyState: 0,
            getResponseHeader: function(key) {
              var match;
              if (state === 2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while ((match = rheaders.exec(responseHeadersString))) {
                    responseHeaders[match[1].toLowerCase()] = match[2];
                  }
                }
                match = responseHeaders[key.toLowerCase()];
              }
              return match == null ? null : match;
            },
            getAllResponseHeaders: function() {
              return state === 2 ? responseHeadersString : null;
            },
            setRequestHeader: function(name, value) {
              var lname = name.toLowerCase();
              if (!state) {
                name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            overrideMimeType: function(type) {
              if (!state) {
                s.mimeType = type;
              }
              return this;
            },
            statusCode: function(map) {
              var code;
              if (map) {
                if (state < 2) {
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                } else {
                  jqXHR.always(map[jqXHR.status]);
                }
              }
              return this;
            },
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      for (i in {
        success: 1,
        error: 1,
        complete: 1
      }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
            contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function() {
      return this.parent().each(function() {
        if (!jQuery.nodeName(this, "body")) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  jQuery.expr.filters.hidden = function(elem) {
    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
  };
  jQuery.expr.filters.visible = function(elem) {
    return !jQuery.expr.filters.hidden(elem);
  };
  var r20 = /%20/g,
      rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
        s = [],
        add = function(key, value) {
          value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&").replace(r20, "+");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function() {
        var type = this.type;
        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function(i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new XMLHttpRequest();
    } catch (e) {}
  };
  var xhrId = 0,
      xhrCallbacks = {},
      xhrSuccessStatus = {
        0: 200,
        1223: 204
      },
      xhrSupported = jQuery.ajaxSettings.xhr();
  if (window.attachEvent) {
    window.attachEvent("onunload", function() {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
    });
  }
  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
              xhr = options.xhr(),
              id = ++xhrId;
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  complete(xhr.status, xhr.statusText);
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {text: xhr.responseText} : undefined, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          xhr.onerror = callback("error");
          callback = xhrCallbacks[id] = callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxSetup({
    accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
    contents: {script: /(?:java|ecma)script/},
    converters: {"text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }}
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script,
          callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            async: true,
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function(evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        window[callbackName] = overwritten;
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (!data || typeof data !== "string") {
      return null;
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    context = context || document;
    var parsed = rsingleTag.exec(data),
        scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = jQuery.buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  var _load = jQuery.fn.load;
  jQuery.fn.load = function(url, params, callback) {
    if (typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    }
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");
    if (off >= 0) {
      selector = jQuery.trim(url.slice(off));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type,
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).complete(callback && function(jqXHR, status) {
        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.filters.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  var docElem = window.document.documentElement;
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.offset = {setOffset: function(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }};
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function(i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var docElem,
          win,
          elem = this[0],
          box = {
            top: 0,
            left: 0
          },
          doc = elem && elem.ownerDocument;
      if (!doc) {
        return;
      }
      docElem = doc.documentElement;
      if (!jQuery.contains(docElem, elem)) {
        return box;
      }
      if (typeof elem.getBoundingClientRect !== strundefined) {
        box = elem.getBoundingClientRect();
      }
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    },
    position: function() {
      if (!this[0]) {
        return;
      }
      var offsetParent,
          offset,
          elem = this[0],
          parentOffset = {
            top: 0,
            left: 0
          };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent || docElem;
        while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.size = function() {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof define === "function" && define.amd) {
    define("c2", [], function() {
      return jQuery;
    });
  }
  var _jQuery = window.jQuery,
      _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (typeof noGlobal === strundefined) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
}));

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("84", ["c2"], function(main) {
  return main;
});

_removeDefine();
})();
$__System.register('d', ['2', '3', '68', '84', '6b', 'c1'], function (_export) {
  'use strict';

  var Detector, THREE, Map, jQuery, UI, Renderer, scene, map, ui, renderer;
  return {
    setters: [function (_) {
      Detector = _['default'];
    }, function (_3) {
      THREE = _3['default'];
    }, function (_2) {
      Map = _2['default'];
    }, function (_4) {
      jQuery = _4['default'];
    }, function (_b) {
      UI = _b['default'];
    }, function (_c1) {
      Renderer = _c1['default'];
    }],
    execute: function () {
      window.THREE = THREE;

      scene = undefined;
      map = undefined;
      ui = undefined;
      renderer = undefined;

      jQuery(function () {

        if (!Detector.webgl) {
          Detector.addGetWebGLMessage();
        }

        _export('map', map = new Map());
        _export('renderer', renderer = new Renderer(map));
        _export('ui', ui = new UI(map));
        _export('scene', scene = map.scene);

        var animate = function animate() {
          requestAnimationFrame(animate);
          renderer.render();
        };

        animate();
      });

      _export('scene', scene);

      _export('map', map);

      _export('ui', ui);

      _export('renderer', renderer);
    }
  };
});
$__System.register('6c', ['3'], function (_export) {
  /**
  * @author Lianna Eeftinck / https://github.com/Leeft
  */

  'use strict';

  var THREE, generateUUID, degToRad, radToDeg;
  return {
    setters: [function (_) {
      THREE = _['default'];
    }],
    execute: function () {
      generateUUID = THREE.Math.generateUUID;
      degToRad = THREE.Math.degToRad;
      radToDeg = THREE.Math.radToDeg;

      _export('generateUUID', generateUUID);

      _export('degToRad', degToRad);

      _export('radToDeg', radToDeg);
    }
  };
});
$__System.register('6', ['1', '7', '8', '9', '83', '6a', '1d', 'b', 'd', '1e', '6c'], function (_export) {
  var SCMAP, settings, _createClass, _classCallCheck, MapSymbols, Faction, JumpPoint, config, map, Color, Vector3, generateUUID, UNSET, StarSystem;

  return {
    setters: [function (_3) {
      SCMAP = _3['default'];
    }, function (_5) {
      settings = _5['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_4) {
      MapSymbols = _4['default'];
    }, function (_a) {
      Faction = _a['default'];
    }, function (_d) {
      JumpPoint = _d['default'];
    }, function (_b) {
      config = _b['default'];
    }, function (_d2) {
      map = _d2.map;
    }, function (_e) {
      Color = _e.Color;
      Vector3 = _e.Vector3;
    }, function (_c) {
      generateUUID = _c.generateUUID;
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      'use strict';

      UNSET = new Color(0x80A0CC);

      StarSystem = (function () {
        function StarSystem(data) {
          _classCallCheck(this, StarSystem);

          this.id = undefined;
          this.uuid = undefined;
          this.name = generateUUID();
          this.description = '';
          this.nickname = '';
          this.position = new Vector3();
          this.faction = new Faction();
          this.size = 'medium';
          this.jumpPoints = [];
          this.poi = [];
          this.color = new Color(0xFFFFFF);
          this.planets = 0;
          this.planetaryRotation = [];
          this['import'] = [];
          this['export'] = [];
          this.status = 'Unknown';
          this.crimeStatus = '';
          this.blackMarket = [];
          this.ueeStrategicValue = undefined;
          this.info = [];
          this.binary = false;
          this.isOffLimits = false;
          this.hasWarning = false;
          this.isMajorTradeHub = false;

          this.setValues(data);
        }

        _createClass(StarSystem, [{
          key: 'getIcons',
          value: function getIcons() {
            var myIcons = [];

            //if ( true && ( this.name === 'Sol' || /^Unknown/.test( this.name ) ) ) {
            //  myIcons.push( MapSymbols.DANGER );
            //  myIcons.push( MapSymbols.WARNING );
            //  myIcons.push( MapSymbols.HANGAR );
            //  myIcons.push( MapSymbols.INFO );
            //  myIcons.push( MapSymbols.TRADE );
            //  myIcons.push( MapSymbols.BANNED );
            //  myIcons.push( MapSymbols.AVOID );
            //  myIcons.push( MapSymbols.COMMENTS );
            //  myIcons.push( MapSymbols.BOOKMARK );
            //  return myIcons;
            //}

            if (this.faction.isHostileTo(settings.usersFaction)) {
              myIcons.push(MapSymbols.DANGER);
            }
            if (this.hasWarning) {
              myIcons.push(MapSymbols.WARNING);
            }
            if (this.info.length) {
              myIcons.push(MapSymbols.INFO);
            }
            if (this.isMajorTradeHub) {
              myIcons.push(MapSymbols.TRADE);
            }
            if (this.isOffLimits) {
              myIcons.push(MapSymbols.BANNED);
            }
            if (this.hasHangar()) {
              myIcons.push(MapSymbols.HANGAR);
            }
            if (this.isBookmarked()) {
              myIcons.push(MapSymbols.BOOKMARK);
            }
            if (this.isToBeAvoided()) {
              myIcons.push(MapSymbols.AVOID);
            }
            if (this.hasComments()) {
              myIcons.push(MapSymbols.COMMENTS);
            }

            return myIcons;
          }
        }, {
          key: 'refreshIcons',
          value: function refreshIcons() {
            this.label.icons = settings.labelIcons ? this.getIcons() : [];
            this.label.redraw();
            this.refreshScale(this.labelScale);
          }
        }, {
          key: 'refreshScale',

          // TODO: Move this helper to label class
          value: function refreshScale(scale) {
            this.label.sprite.scale.set(scale * (this.label.node.width / this.label.node.height), scale, 1);
          }

          // Returns the jumppoint leading to the given destination
        }, {
          key: 'jumpPointTo',
          value: function jumpPointTo(destination) {
            for (var i = 0; i < this.jumpPoints.length; i++) {
              if (this.jumpPoints[i].destination === destination) {
                return this.jumpPoints[i];
              }
            }
          }
        }, {
          key: 'isBookmarked',
          value: function isBookmarked() {
            return this.storedSettings().bookmarked === true;
          }
        }, {
          key: 'isUnknown',
          value: function isUnknown() {
            return this.status === 'Unknown' ? true : false;
          }
        }, {
          key: 'setBookmarkedState',
          value: function setBookmarkedState(state) {
            this.storedSettings().bookmarked = state ? true : false;
            this.saveSettings();
            return this;
          }
        }, {
          key: 'hasHangar',
          value: function hasHangar() {
            return this.storedSettings().hangarLocation === true;
          }
        }, {
          key: 'setHangarState',
          value: function setHangarState(state) {
            this.storedSettings().hangarLocation = state ? true : false;
            this.saveSettings();
            return this;
          }
        }, {
          key: 'isToBeAvoided',
          value: function isToBeAvoided() {
            return this.storedSettings().avoid === true;
          }
        }, {
          key: 'setToBeAvoidedState',
          value: function setToBeAvoidedState(state) {
            this.storedSettings().avoid = state ? true : false;
            this.saveSettings();
            return this;
          }
        }, {
          key: 'hasComments',
          value: function hasComments() {
            return typeof this.storedSettings().comments === 'string' && this.storedSettings().comments.length > 0;
          }
        }, {
          key: 'getComments',
          value: function getComments() {
            return this.storedSettings().comments;
          }
        }, {
          key: 'setComments',
          value: function setComments(comments) {
            if (typeof comments === 'string' && comments.length > 1) {
              this.storedSettings().comments = comments;
            } else {
              delete this.storedSettings().comments;
            }
            this.saveSettings();
            return this;
          }
        }, {
          key: 'storedSettings',
          value: function storedSettings() {
            if (!(this.id in settings.systems)) {
              settings.systems[this.id] = {};
            }
            return settings.systems[this.id];
          }
        }, {
          key: 'saveSettings',
          value: function saveSettings() {
            settings.save('systems');
            return this;
          }
        }, {
          key: 'toString',
          value: function toString() {
            return this.name;
          }
        }, {
          key: 'getValue',
          value: function getValue(key) {
            if (key === undefined) {
              return;
            }
            var value = this[key];
            return value;
          }
        }, {
          key: 'factionStyle',
          value: function factionStyle() {
            return this.faction.color.getStyle();
          }
        }, {
          key: '_fixJumpPoints',
          value: function _fixJumpPoints(cleanup) {
            var i = undefined,
                jumpPoint = undefined,
                destination = undefined,
                jumpPoints = [];

            for (i = 0; i < this.jumpPoints.length; i++) {
              jumpPoint = this.jumpPoints[i];

              if (jumpPoint instanceof JumpPoint) {
                continue;
              }

              destination = StarSystem.getById(jumpPoint.destinationSystemId);
              if (destination === this) {
                destination = StarSystem.getById(jumpPoint.sourceSystemId);
              }

              if (destination instanceof StarSystem) {
                jumpPoint = new JumpPoint({
                  id: jumpPoint.jumpPointId,
                  direction: jumpPoint.direction,
                  source: this,
                  destination: destination,
                  name: jumpPoint.name,
                  size: jumpPoint.size,
                  status: jumpPoint.status,
                  type: jumpPoint.type,
                  entryAU: jumpPoint.coordsAu
                });

                if (cleanup) {
                  jumpPoints.push(jumpPoint);
                } else {
                  system.jumpPoints[i] = jumpPoint;
                }
              }
            }

            if (cleanup) {
              this.jumpPoints = jumpPoints;
            }

            return this;
          }
        }, {
          key: 'setValues',
          value: function setValues(values) {
            var key = undefined,
                currentValue = undefined,
                newValue = undefined,
                jumpPoint = undefined;

            if (values === undefined) {
              return;
            }

            for (key in values) {
              newValue = values[key];
              if (newValue === undefined) {
                console.log('StarSystem: "' + key + '" parameter is undefined for "' + this.name + '"');
                continue;
              }

              if (key in this) {
                currentValue = this[key];

                if (currentValue instanceof Color) {

                  if (newValue instanceof Color) {
                    this[key] = newValue;
                  } else {
                    newValue = newValue.replace('0x', '#').toLowerCase();
                    this['_' + key] = newValue;
                    if (/unknown/i.test(newValue)) {
                      this[key] = UNSET;
                    } else {
                      this[key] = new Color(newValue);
                    }
                  }
                } else if (currentValue instanceof Faction) {

                  this[key] = newValue.claim(this);
                } else if (currentValue instanceof Vector3 && newValue instanceof Vector3) {

                  currentValue.copy(newValue);
                } else if (currentValue instanceof Vector3) {

                  if (newValue instanceof Vector3) {
                    currentValue.copy(newValue);
                  } else if (newValue instanceof Array) {
                    currentValue.fromArray(newValue);
                  }
                } else {

                  this[key] = newValue;
                }
              }
            }
          }
        }, {
          key: 'scale',
          get: function get() {
            var scale = 1.0;
            switch (this.size) {
              case 'dwarf':
                scale = 0.90;break;
              case 'medium':
                scale = 1.0;break;
              case 'large':
                scale = 1.15;break;
              case 'giant':
                scale = 1.27;break;
              case 'binary':
                scale = 1.4;this.binary = true;break;
            }
            return scale;
          }
        }, {
          key: 'labelScale',
          get: function get() {
            return settings.labelScale * config.labelScale * (this.isUnknown() ? 0.5 : 1);
          }
        }], [{
          key: 'fromJSON',
          value: function fromJSON(json) {
            var system = undefined;

            if (json instanceof StarSystem) {
              return json;
            }

            return new StarSystem({
              'id': json.id,
              'uuid': json.uuid,
              'name': json.name,
              'description': json.description,
              'position': json.coordinates,
              'color': json.color === 'Unknown' ? UNSET : new Color(json.color.toLowerCase()),
              'faction': SCMAP.getFactionById(json.faction),
              'isMajorTradeHub': json.isMajorTradeHub,
              'hasWarning': json.hasWarning,
              'isOffLimits': json.isOffLimits,
              'nickname': json.nickname,
              'size': json.size,
              'info': json.info,
              'status': json.status,
              'crimeStatus': SCMAP.getCrimeLevelById(json.crimeLevel),
              'ueeStrategicValue': SCMAP.getUEEStrategicValueById('' + json.ueeStrategicValue),
              'import': json.importing,
              'export': json.exporting,
              'blackMarket': json.blackMarkets,
              'planets': [], // TODO
              'planetaryRotation': [], // TODO
              'jumpPoints': json.jumpPoints
            });
          }
        }, {
          key: 'getById',
          value: function getById(id) {
            return SCMAP.getStarSystemById(id);
          }
        }]);

        return StarSystem;
      })();

      _export('default', StarSystem);
    }
  };
});
$__System.registerDynamic("c3", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var THREE = {REVISION: '73'};
  if (typeof define === 'function' && define.amd) {
    define('three', THREE);
  } else if ('undefined' !== typeof exports && 'undefined' !== typeof module) {
    module.exports = THREE;
  }
  if (self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined) {
    (function() {
      var lastTime = 0;
      var vendors = ['ms', 'moz', 'webkit', 'o'];
      for (var x = 0; x < vendors.length && !self.requestAnimationFrame; ++x) {
        self.requestAnimationFrame = self[vendors[x] + 'RequestAnimationFrame'];
        self.cancelAnimationFrame = self[vendors[x] + 'CancelAnimationFrame'] || self[vendors[x] + 'CancelRequestAnimationFrame'];
      }
      if (self.requestAnimationFrame === undefined && self.setTimeout !== undefined) {
        self.requestAnimationFrame = function(callback) {
          var currTime = Date.now(),
              timeToCall = Math.max(0, 16 - (currTime - lastTime));
          var id = self.setTimeout(function() {
            callback(currTime + timeToCall);
          }, timeToCall);
          lastTime = currTime + timeToCall;
          return id;
        };
      }
      if (self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined) {
        self.cancelAnimationFrame = function(id) {
          self.clearTimeout(id);
        };
      }
    })();
  }
  if (self.performance === undefined) {
    self.performance = {};
  }
  if (self.performance.now === undefined) {
    (function() {
      var start = Date.now();
      self.performance.now = function() {
        return Date.now() - start;
      };
    })();
  }
  if (Number.EPSILON === undefined) {
    Number.EPSILON = Math.pow(2, -52);
  }
  if (Math.sign === undefined) {
    Math.sign = function(x) {
      return (x < 0) ? -1 : (x > 0) ? 1 : +x;
    };
  }
  if (Function.prototype.name === undefined && Object.defineProperty !== undefined) {
    Object.defineProperty(Function.prototype, 'name', {get: function() {
        return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
      }});
  }
  THREE.MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
  };
  THREE.CullFaceNone = 0;
  THREE.CullFaceBack = 1;
  THREE.CullFaceFront = 2;
  THREE.CullFaceFrontBack = 3;
  THREE.FrontFaceDirectionCW = 0;
  THREE.FrontFaceDirectionCCW = 1;
  THREE.BasicShadowMap = 0;
  THREE.PCFShadowMap = 1;
  THREE.PCFSoftShadowMap = 2;
  THREE.FrontSide = 0;
  THREE.BackSide = 1;
  THREE.DoubleSide = 2;
  THREE.FlatShading = 1;
  THREE.SmoothShading = 2;
  THREE.NoColors = 0;
  THREE.FaceColors = 1;
  THREE.VertexColors = 2;
  THREE.NoBlending = 0;
  THREE.NormalBlending = 1;
  THREE.AdditiveBlending = 2;
  THREE.SubtractiveBlending = 3;
  THREE.MultiplyBlending = 4;
  THREE.CustomBlending = 5;
  THREE.AddEquation = 100;
  THREE.SubtractEquation = 101;
  THREE.ReverseSubtractEquation = 102;
  THREE.MinEquation = 103;
  THREE.MaxEquation = 104;
  THREE.ZeroFactor = 200;
  THREE.OneFactor = 201;
  THREE.SrcColorFactor = 202;
  THREE.OneMinusSrcColorFactor = 203;
  THREE.SrcAlphaFactor = 204;
  THREE.OneMinusSrcAlphaFactor = 205;
  THREE.DstAlphaFactor = 206;
  THREE.OneMinusDstAlphaFactor = 207;
  THREE.DstColorFactor = 208;
  THREE.OneMinusDstColorFactor = 209;
  THREE.SrcAlphaSaturateFactor = 210;
  THREE.NeverDepth = 0;
  THREE.AlwaysDepth = 1;
  THREE.LessDepth = 2;
  THREE.LessEqualDepth = 3;
  THREE.EqualDepth = 4;
  THREE.GreaterEqualDepth = 5;
  THREE.GreaterDepth = 6;
  THREE.NotEqualDepth = 7;
  THREE.MultiplyOperation = 0;
  THREE.MixOperation = 1;
  THREE.AddOperation = 2;
  THREE.UVMapping = 300;
  THREE.CubeReflectionMapping = 301;
  THREE.CubeRefractionMapping = 302;
  THREE.EquirectangularReflectionMapping = 303;
  THREE.EquirectangularRefractionMapping = 304;
  THREE.SphericalReflectionMapping = 305;
  THREE.RepeatWrapping = 1000;
  THREE.ClampToEdgeWrapping = 1001;
  THREE.MirroredRepeatWrapping = 1002;
  THREE.NearestFilter = 1003;
  THREE.NearestMipMapNearestFilter = 1004;
  THREE.NearestMipMapLinearFilter = 1005;
  THREE.LinearFilter = 1006;
  THREE.LinearMipMapNearestFilter = 1007;
  THREE.LinearMipMapLinearFilter = 1008;
  THREE.UnsignedByteType = 1009;
  THREE.ByteType = 1010;
  THREE.ShortType = 1011;
  THREE.UnsignedShortType = 1012;
  THREE.IntType = 1013;
  THREE.UnsignedIntType = 1014;
  THREE.FloatType = 1015;
  THREE.HalfFloatType = 1025;
  THREE.UnsignedShort4444Type = 1016;
  THREE.UnsignedShort5551Type = 1017;
  THREE.UnsignedShort565Type = 1018;
  THREE.AlphaFormat = 1019;
  THREE.RGBFormat = 1020;
  THREE.RGBAFormat = 1021;
  THREE.LuminanceFormat = 1022;
  THREE.LuminanceAlphaFormat = 1023;
  THREE.RGBEFormat = THREE.RGBAFormat;
  THREE.RGB_S3TC_DXT1_Format = 2001;
  THREE.RGBA_S3TC_DXT1_Format = 2002;
  THREE.RGBA_S3TC_DXT3_Format = 2003;
  THREE.RGBA_S3TC_DXT5_Format = 2004;
  THREE.RGB_PVRTC_4BPPV1_Format = 2100;
  THREE.RGB_PVRTC_2BPPV1_Format = 2101;
  THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
  THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
  THREE.LoopOnce = 2200;
  THREE.LoopRepeat = 2201;
  THREE.LoopPingPong = 2202;
  THREE.Projector = function() {
    console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');
    this.projectVector = function(vector, camera) {
      console.warn('THREE.Projector: .projectVector() is now vector.project().');
      vector.project(camera);
    };
    this.unprojectVector = function(vector, camera) {
      console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
      vector.unproject(camera);
    };
    this.pickingRay = function(vector, camera) {
      console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
    };
  };
  THREE.CanvasRenderer = function() {
    console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');
    this.domElement = document.createElement('canvas');
    this.clear = function() {};
    this.render = function() {};
    this.setClearColor = function() {};
    this.setSize = function() {};
  };
  THREE.Color = function(color) {
    if (arguments.length === 3) {
      return this.fromArray(arguments);
    }
    return this.set(color);
  };
  THREE.Color.prototype = {
    constructor: THREE.Color,
    r: 1,
    g: 1,
    b: 1,
    set: function(value) {
      if (value instanceof THREE.Color) {
        this.copy(value);
      } else if (typeof value === 'number') {
        this.setHex(value);
      } else if (typeof value === 'string') {
        this.setStyle(value);
      }
      return this;
    },
    setHex: function(hex) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      return this;
    },
    setRGB: function(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
      return this;
    },
    setHSL: function() {
      function hue2rgb(p, q, t) {
        if (t < 0)
          t += 1;
        if (t > 1)
          t -= 1;
        if (t < 1 / 6)
          return p + (q - p) * 6 * t;
        if (t < 1 / 2)
          return q;
        if (t < 2 / 3)
          return p + (q - p) * 6 * (2 / 3 - t);
        return p;
      }
      return function(h, s, l) {
        h = THREE.Math.euclideanModulo(h, 1);
        s = THREE.Math.clamp(s, 0, 1);
        l = THREE.Math.clamp(l, 0, 1);
        if (s === 0) {
          this.r = this.g = this.b = l;
        } else {
          var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
          var q = (2 * l) - p;
          this.r = hue2rgb(q, p, h + 1 / 3);
          this.g = hue2rgb(q, p, h);
          this.b = hue2rgb(q, p, h - 1 / 3);
        }
        return this;
      };
    }(),
    setStyle: function(style) {
      function handleAlpha(string) {
        if (string === undefined)
          return;
        if (parseFloat(string) < 1) {
          console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
        }
      }
      var m;
      if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
        var color;
        var name = m[1];
        var components = m[2];
        switch (name) {
          case 'rgb':
          case 'rgba':
            if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
              this.r = Math.min(255, parseInt(color[1], 10)) / 255;
              this.g = Math.min(255, parseInt(color[2], 10)) / 255;
              this.b = Math.min(255, parseInt(color[3], 10)) / 255;
              handleAlpha(color[5]);
              return this;
            }
            if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
              this.r = Math.min(100, parseInt(color[1], 10)) / 100;
              this.g = Math.min(100, parseInt(color[2], 10)) / 100;
              this.b = Math.min(100, parseInt(color[3], 10)) / 100;
              handleAlpha(color[5]);
              return this;
            }
            break;
          case 'hsl':
          case 'hsla':
            if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
              var h = parseFloat(color[1]) / 360;
              var s = parseInt(color[2], 10) / 100;
              var l = parseInt(color[3], 10) / 100;
              handleAlpha(color[5]);
              return this.setHSL(h, s, l);
            }
            break;
        }
      } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
        var hex = m[1];
        var size = hex.length;
        if (size === 3) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
          this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
          this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
          return this;
        } else if (size === 6) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
          this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
          this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
          return this;
        }
      }
      if (style && style.length > 0) {
        var hex = THREE.ColorKeywords[style];
        if (hex !== undefined) {
          this.setHex(hex);
        } else {
          console.warn('THREE.Color: Unknown color ' + style);
        }
      }
      return this;
    },
    clone: function() {
      return new this.constructor(this.r, this.g, this.b);
    },
    copy: function(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    },
    copyGammaToLinear: function(color, gammaFactor) {
      if (gammaFactor === undefined)
        gammaFactor = 2.0;
      this.r = Math.pow(color.r, gammaFactor);
      this.g = Math.pow(color.g, gammaFactor);
      this.b = Math.pow(color.b, gammaFactor);
      return this;
    },
    copyLinearToGamma: function(color, gammaFactor) {
      if (gammaFactor === undefined)
        gammaFactor = 2.0;
      var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;
      this.r = Math.pow(color.r, safeInverse);
      this.g = Math.pow(color.g, safeInverse);
      this.b = Math.pow(color.b, safeInverse);
      return this;
    },
    convertGammaToLinear: function() {
      var r = this.r,
          g = this.g,
          b = this.b;
      this.r = r * r;
      this.g = g * g;
      this.b = b * b;
      return this;
    },
    convertLinearToGamma: function() {
      this.r = Math.sqrt(this.r);
      this.g = Math.sqrt(this.g);
      this.b = Math.sqrt(this.b);
      return this;
    },
    getHex: function() {
      return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
    },
    getHexString: function() {
      return ('000000' + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(optionalTarget) {
      var hsl = optionalTarget || {
        h: 0,
        s: 0,
        l: 0
      };
      var r = this.r,
          g = this.g,
          b = this.b;
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var hue,
          saturation;
      var lightness = (min + max) / 2.0;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        var delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
            break;
        }
        hue /= 6;
      }
      hsl.h = hue;
      hsl.s = saturation;
      hsl.l = lightness;
      return hsl;
    },
    getStyle: function() {
      return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';
    },
    offsetHSL: function(h, s, l) {
      var hsl = this.getHSL();
      hsl.h += h;
      hsl.s += s;
      hsl.l += l;
      this.setHSL(hsl.h, hsl.s, hsl.l);
      return this;
    },
    add: function(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    },
    addColors: function(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    },
    addScalar: function(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    },
    multiply: function(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    },
    multiplyScalar: function(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    },
    lerp: function(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    },
    equals: function(c) {
      return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
    },
    fromArray: function(array, offset) {
      if (offset === undefined)
        offset = 0;
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    },
    toArray: function(array, offset) {
      if (array === undefined)
        array = [];
      if (offset === undefined)
        offset = 0;
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
  };
  THREE.ColorKeywords = {
    'aliceblue': 0xF0F8FF,
    'antiquewhite': 0xFAEBD7,
    'aqua': 0x00FFFF,
    'aquamarine': 0x7FFFD4,
    'azure': 0xF0FFFF,
    'beige': 0xF5F5DC,
    'bisque': 0xFFE4C4,
    'black': 0x000000,
    'blanchedalmond': 0xFFEBCD,
    'blue': 0x0000FF,
    'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A,
    'burlywood': 0xDEB887,
    'cadetblue': 0x5F9EA0,
    'chartreuse': 0x7FFF00,
    'chocolate': 0xD2691E,
    'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED,
    'cornsilk': 0xFFF8DC,
    'crimson': 0xDC143C,
    'cyan': 0x00FFFF,
    'darkblue': 0x00008B,
    'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B,
    'darkgray': 0xA9A9A9,
    'darkgreen': 0x006400,
    'darkgrey': 0xA9A9A9,
    'darkkhaki': 0xBDB76B,
    'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F,
    'darkorange': 0xFF8C00,
    'darkorchid': 0x9932CC,
    'darkred': 0x8B0000,
    'darksalmon': 0xE9967A,
    'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B,
    'darkslategray': 0x2F4F4F,
    'darkslategrey': 0x2F4F4F,
    'darkturquoise': 0x00CED1,
    'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493,
    'deepskyblue': 0x00BFFF,
    'dimgray': 0x696969,
    'dimgrey': 0x696969,
    'dodgerblue': 0x1E90FF,
    'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0,
    'forestgreen': 0x228B22,
    'fuchsia': 0xFF00FF,
    'gainsboro': 0xDCDCDC,
    'ghostwhite': 0xF8F8FF,
    'gold': 0xFFD700,
    'goldenrod': 0xDAA520,
    'gray': 0x808080,
    'green': 0x008000,
    'greenyellow': 0xADFF2F,
    'grey': 0x808080,
    'honeydew': 0xF0FFF0,
    'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C,
    'indigo': 0x4B0082,
    'ivory': 0xFFFFF0,
    'khaki': 0xF0E68C,
    'lavender': 0xE6E6FA,
    'lavenderblush': 0xFFF0F5,
    'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD,
    'lightblue': 0xADD8E6,
    'lightcoral': 0xF08080,
    'lightcyan': 0xE0FFFF,
    'lightgoldenrodyellow': 0xFAFAD2,
    'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90,
    'lightgrey': 0xD3D3D3,
    'lightpink': 0xFFB6C1,
    'lightsalmon': 0xFFA07A,
    'lightseagreen': 0x20B2AA,
    'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899,
    'lightslategrey': 0x778899,
    'lightsteelblue': 0xB0C4DE,
    'lightyellow': 0xFFFFE0,
    'lime': 0x00FF00,
    'limegreen': 0x32CD32,
    'linen': 0xFAF0E6,
    'magenta': 0xFF00FF,
    'maroon': 0x800000,
    'mediumaquamarine': 0x66CDAA,
    'mediumblue': 0x0000CD,
    'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB,
    'mediumseagreen': 0x3CB371,
    'mediumslateblue': 0x7B68EE,
    'mediumspringgreen': 0x00FA9A,
    'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585,
    'midnightblue': 0x191970,
    'mintcream': 0xF5FFFA,
    'mistyrose': 0xFFE4E1,
    'moccasin': 0xFFE4B5,
    'navajowhite': 0xFFDEAD,
    'navy': 0x000080,
    'oldlace': 0xFDF5E6,
    'olive': 0x808000,
    'olivedrab': 0x6B8E23,
    'orange': 0xFFA500,
    'orangered': 0xFF4500,
    'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA,
    'palegreen': 0x98FB98,
    'paleturquoise': 0xAFEEEE,
    'palevioletred': 0xDB7093,
    'papayawhip': 0xFFEFD5,
    'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F,
    'pink': 0xFFC0CB,
    'plum': 0xDDA0DD,
    'powderblue': 0xB0E0E6,
    'purple': 0x800080,
    'red': 0xFF0000,
    'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1,
    'saddlebrown': 0x8B4513,
    'salmon': 0xFA8072,
    'sandybrown': 0xF4A460,
    'seagreen': 0x2E8B57,
    'seashell': 0xFFF5EE,
    'sienna': 0xA0522D,
    'silver': 0xC0C0C0,
    'skyblue': 0x87CEEB,
    'slateblue': 0x6A5ACD,
    'slategray': 0x708090,
    'slategrey': 0x708090,
    'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F,
    'steelblue': 0x4682B4,
    'tan': 0xD2B48C,
    'teal': 0x008080,
    'thistle': 0xD8BFD8,
    'tomato': 0xFF6347,
    'turquoise': 0x40E0D0,
    'violet': 0xEE82EE,
    'wheat': 0xF5DEB3,
    'white': 0xFFFFFF,
    'whitesmoke': 0xF5F5F5,
    'yellow': 0xFFFF00,
    'yellowgreen': 0x9ACD32
  };
  THREE.Quaternion = function(x, y, z, w) {
    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._w = (w !== undefined) ? w : 1;
  };
  THREE.Quaternion.prototype = {
    constructor: THREE.Quaternion,
    get x() {
      return this._x;
    },
    set x(value) {
      this._x = value;
      this.onChangeCallback();
    },
    get y() {
      return this._y;
    },
    set y(value) {
      this._y = value;
      this.onChangeCallback();
    },
    get z() {
      return this._z;
    },
    set z(value) {
      this._z = value;
      this.onChangeCallback();
    },
    get w() {
      return this._w;
    },
    set w(value) {
      this._w = value;
      this.onChangeCallback();
    },
    set: function(x, y, z, w) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
      this.onChangeCallback();
      return this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    },
    copy: function(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this.onChangeCallback();
      return this;
    },
    setFromEuler: function(euler, update) {
      if (euler instanceof THREE.Euler === false) {
        throw new Error('THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
      }
      var c1 = Math.cos(euler._x / 2);
      var c2 = Math.cos(euler._y / 2);
      var c3 = Math.cos(euler._z / 2);
      var s1 = Math.sin(euler._x / 2);
      var s2 = Math.sin(euler._y / 2);
      var s3 = Math.sin(euler._z / 2);
      var order = euler.order;
      if (order === 'XYZ') {
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
      } else if (order === 'YXZ') {
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
      } else if (order === 'ZXY') {
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
      } else if (order === 'ZYX') {
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
      } else if (order === 'YZX') {
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
      } else if (order === 'XZY') {
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
      }
      if (update !== false)
        this.onChangeCallback();
      return this;
    },
    setFromAxisAngle: function(axis, angle) {
      var halfAngle = angle / 2,
          s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);
      this.onChangeCallback();
      return this;
    },
    setFromRotationMatrix: function(m) {
      var te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10],
          trace = m11 + m22 + m33,
          s;
      if (trace > 0) {
        s = 0.5 / Math.sqrt(trace + 1.0);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
        this._w = (m32 - m23) / s;
        this._x = 0.25 * s;
        this._y = (m12 + m21) / s;
        this._z = (m13 + m31) / s;
      } else if (m22 > m33) {
        s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
        this._w = (m13 - m31) / s;
        this._x = (m12 + m21) / s;
        this._y = 0.25 * s;
        this._z = (m23 + m32) / s;
      } else {
        s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
        this._w = (m21 - m12) / s;
        this._x = (m13 + m31) / s;
        this._y = (m23 + m32) / s;
        this._z = 0.25 * s;
      }
      this.onChangeCallback();
      return this;
    },
    setFromUnitVectors: function() {
      var v1,
          r;
      var EPS = 0.000001;
      return function(vFrom, vTo) {
        if (v1 === undefined)
          v1 = new THREE.Vector3();
        r = vFrom.dot(vTo) + 1;
        if (r < EPS) {
          r = 0;
          if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
            v1.set(-vFrom.y, vFrom.x, 0);
          } else {
            v1.set(0, -vFrom.z, vFrom.y);
          }
        } else {
          v1.crossVectors(vFrom, vTo);
        }
        this._x = v1.x;
        this._y = v1.y;
        this._z = v1.z;
        this._w = r;
        this.normalize();
        return this;
      };
    }(),
    inverse: function() {
      this.conjugate().normalize();
      return this;
    },
    conjugate: function() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this.onChangeCallback();
      return this;
    },
    dot: function(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    },
    lengthSq: function() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    },
    normalize: function() {
      var l = this.length();
      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }
      this.onChangeCallback();
      return this;
    },
    multiply: function(q, p) {
      if (p !== undefined) {
        console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
        return this.multiplyQuaternions(q, p);
      }
      return this.multiplyQuaternions(this, q);
    },
    multiplyQuaternions: function(a, b) {
      var qax = a._x,
          qay = a._y,
          qaz = a._z,
          qaw = a._w;
      var qbx = b._x,
          qby = b._y,
          qbz = b._z,
          qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this.onChangeCallback();
      return this;
    },
    multiplyVector3: function(vector) {
      console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
      return vector.applyQuaternion(this);
    },
    slerp: function(qb, t) {
      if (t === 0)
        return this;
      if (t === 1)
        return this.copy(qb);
      var x = this._x,
          y = this._y,
          z = this._z,
          w = this._w;
      var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1.0) {
        this._w = w;
        this._x = x;
        this._y = y;
        this._z = z;
        return this;
      }
      var halfTheta = Math.acos(cosHalfTheta);
      var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
      if (Math.abs(sinHalfTheta) < 0.001) {
        this._w = 0.5 * (w + this._w);
        this._x = 0.5 * (x + this._x);
        this._y = 0.5 * (y + this._y);
        this._z = 0.5 * (z + this._z);
        return this;
      }
      var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = (w * ratioA + this._w * ratioB);
      this._x = (x * ratioA + this._x * ratioB);
      this._y = (y * ratioA + this._y * ratioB);
      this._z = (z * ratioA + this._z * ratioB);
      this.onChangeCallback();
      return this;
    },
    equals: function(quaternion) {
      return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
    },
    fromArray: function(array, offset) {
      if (offset === undefined)
        offset = 0;
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this.onChangeCallback();
      return this;
    },
    toArray: function(array, offset) {
      if (array === undefined)
        array = [];
      if (offset === undefined)
        offset = 0;
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    },
    onChange: function(callback) {
      this.onChangeCallback = callback;
      return this;
    },
    onChangeCallback: function() {}
  };
  THREE.Quaternion.slerp = function(qa, qb, qm, t) {
    return qm.copy(qa).slerp(qb, t);
  };
  THREE.Vector2 = function(x, y) {
    this.x = x || 0;
    this.y = y || 0;
  };
  THREE.Vector2.prototype = {
    constructor: THREE.Vector2,
    get width() {
      return this.x;
    },
    set width(value) {
      this.x = value;
    },
    get height() {
      return this.y;
    },
    set height(value) {
      this.y = value;
    },
    set: function(x, y) {
      this.x = x;
      this.y = y;
      return this;
    },
    setX: function(x) {
      this.x = x;
      return this;
    },
    setY: function(y) {
      this.y = y;
      return this;
    },
    setComponent: function(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        default:
          throw new Error('index is out of range: ' + index);
      }
    },
    getComponent: function(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error('index is out of range: ' + index);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y);
    },
    copy: function(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    },
    add: function(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      return this;
    },
    addScalar: function(s) {
      this.x += s;
      this.y += s;
      return this;
    },
    addVectors: function(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    },
    addScaledVector: function(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      return this;
    },
    sub: function(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      return this;
    },
    subScalar: function(s) {
      this.x -= s;
      this.y -= s;
      return this;
    },
    subVectors: function(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    },
    multiply: function(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    },
    multiplyScalar: function(scalar) {
      if (isFinite(scalar)) {
        this.x *= scalar;
        this.y *= scalar;
      } else {
        this.x = 0;
        this.y = 0;
      }
      return this;
    },
    divide: function(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    },
    divideScalar: function(scalar) {
      return this.multiplyScalar(1 / scalar);
    },
    min: function(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      return this;
    },
    max: function(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      return this;
    },
    clamp: function(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    },
    clampScalar: function() {
      var min,
          max;
      return function clampScalar(minVal, maxVal) {
        if (min === undefined) {
          min = new THREE.Vector2();
          max = new THREE.Vector2();
        }
        min.set(minVal, minVal);
        max.set(maxVal, maxVal);
        return this.clamp(min, max);
      };
    }(),
    clampLength: function(min, max) {
      var length = this.length();
      this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
      return this;
    },
    floor: function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    },
    ceil: function() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    },
    round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    },
    roundToZero: function() {
      this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    },
    dot: function(v) {
      return this.x * v.x + this.y * v.y;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    lengthManhattan: function() {
      return Math.abs(this.x) + Math.abs(this.y);
    },
    normalize: function() {
      return this.divideScalar(this.length());
    },
    distanceTo: function(v) {
      return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function(v) {
      var dx = this.x - v.x,
          dy = this.y - v.y;
      return dx * dx + dy * dy;
    },
    setLength: function(length) {
      return this.multiplyScalar(length / this.length());
    },
    lerp: function(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      return this;
    },
    lerpVectors: function(v1, v2, alpha) {
      this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
      return this;
    },
    equals: function(v) {
      return ((v.x === this.x) && (v.y === this.y));
    },
    fromArray: function(array, offset) {
      if (offset === undefined)
        offset = 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    },
    toArray: function(array, offset) {
      if (array === undefined)
        array = [];
      if (offset === undefined)
        offset = 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    },
    fromAttribute: function(attribute, index, offset) {
      if (offset === undefined)
        offset = 0;
      index = index * attribute.itemSize + offset;
      this.x = attribute.array[index];
      this.y = attribute.array[index + 1];
      return this;
    },
    rotateAround: function(center, angle) {
      var c = Math.cos(angle),
          s = Math.sin(angle);
      var x = this.x - center.x;
      var y = this.y - center.y;
      this.x = x * c - y * s + center.x;
      this.y = x * s + y * c + center.y;
      return this;
    }
  };
  THREE.Vector3 = function(x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
  };
  THREE.Vector3.prototype = {
    constructor: THREE.Vector3,
    set: function(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    },
    setX: function(x) {
      this.x = x;
      return this;
    },
    setY: function(y) {
      this.y = y;
      return this;
    },
    setZ: function(z) {
      this.z = z;
      return this;
    },
    setComponent: function(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error('index is out of range: ' + index);
      }
    },
    getComponent: function(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error('index is out of range: ' + index);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z);
    },
    copy: function(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    },
    add: function(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    },
    addScalar: function(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    },
    addVectors: function(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    },
    addScaledVector: function(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    },
    sub: function(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    },
    subScalar: function(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    },
    subVectors: function(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    },
    multiply: function(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
        return this.multiplyVectors(v, w);
      }
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    },
    multiplyScalar: function(scalar) {
      if (isFinite(scalar)) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
      } else {
        this.x = 0;
        this.y = 0;
        this.z = 0;
      }
      return this;
    },
    multiplyVectors: function(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    },
    applyEuler: function() {
      var quaternion;
      return function applyEuler(euler) {
        if (euler instanceof THREE.Euler === false) {
          console.error('THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        if (quaternion === undefined)
          quaternion = new THREE.Quaternion();
        this.applyQuaternion(quaternion.setFromEuler(euler));
        return this;
      };
    }(),
    applyAxisAngle: function() {
      var quaternion;
      return function applyAxisAngle(axis, angle) {
        if (quaternion === undefined)
          quaternion = new THREE.Quaternion();
        this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
        return this;
      };
    }(),
    applyMatrix3: function(m) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6] * z;
      this.y = e[1] * x + e[4] * y + e[7] * z;
      this.z = e[2] * x + e[5] * y + e[8] * z;
      return this;
    },
    applyMatrix4: function(m) {
      var x = this.x,
          y = this.y,
          z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
      return this;
    },
    applyProjection: function(m) {
      var x = this.x,
          y = this.y,
          z = this.z;
      var e = m.elements;
      var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
      return this;
    },
    applyQuaternion: function(q) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var qx = q.x;
      var qy = q.y;
      var qz = q.z;
      var qw = q.w;
      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z;
      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    },
    project: function() {
      var matrix;
      return function project(camera) {
        if (matrix === undefined)
          matrix = new THREE.Matrix4();
        matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
        return this.applyProjection(matrix);
      };
    }(),
    unproject: function() {
      var matrix;
      return function unproject(camera) {
        if (matrix === undefined)
          matrix = new THREE.Matrix4();
        matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
        return this.applyProjection(matrix);
      };
    }(),
    transformDirection: function(m) {
      var x = this.x,
          y = this.y,
          z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      this.normalize();
      return this;
    },
    divide: function(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    },
    divideScalar: function(scalar) {
      return this.multiplyScalar(1 / scalar);
    },
    min: function(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    },
    max: function(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    },
    clamp: function(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      return this;
    },
    clampScalar: function() {
      var min,
          max;
      return function clampScalar(minVal, maxVal) {
        if (min === undefined) {
          min = new THREE.Vector3();
          max = new THREE.Vector3();
        }
        min.set(minVal, minVal, minVal);
        max.set(maxVal, maxVal, maxVal);
        return this.clamp(min, max);
      };
    }(),
    clampLength: function(min, max) {
      var length = this.length();
      this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
      return this;
    },
    floor: function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    },
    ceil: function() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    },
    round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    },
    roundToZero: function() {
      this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    },
    dot: function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    lengthManhattan: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
      return this.divideScalar(this.length());
    },
    setLength: function(length) {
      return this.multiplyScalar(length / this.length());
    },
    lerp: function(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    },
    lerpVectors: function(v1, v2, alpha) {
      this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
      return this;
    },
    cross: function(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
        return this.crossVectors(v, w);
      }
      var x = this.x,
          y = this.y,
          z = this.z;
      this.x = y * v.z - z * v.y;
      this.y = z * v.x - x * v.z;
      this.z = x * v.y - y * v.x;
      return this;
    },
    crossVectors: function(a, b) {
      var ax = a.x,
          ay = a.y,
          az = a.z;
      var bx = b.x,
          by = b.y,
          bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    },
    projectOnVector: function() {
      var v1,
          dot;
      return function projectOnVector(vector) {
        if (v1 === undefined)
          v1 = new THREE.Vector3();
        v1.copy(vector).normalize();
        dot = this.dot(v1);
        return this.copy(v1).multiplyScalar(dot);
      };
    }(),
    projectOnPlane: function() {
      var v1;
      return function projectOnPlane(planeNormal) {
        if (v1 === undefined)
          v1 = new THREE.Vector3();
        v1.copy(this).projectOnVector(planeNormal);
        return this.sub(v1);
      };
    }(),
    reflect: function() {
      var v1;
      return function reflect(normal) {
        if (v1 === undefined)
          v1 = new THREE.Vector3();
        return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
      };
    }(),
    angleTo: function(v) {
      var theta = this.dot(v) / (this.length() * v.length());
      return Math.acos(THREE.Math.clamp(theta, -1, 1));
    },
    distanceTo: function(v) {
      return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function(v) {
      var dx = this.x - v.x;
      var dy = this.y - v.y;
      var dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    },
    setEulerFromRotationMatrix: function(m, order) {
      console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
    },
    setEulerFromQuaternion: function(q, order) {
      console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
    },
    getPositionFromMatrix: function(m) {
      console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
      return this.setFromMatrixPosition(m);
    },
    getScaleFromMatrix: function(m) {
      console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
      return this.setFromMatrixScale(m);
    },
    getColumnFromMatrix: function(index, matrix) {
      console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
      return this.setFromMatrixColumn(index, matrix);
    },
    setFromMatrixPosition: function(m) {
      this.x = m.elements[12];
      this.y = m.elements[13];
      this.z = m.elements[14];
      return this;
    },
    setFromMatrixScale: function(m) {
      var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();
      var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();
      var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    },
    setFromMatrixColumn: function(index, matrix) {
      var offset = index * 4;
      var me = matrix.elements;
      this.x = me[offset];
      this.y = me[offset + 1];
      this.z = me[offset + 2];
      return this;
    },
    equals: function(v) {
      return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
    },
    fromArray: function(array, offset) {
      if (offset === undefined)
        offset = 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    },
    toArray: function(array, offset) {
      if (array === undefined)
        array = [];
      if (offset === undefined)
        offset = 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    },
    fromAttribute: function(attribute, index, offset) {
      if (offset === undefined)
        offset = 0;
      index = index * attribute.itemSize + offset;
      this.x = attribute.array[index];
      this.y = attribute.array[index + 1];
      this.z = attribute.array[index + 2];
      return this;
    }
  };
  THREE.Vector4 = function(x, y, z, w) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = (w !== undefined) ? w : 1;
  };
  THREE.Vector4.prototype = {
    constructor: THREE.Vector4,
    set: function(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    },
    setX: function(x) {
      this.x = x;
      return this;
    },
    setY: function(y) {
      this.y = y;
      return this;
    },
    setZ: function(z) {
      this.z = z;
      return this;
    },
    setW: function(w) {
      this.w = w;
      return this;
    },
    setComponent: function(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        case 3:
          this.w = value;
          break;
        default:
          throw new Error('index is out of range: ' + index);
      }
    },
    getComponent: function(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error('index is out of range: ' + index);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    },
    copy: function(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = (v.w !== undefined) ? v.w : 1;
      return this;
    },
    add: function(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    },
    addScalar: function(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      this.w += s;
      return this;
    },
    addVectors: function(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;
      return this;
    },
    addScaledVector: function(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      this.w += v.w * s;
      return this;
    },
    sub: function(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    },
    subScalar: function(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      this.w -= s;
      return this;
    },
    subVectors: function(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;
      return this;
    },
    multiplyScalar: function(scalar) {
      if (isFinite(scalar)) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
      } else {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
      }
      return this;
    },
    applyMatrix4: function(m) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var w = this.w;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
      return this;
    },
    divideScalar: function(scalar) {
      return this.multiplyScalar(1 / scalar);
    },
    setAxisAngleFromQuaternion: function(q) {
      this.w = 2 * Math.acos(q.w);
      var s = Math.sqrt(1 - q.w * q.w);
      if (s < 0.0001) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q.x / s;
        this.y = q.y / s;
        this.z = q.z / s;
      }
      return this;
    },
    setAxisAngleFromRotationMatrix: function(m) {
      var angle,
          x,
          y,
          z,
          epsilon = 0.01,
          epsilon2 = 0.1,
          te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10];
      if ((Math.abs(m12 - m21) < epsilon) && (Math.abs(m13 - m31) < epsilon) && (Math.abs(m23 - m32) < epsilon)) {
        if ((Math.abs(m12 + m21) < epsilon2) && (Math.abs(m13 + m31) < epsilon2) && (Math.abs(m23 + m32) < epsilon2) && (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
          this.set(1, 0, 0, 0);
          return this;
        }
        angle = Math.PI;
        var xx = (m11 + 1) / 2;
        var yy = (m22 + 1) / 2;
        var zz = (m33 + 1) / 2;
        var xy = (m12 + m21) / 4;
        var xz = (m13 + m31) / 4;
        var yz = (m23 + m32) / 4;
        if ((xx > yy) && (xx > zz)) {
          if (xx < epsilon) {
            x = 0;
            y = 0.707106781;
            z = 0.707106781;
          } else {
            x = Math.sqrt(xx);
            y = xy / x;
            z = xz / x;
          }
        } else if (yy > zz) {
          if (yy < epsilon) {
            x = 0.707106781;
            y = 0;
            z = 0.707106781;
          } else {
            y = Math.sqrt(yy);
            x = xy / y;
            z = yz / y;
          }
        } else {
          if (zz < epsilon) {
            x = 0.707106781;
            y = 0.707106781;
            z = 0;
          } else {
            z = Math.sqrt(zz);
            x = xz / z;
            y = yz / z;
          }
        }
        this.set(x, y, z, angle);
        return this;
      }
      var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
      if (Math.abs(s) < 0.001)
        s = 1;
      this.x = (m32 - m23) / s;
      this.y = (m13 - m31) / s;
      this.z = (m21 - m12) / s;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    },
    min: function(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      this.w = Math.min(this.w, v.w);
      return this;
    },
    max: function(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      this.w = Math.max(this.w, v.w);
      return this;
    },
    clamp: function(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      this.w = Math.max(min.w, Math.min(max.w, this.w));
      return this;
    },
    clampScalar: function() {
      var min,
          max;
      return function clampScalar(minVal, maxVal) {
        if (min === undefined) {
          min = new THREE.Vector4();
          max = new THREE.Vector4();
        }
        min.set(minVal, minVal, minVal, minVal);
        max.set(maxVal, maxVal, maxVal, maxVal);
        return this.clamp(min, max);
      };
    }(),
    floor: function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    },
    ceil: function() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    },
    round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    },
    roundToZero: function() {
      this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
      this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    },
    dot: function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    },
    lengthManhattan: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function() {
      return this.divideScalar(this.length());
    },
    setLength: function(length) {
      return this.multiplyScalar(length / this.length());
    },
    lerp: function(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      this.w += (v.w - this.w) * alpha;
      return this;
    },
    lerpVectors: function(v1, v2, alpha) {
      this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
      return this;
    },
    equals: function(v) {
      return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
    },
    fromArray: function(array, offset) {
      if (offset === undefined)
        offset = 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    },
    toArray: function(array, offset) {
      if (array === undefined)
        array = [];
      if (offset === undefined)
        offset = 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    },
    fromAttribute: function(attribute, index, offset) {
      if (offset === undefined)
        offset = 0;
      index = index * attribute.itemSize + offset;
      this.x = attribute.array[index];
      this.y = attribute.array[index + 1];
      this.z = attribute.array[index + 2];
      this.w = attribute.array[index + 3];
      return this;
    }
  };
  THREE.Euler = function(x, y, z, order) {
    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._order = order || THREE.Euler.DefaultOrder;
  };
  THREE.Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
  THREE.Euler.DefaultOrder = 'XYZ';
  THREE.Euler.prototype = {
    constructor: THREE.Euler,
    get x() {
      return this._x;
    },
    set x(value) {
      this._x = value;
      this.onChangeCallback();
    },
    get y() {
      return this._y;
    },
    set y(value) {
      this._y = value;
      this.onChangeCallback();
    },
    get z() {
      return this._z;
    },
    set z(value) {
      this._z = value;
      this.onChangeCallback();
    },
    get order() {
      return this._order;
    },
    set order(value) {
      this._order = value;
      this.onChangeCallback();
    },
    set: function(x, y, z, order) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order || this._order;
      this.onChangeCallback();
      return this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    },
    copy: function(euler) {
      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;
      this.onChangeCallback();
      return this;
    },
    setFromRotationMatrix: function(m, order, update) {
      var clamp = THREE.Math.clamp;
      var te = m.elements;
      var m11 = te[0],
          m12 = te[4],
          m13 = te[8];
      var m21 = te[1],
          m22 = te[5],
          m23 = te[9];
      var m31 = te[2],
          m32 = te[6],
          m33 = te[10];
      order = order || this._order;
      if (order === 'XYZ') {
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.99999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
      } else if (order === 'YXZ') {
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.99999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
      } else if (order === 'ZXY') {
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.99999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
      } else if (order === 'ZYX') {
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.99999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
      } else if (order === 'YZX') {
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.99999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
      } else if (order === 'XZY') {
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.99999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
      } else {
        console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
      }
      this._order = order;
      if (update !== false)
        this.onChangeCallback();
      return this;
    },
    setFromQuaternion: function() {
      var matrix;
      return function(q, order, update) {
        if (matrix === undefined)
          matrix = new THREE.Matrix4();
        matrix.makeRotationFromQuaternion(q);
        this.setFromRotationMatrix(matrix, order, update);
        return this;
      };
    }(),
    setFromVector3: function(v, order) {
      return this.set(v.x, v.y, v.z, order || this._order);
    },
    reorder: function() {
      var q = new THREE.Quaternion();
      return function(newOrder) {
        q.setFromEuler(this);
        this.setFromQuaternion(q, newOrder);
      };
    }(),
    equals: function(euler) {
      return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
    },
    fromArray: function(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== undefined)
        this._order = array[3];
      this.onChangeCallback();
      return this;
    },
    toArray: function(array, offset) {
      if (array === undefined)
        array = [];
      if (offset === undefined)
        offset = 0;
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    },
    toVector3: function(optionalResult) {
      if (optionalResult) {
        return optionalResult.set(this._x, this._y, this._z);
      } else {
        return new THREE.Vector3(this._x, this._y, this._z);
      }
    },
    onChange: function(callback) {
      this.onChangeCallback = callback;
      return this;
    },
    onChangeCallback: function() {}
  };
  THREE.Line3 = function(start, end) {
    this.start = (start !== undefined) ? start : new THREE.Vector3();
    this.end = (end !== undefined) ? end : new THREE.Vector3();
  };
  THREE.Line3.prototype = {
    constructor: THREE.Line3,
    set: function(start, end) {
      this.start.copy(start);
      this.end.copy(end);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(line) {
      this.start.copy(line.start);
      this.end.copy(line.end);
      return this;
    },
    center: function(optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      return result.addVectors(this.start, this.end).multiplyScalar(0.5);
    },
    delta: function(optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      return result.subVectors(this.end, this.start);
    },
    distanceSq: function() {
      return this.start.distanceToSquared(this.end);
    },
    distance: function() {
      return this.start.distanceTo(this.end);
    },
    at: function(t, optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      return this.delta(result).multiplyScalar(t).add(this.start);
    },
    closestPointToPointParameter: function() {
      var startP = new THREE.Vector3();
      var startEnd = new THREE.Vector3();
      return function(point, clampToLine) {
        startP.subVectors(point, this.start);
        startEnd.subVectors(this.end, this.start);
        var startEnd2 = startEnd.dot(startEnd);
        var startEnd_startP = startEnd.dot(startP);
        var t = startEnd_startP / startEnd2;
        if (clampToLine) {
          t = THREE.Math.clamp(t, 0, 1);
        }
        return t;
      };
    }(),
    closestPointToPoint: function(point, clampToLine, optionalTarget) {
      var t = this.closestPointToPointParameter(point, clampToLine);
      var result = optionalTarget || new THREE.Vector3();
      return this.delta(result).multiplyScalar(t).add(this.start);
    },
    applyMatrix4: function(matrix) {
      this.start.applyMatrix4(matrix);
      this.end.applyMatrix4(matrix);
      return this;
    },
    equals: function(line) {
      return line.start.equals(this.start) && line.end.equals(this.end);
    }
  };
  THREE.Box2 = function(min, max) {
    this.min = (min !== undefined) ? min : new THREE.Vector2(Infinity, Infinity);
    this.max = (max !== undefined) ? max : new THREE.Vector2(-Infinity, -Infinity);
  };
  THREE.Box2.prototype = {
    constructor: THREE.Box2,
    set: function(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    },
    setFromPoints: function(points) {
      this.makeEmpty();
      for (var i = 0,
          il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    },
    setFromCenterAndSize: function() {
      var v1 = new THREE.Vector2();
      return function(center, size) {
        var halfSize = v1.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    },
    makeEmpty: function() {
      this.min.x = this.min.y = Infinity;
      this.max.x = this.max.y = -Infinity;
      return this;
    },
    empty: function() {
      return (this.max.x < this.min.x) || (this.max.y < this.min.y);
    },
    center: function(optionalTarget) {
      var result = optionalTarget || new THREE.Vector2();
      return result.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    size: function(optionalTarget) {
      var result = optionalTarget || new THREE.Vector2();
      return result.subVectors(this.max, this.min);
    },
    expandByPoint: function(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    },
    expandByVector: function(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    },
    expandByScalar: function(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    },
    containsPoint: function(point) {
      if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) {
        return false;
      }
      return true;
    },
    containsBox: function(box) {
      if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) && (this.min.y <= box.min.y) && (box.max.y <= this.max.y)) {
        return true;
      }
      return false;
    },
    getParameter: function(point, optionalTarget) {
      var result = optionalTarget || new THREE.Vector2();
      return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    },
    isIntersectionBox: function(box) {
      if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) {
        return false;
      }
      return true;
    },
    clampPoint: function(point, optionalTarget) {
      var result = optionalTarget || new THREE.Vector2();
      return result.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
      var v1 = new THREE.Vector2();
      return function(point) {
        var clampedPoint = v1.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      };
    }(),
    intersect: function(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      return this;
    },
    union: function(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    },
    translate: function(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    },
    equals: function(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  };
  THREE.Box3 = function(min, max) {
    this.min = (min !== undefined) ? min : new THREE.Vector3(Infinity, Infinity, Infinity);
    this.max = (max !== undefined) ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
  };
  THREE.Box3.prototype = {
    constructor: THREE.Box3,
    set: function(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    },
    setFromPoints: function(points) {
      this.makeEmpty();
      for (var i = 0,
          il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    },
    setFromCenterAndSize: function() {
      var v1 = new THREE.Vector3();
      return function(center, size) {
        var halfSize = v1.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      };
    }(),
    setFromObject: function() {
      var v1 = new THREE.Vector3();
      return function(object) {
        var scope = this;
        object.updateMatrixWorld(true);
        this.makeEmpty();
        object.traverse(function(node) {
          var geometry = node.geometry;
          if (geometry !== undefined) {
            if (geometry instanceof THREE.Geometry) {
              var vertices = geometry.vertices;
              for (var i = 0,
                  il = vertices.length; i < il; i++) {
                v1.copy(vertices[i]);
                v1.applyMatrix4(node.matrixWorld);
                scope.expandByPoint(v1);
              }
            } else if (geometry instanceof THREE.BufferGeometry && geometry.attributes['position'] !== undefined) {
              var positions = geometry.attributes['position'].array;
              for (var i = 0,
                  il = positions.length; i < il; i += 3) {
                v1.set(positions[i], positions[i + 1], positions[i + 2]);
                v1.applyMatrix4(node.matrixWorld);
                scope.expandByPoint(v1);
              }
            }
          }
        });
        return this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    },
    makeEmpty: function() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    },
    empty: function() {
      return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
    },
    center: function(optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      return result.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    size: function(optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      return result.subVectors(this.max, this.min);
    },
    expandByPoint: function(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    },
    expandByVector: function(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    },
    expandByScalar: function(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    },
    containsPoint: function(point) {
      if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) {
        return false;
      }
      return true;
    },
    containsBox: function(box) {
      if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) && (this.min.y <= box.min.y) && (box.max.y <= this.max.y) && (this.min.z <= box.min.z) && (box.max.z <= this.max.z)) {
        return true;
      }
      return false;
    },
    getParameter: function(point, optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    },
    isIntersectionBox: function(box) {
      if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) {
        return false;
      }
      return true;
    },
    clampPoint: function(point, optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      return result.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
      var v1 = new THREE.Vector3();
      return function(point) {
        var clampedPoint = v1.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      };
    }(),
    getBoundingSphere: function() {
      var v1 = new THREE.Vector3();
      return function(optionalTarget) {
        var result = optionalTarget || new THREE.Sphere();
        result.center = this.center();
        result.radius = this.size(v1).length() * 0.5;
        return result;
      };
    }(),
    intersect: function(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      return this;
    },
    union: function(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    },
    applyMatrix4: function() {
      var points = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
      return function(matrix) {
        points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
        points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
        points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
        points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
        points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
        points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
        points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
        points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
        this.makeEmpty();
        this.setFromPoints(points);
        return this;
      };
    }(),
    translate: function(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    },
    equals: function(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  };
  THREE.Matrix3 = function() {
    this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    if (arguments.length > 0) {
      console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
    }
  };
  THREE.Matrix3.prototype = {
    constructor: THREE.Matrix3,
    set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      var te = this.elements;
      te[0] = n11;
      te[3] = n12;
      te[6] = n13;
      te[1] = n21;
      te[4] = n22;
      te[7] = n23;
      te[2] = n31;
      te[5] = n32;
      te[8] = n33;
      return this;
    },
    identity: function() {
      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
      return this;
    },
    clone: function() {
      return new this.constructor().fromArray(this.elements);
    },
    copy: function(m) {
      var me = m.elements;
      this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
      return this;
    },
    multiplyVector3: function(vector) {
      console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
      return vector.applyMatrix3(this);
    },
    multiplyVector3Array: function(a) {
      console.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
      return this.applyToVector3Array(a);
    },
    applyToVector3Array: function() {
      var v1;
      return function(array, offset, length) {
        if (v1 === undefined)
          v1 = new THREE.Vector3();
        if (offset === undefined)
          offset = 0;
        if (length === undefined)
          length = array.length;
        for (var i = 0,
            j = offset; i < length; i += 3, j += 3) {
          v1.fromArray(array, j);
          v1.applyMatrix3(this);
          v1.toArray(array, j);
        }
        return array;
      };
    }(),
    applyToBuffer: function() {
      var v1;
      return function applyToBuffer(buffer, offset, length) {
        if (v1 === undefined)
          v1 = new THREE.Vector3();
        if (offset === undefined)
          offset = 0;
        if (length === undefined)
          length = buffer.length / buffer.itemSize;
        for (var i = 0,
            j = offset; i < length; i++, j++) {
          v1.x = buffer.getX(j);
          v1.y = buffer.getY(j);
          v1.z = buffer.getZ(j);
          v1.applyMatrix3(this);
          buffer.setXYZ(v1.x, v1.y, v1.z);
        }
        return buffer;
      };
    }(),
    multiplyScalar: function(s) {
      var te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    },
    determinant: function() {
      var te = this.elements;
      var a = te[0],
          b = te[1],
          c = te[2],
          d = te[3],
          e = te[4],
          f = te[5],
          g = te[6],
          h = te[7],
          i = te[8];
      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    },
    getInverse: function(matrix, throwOnInvertible) {
      var me = matrix.elements;
      var te = this.elements;
      te[0] = me[10] * me[5] - me[6] * me[9];
      te[1] = -me[10] * me[1] + me[2] * me[9];
      te[2] = me[6] * me[1] - me[2] * me[5];
      te[3] = -me[10] * me[4] + me[6] * me[8];
      te[4] = me[10] * me[0] - me[2] * me[8];
      te[5] = -me[6] * me[0] + me[2] * me[4];
      te[6] = me[9] * me[4] - me[5] * me[8];
      te[7] = -me[9] * me[0] + me[1] * me[8];
      te[8] = me[5] * me[0] - me[1] * me[4];
      var det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];
      if (det === 0) {
        var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
        if (throwOnInvertible || false) {
          throw new Error(msg);
        } else {
          console.warn(msg);
        }
        this.identity();
        return this;
      }
      this.multiplyScalar(1.0 / det);
      return this;
    },
    transpose: function() {
      var tmp,
          m = this.elements;
      tmp = m[1];
      m[1] = m[3];
      m[3] = tmp;
      tmp = m[2];
      m[2] = m[6];
      m[6] = tmp;
      tmp = m[5];
      m[5] = m[7];
      m[7] = tmp;
      return this;
    },
    flattenToArrayOffset: function(array, offset) {
      var te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    },
    getNormalMatrix: function(m) {
      this.getInverse(m).transpose();
      return this;
    },
    transposeIntoArray: function(r) {
      var m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    },
    fromArray: function(array) {
      this.elements.set(array);
      return this;
    },
    toArray: function() {
      var te = this.elements;
      return [te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8]];
    }
  };
  THREE.Matrix4 = function() {
    this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    if (arguments.length > 0) {
      console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
    }
  };
  THREE.Matrix4.prototype = {
    constructor: THREE.Matrix4,
    set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      var te = this.elements;
      te[0] = n11;
      te[4] = n12;
      te[8] = n13;
      te[12] = n14;
      te[1] = n21;
      te[5] = n22;
      te[9] = n23;
      te[13] = n24;
      te[2] = n31;
      te[6] = n32;
      te[10] = n33;
      te[14] = n34;
      te[3] = n41;
      te[7] = n42;
      te[11] = n43;
      te[15] = n44;
      return this;
    },
    identity: function() {
      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    },
    clone: function() {
      return new THREE.Matrix4().fromArray(this.elements);
    },
    copy: function(m) {
      this.elements.set(m.elements);
      return this;
    },
    extractPosition: function(m) {
      console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
      return this.copyPosition(m);
    },
    copyPosition: function(m) {
      var te = this.elements;
      var me = m.elements;
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      return this;
    },
    extractBasis: function(xAxis, yAxis, zAxis) {
      var te = this.elements;
      xAxis.set(te[0], te[1], te[2]);
      yAxis.set(te[4], te[5], te[6]);
      zAxis.set(te[8], te[9], te[10]);
      return this;
    },
    makeBasis: function(xAxis, yAxis, zAxis) {
      this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
      return this;
    },
    extractRotation: function() {
      var v1;
      return function(m) {
        if (v1 === undefined)
          v1 = new THREE.Vector3();
        var te = this.elements;
        var me = m.elements;
        var scaleX = 1 / v1.set(me[0], me[1], me[2]).length();
        var scaleY = 1 / v1.set(me[4], me[5], me[6]).length();
        var scaleZ = 1 / v1.set(me[8], me[9], me[10]).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        return this;
      };
    }(),
    makeRotationFromEuler: function(euler) {
      if (euler instanceof THREE.Euler === false) {
        console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
      }
      var te = this.elements;
      var x = euler.x,
          y = euler.y,
          z = euler.z;
      var a = Math.cos(x),
          b = Math.sin(x);
      var c = Math.cos(y),
          d = Math.sin(y);
      var e = Math.cos(z),
          f = Math.sin(z);
      if (euler.order === 'XYZ') {
        var ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;
        te[1] = af + be * d;
        te[5] = ae - bf * d;
        te[9] = -b * c;
        te[2] = bf - ae * d;
        te[6] = be + af * d;
        te[10] = a * c;
      } else if (euler.order === 'YXZ') {
        var ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
        te[0] = ce + df * b;
        te[4] = de * b - cf;
        te[8] = a * d;
        te[1] = a * f;
        te[5] = a * e;
        te[9] = -b;
        te[2] = cf * b - de;
        te[6] = df + ce * b;
        te[10] = a * c;
      } else if (euler.order === 'ZXY') {
        var ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
        te[0] = ce - df * b;
        te[4] = -a * f;
        te[8] = de + cf * b;
        te[1] = cf + de * b;
        te[5] = a * e;
        te[9] = df - ce * b;
        te[2] = -a * d;
        te[6] = b;
        te[10] = a * c;
      } else if (euler.order === 'ZYX') {
        var ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
        te[0] = c * e;
        te[4] = be * d - af;
        te[8] = ae * d + bf;
        te[1] = c * f;
        te[5] = bf * d + ae;
        te[9] = af * d - be;
        te[2] = -d;
        te[6] = b * c;
        te[10] = a * c;
      } else if (euler.order === 'YZX') {
        var ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
        te[0] = c * e;
        te[4] = bd - ac * f;
        te[8] = bc * f + ad;
        te[1] = f;
        te[5] = a * e;
        te[9] = -b * e;
        te[2] = -d * e;
        te[6] = ad * f + bc;
        te[10] = ac - bd * f;
      } else if (euler.order === 'XZY') {
        var ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
        te[0] = c * e;
        te[4] = -f;
        te[8] = d * e;
        te[1] = ac * f + bd;
        te[5] = a * e;
        te[9] = ad * f - bc;
        te[2] = bc * f - ad;
        te[6] = b * e;
        te[10] = bd * f + ac;
      }
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    },
    setRotationFromQuaternion: function(q) {
      console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
      return this.makeRotationFromQuaternion(q);
    },
    makeRotationFromQuaternion: function(q) {
      var te = this.elements;
      var x = q.x,
          y = q.y,
          z = q.z,
          w = q.w;
      var x2 = x + x,
          y2 = y + y,
          z2 = z + z;
      var xx = x * x2,
          xy = x * y2,
          xz = x * z2;
      var yy = y * y2,
          yz = y * z2,
          zz = z * z2;
      var wx = w * x2,
          wy = w * y2,
          wz = w * z2;
      te[0] = 1 - (yy + zz);
      te[4] = xy - wz;
      te[8] = xz + wy;
      te[1] = xy + wz;
      te[5] = 1 - (xx + zz);
      te[9] = yz - wx;
      te[2] = xz - wy;
      te[6] = yz + wx;
      te[10] = 1 - (xx + yy);
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    },
    lookAt: function() {
      var x,
          y,
          z;
      return function(eye, target, up) {
        if (x === undefined)
          x = new THREE.Vector3();
        if (y === undefined)
          y = new THREE.Vector3();
        if (z === undefined)
          z = new THREE.Vector3();
        var te = this.elements;
        z.subVectors(eye, target).normalize();
        if (z.lengthSq() === 0) {
          z.z = 1;
        }
        x.crossVectors(up, z).normalize();
        if (x.lengthSq() === 0) {
          z.x += 0.0001;
          x.crossVectors(up, z).normalize();
        }
        y.crossVectors(z, x);
        te[0] = x.x;
        te[4] = y.x;
        te[8] = z.x;
        te[1] = x.y;
        te[5] = y.y;
        te[9] = z.y;
        te[2] = x.z;
        te[6] = y.z;
        te[10] = z.z;
        return this;
      };
    }(),
    multiply: function(m, n) {
      if (n !== undefined) {
        console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
        return this.multiplyMatrices(m, n);
      }
      return this.multiplyMatrices(this, m);
    },
    multiplyMatrices: function(a, b) {
      var ae = a.elements;
      var be = b.elements;
      var te = this.elements;
      var a11 = ae[0],
          a12 = ae[4],
          a13 = ae[8],
          a14 = ae[12];
      var a21 = ae[1],
          a22 = ae[5],
          a23 = ae[9],
          a24 = ae[13];
      var a31 = ae[2],
          a32 = ae[6],
          a33 = ae[10],
          a34 = ae[14];
      var a41 = ae[3],
          a42 = ae[7],
          a43 = ae[11],
          a44 = ae[15];
      var b11 = be[0],
          b12 = be[4],
          b13 = be[8],
          b14 = be[12];
      var b21 = be[1],
          b22 = be[5],
          b23 = be[9],
          b24 = be[13];
      var b31 = be[2],
          b32 = be[6],
          b33 = be[10],
          b34 = be[14];
      var b41 = be[3],
          b42 = be[7],
          b43 = be[11],
          b44 = be[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    },
    multiplyToArray: function(a, b, r) {
      var te = this.elements;
      this.multiplyMatrices(a, b);
      r[0] = te[0];
      r[1] = te[1];
      r[2] = te[2];
      r[3] = te[3];
      r[4] = te[4];
      r[5] = te[5];
      r[6] = te[6];
      r[7] = te[7];
      r[8] = te[8];
      r[9] = te[9];
      r[10] = te[10];
      r[11] = te[11];
      r[12] = te[12];
      r[13] = te[13];
      r[14] = te[14];
      r[15] = te[15];
      return this;
    },
    multiplyScalar: function(s) {
      var te = this.elements;
      te[0] *= s;
      te[4] *= s;
      te[8] *= s;
      te[12] *= s;
      te[1] *= s;
      te[5] *= s;
      te[9] *= s;
      te[13] *= s;
      te[2] *= s;
      te[6] *= s;
      te[10] *= s;
      te[14] *= s;
      te[3] *= s;
      te[7] *= s;
      te[11] *= s;
      te[15] *= s;
      return this;
    },
    multiplyVector3: function(vector) {
      console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
      return vector.applyProjection(this);
    },
    multiplyVector4: function(vector) {
      console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
      return vector.applyMatrix4(this);
    },
    multiplyVector3Array: function(a) {
      console.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
      return this.applyToVector3Array(a);
    },
    applyToVector3Array: function() {
      var v1;
      return function(array, offset, length) {
        if (v1 === undefined)
          v1 = new THREE.Vector3();
        if (offset === undefined)
          offset = 0;
        if (length === undefined)
          length = array.length;
        for (var i = 0,
            j = offset; i < length; i += 3, j += 3) {
          v1.fromArray(array, j);
          v1.applyMatrix4(this);
          v1.toArray(array, j);
        }
        return array;
      };
    }(),
    applyToBuffer: function() {
      var v1;
      return function applyToBuffer(buffer, offset, length) {
        if (v1 === undefined)
          v1 = new THREE.Vector3();
        if (offset === undefined)
          offset = 0;
        if (length === undefined)
          length = buffer.length / buffer.itemSize;
        for (var i = 0,
            j = offset; i < length; i++, j++) {
          v1.x = buffer.getX(j);
          v1.y = buffer.getY(j);
          v1.z = buffer.getZ(j);
          v1.applyMatrix4(this);
          buffer.setXYZ(v1.x, v1.y, v1.z);
        }
        return buffer;
      };
    }(),
    rotateAxis: function(v) {
      console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
      v.transformDirection(this);
    },
    crossVector: function(vector) {
      console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
      return vector.applyMatrix4(this);
    },
    determinant: function() {
      var te = this.elements;
      var n11 = te[0],
          n12 = te[4],
          n13 = te[8],
          n14 = te[12];
      var n21 = te[1],
          n22 = te[5],
          n23 = te[9],
          n24 = te[13];
      var n31 = te[2],
          n32 = te[6],
          n33 = te[10],
          n34 = te[14];
      var n41 = te[3],
          n42 = te[7],
          n43 = te[11],
          n44 = te[15];
      return (n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31));
    },
    transpose: function() {
      var te = this.elements;
      var tmp;
      tmp = te[1];
      te[1] = te[4];
      te[4] = tmp;
      tmp = te[2];
      te[2] = te[8];
      te[8] = tmp;
      tmp = te[6];
      te[6] = te[9];
      te[9] = tmp;
      tmp = te[3];
      te[3] = te[12];
      te[12] = tmp;
      tmp = te[7];
      te[7] = te[13];
      te[13] = tmp;
      tmp = te[11];
      te[11] = te[14];
      te[14] = tmp;
      return this;
    },
    flattenToArrayOffset: function(array, offset) {
      var te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    },
    getPosition: function() {
      var v1;
      return function() {
        if (v1 === undefined)
          v1 = new THREE.Vector3();
        console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
        var te = this.elements;
        return v1.set(te[12], te[13], te[14]);
      };
    }(),
    setPosition: function(v) {
      var te = this.elements;
      te[12] = v.x;
      te[13] = v.y;
      te[14] = v.z;
      return this;
    },
    getInverse: function(m, throwOnInvertible) {
      var te = this.elements;
      var me = m.elements;
      var n11 = me[0],
          n12 = me[4],
          n13 = me[8],
          n14 = me[12];
      var n21 = me[1],
          n22 = me[5],
          n23 = me[9],
          n24 = me[13];
      var n31 = me[2],
          n32 = me[6],
          n33 = me[10],
          n34 = me[14];
      var n41 = me[3],
          n42 = me[7],
          n43 = me[11],
          n44 = me[15];
      te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
      te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
      te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
      te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
      te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
      te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
      te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
      te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
      te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
      te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
      te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
      te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
      te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
      te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
      te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
      var det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];
      if (det === 0) {
        var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
        if (throwOnInvertible || false) {
          throw new Error(msg);
        } else {
          console.warn(msg);
        }
        this.identity();
        return this;
      }
      this.multiplyScalar(1 / det);
      return this;
    },
    translate: function(v) {
      console.error('THREE.Matrix4: .translate() has been removed.');
    },
    rotateX: function(angle) {
      console.error('THREE.Matrix4: .rotateX() has been removed.');
    },
    rotateY: function(angle) {
      console.error('THREE.Matrix4: .rotateY() has been removed.');
    },
    rotateZ: function(angle) {
      console.error('THREE.Matrix4: .rotateZ() has been removed.');
    },
    rotateByAxis: function(axis, angle) {
      console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
    },
    scale: function(v) {
      var te = this.elements;
      var x = v.x,
          y = v.y,
          z = v.z;
      te[0] *= x;
      te[4] *= y;
      te[8] *= z;
      te[1] *= x;
      te[5] *= y;
      te[9] *= z;
      te[2] *= x;
      te[6] *= y;
      te[10] *= z;
      te[3] *= x;
      te[7] *= y;
      te[11] *= z;
      return this;
    },
    getMaxScaleOnAxis: function() {
      var te = this.elements;
      var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    },
    makeTranslation: function(x, y, z) {
      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
      return this;
    },
    makeRotationX: function(theta) {
      var c = Math.cos(theta),
          s = Math.sin(theta);
      this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
      return this;
    },
    makeRotationY: function(theta) {
      var c = Math.cos(theta),
          s = Math.sin(theta);
      this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
      return this;
    },
    makeRotationZ: function(theta) {
      var c = Math.cos(theta),
          s = Math.sin(theta);
      this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    },
    makeRotationAxis: function(axis, angle) {
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      var t = 1 - c;
      var x = axis.x,
          y = axis.y,
          z = axis.z;
      var tx = t * x,
          ty = t * y;
      this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
      return this;
    },
    makeScale: function(x, y, z) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
      return this;
    },
    compose: function(position, quaternion, scale) {
      this.makeRotationFromQuaternion(quaternion);
      this.scale(scale);
      this.setPosition(position);
      return this;
    },
    decompose: function() {
      var vector,
          matrix;
      return function(position, quaternion, scale) {
        if (vector === undefined)
          vector = new THREE.Vector3();
        if (matrix === undefined)
          matrix = new THREE.Matrix4();
        var te = this.elements;
        var sx = vector.set(te[0], te[1], te[2]).length();
        var sy = vector.set(te[4], te[5], te[6]).length();
        var sz = vector.set(te[8], te[9], te[10]).length();
        var det = this.determinant();
        if (det < 0) {
          sx = -sx;
        }
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        matrix.elements.set(this.elements);
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        matrix.elements[0] *= invSX;
        matrix.elements[1] *= invSX;
        matrix.elements[2] *= invSX;
        matrix.elements[4] *= invSY;
        matrix.elements[5] *= invSY;
        matrix.elements[6] *= invSY;
        matrix.elements[8] *= invSZ;
        matrix.elements[9] *= invSZ;
        matrix.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(matrix);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
      };
    }(),
    makeFrustum: function(left, right, bottom, top, near, far) {
      var te = this.elements;
      var x = 2 * near / (right - left);
      var y = 2 * near / (top - bottom);
      var a = (right + left) / (right - left);
      var b = (top + bottom) / (top - bottom);
      var c = -(far + near) / (far - near);
      var d = -2 * far * near / (far - near);
      te[0] = x;
      te[4] = 0;
      te[8] = a;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = b;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = c;
      te[14] = d;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    },
    makePerspective: function(fov, aspect, near, far) {
      var ymax = near * Math.tan(THREE.Math.degToRad(fov * 0.5));
      var ymin = -ymax;
      var xmin = ymin * aspect;
      var xmax = ymax * aspect;
      return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
    },
    makeOrthographic: function(left, right, top, bottom, near, far) {
      var te = this.elements;
      var w = right - left;
      var h = top - bottom;
      var p = far - near;
      var x = (right + left) / w;
      var y = (top + bottom) / h;
      var z = (far + near) / p;
      te[0] = 2 / w;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x;
      te[1] = 0;
      te[5] = 2 / h;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = -2 / p;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    },
    equals: function(matrix) {
      var te = this.elements;
      var me = matrix.elements;
      for (var i = 0; i < 16; i++) {
        if (te[i] !== me[i])
          return false;
      }
      return true;
    },
    fromArray: function(array) {
      this.elements.set(array);
      return this;
    },
    toArray: function() {
      var te = this.elements;
      return [te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8], te[9], te[10], te[11], te[12], te[13], te[14], te[15]];
    }
  };
  THREE.Ray = function(origin, direction) {
    this.origin = (origin !== undefined) ? origin : new THREE.Vector3();
    this.direction = (direction !== undefined) ? direction : new THREE.Vector3();
  };
  THREE.Ray.prototype = {
    constructor: THREE.Ray,
    set: function(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    },
    at: function(t, optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      return result.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    recast: function() {
      var v1 = new THREE.Vector3();
      return function(t) {
        this.origin.copy(this.at(t, v1));
        return this;
      };
    }(),
    closestPointToPoint: function(point, optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      result.subVectors(point, this.origin);
      var directionDistance = result.dot(this.direction);
      if (directionDistance < 0) {
        return result.copy(this.origin);
      }
      return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    },
    distanceToPoint: function(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    },
    distanceSqToPoint: function() {
      var v1 = new THREE.Vector3();
      return function(point) {
        var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
        if (directionDistance < 0) {
          return this.origin.distanceToSquared(point);
        }
        v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return v1.distanceToSquared(point);
      };
    }(),
    distanceSqToSegment: function() {
      var segCenter = new THREE.Vector3();
      var segDir = new THREE.Vector3();
      var diff = new THREE.Vector3();
      return function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        segDir.copy(v1).sub(v0).normalize();
        diff.copy(this.origin).sub(segCenter);
        var segExtent = v0.distanceTo(v1) * 0.5;
        var a01 = -this.direction.dot(segDir);
        var b0 = diff.dot(this.direction);
        var b1 = -diff.dot(segDir);
        var c = diff.lengthSq();
        var det = Math.abs(1 - a01 * a01);
        var s0,
            s1,
            sqrDist,
            extDet;
        if (det > 0) {
          s0 = a01 * b1 - b0;
          s1 = a01 * b0 - b1;
          extDet = segExtent * det;
          if (s0 >= 0) {
            if (s1 >= -extDet) {
              if (s1 <= extDet) {
                var invDet = 1 / det;
                s0 *= invDet;
                s1 *= invDet;
                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
              } else {
                s1 = segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              s1 = -segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            if (s1 <= -extDet) {
              s0 = Math.max(0, -(-a01 * segExtent + b0));
              s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            } else if (s1 <= extDet) {
              s0 = 0;
              s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = s1 * (s1 + 2 * b1) + c;
            } else {
              s0 = Math.max(0, -(a01 * segExtent + b0));
              s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          }
        } else {
          s1 = (a01 > 0) ? -segExtent : segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) {
          optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        }
        if (optionalPointOnSegment) {
          optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
        }
        return sqrDist;
      };
    }(),
    isIntersectionSphere: function(sphere) {
      return this.distanceToPoint(sphere.center) <= sphere.radius;
    },
    intersectSphere: function() {
      var v1 = new THREE.Vector3();
      return function(sphere, optionalTarget) {
        v1.subVectors(sphere.center, this.origin);
        var tca = v1.dot(this.direction);
        var d2 = v1.dot(v1) - tca * tca;
        var radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2)
          return null;
        var thc = Math.sqrt(radius2 - d2);
        var t0 = tca - thc;
        var t1 = tca + thc;
        if (t0 < 0 && t1 < 0)
          return null;
        if (t0 < 0)
          return this.at(t1, optionalTarget);
        return this.at(t0, optionalTarget);
      };
    }(),
    isIntersectionPlane: function(plane) {
      var distToPoint = plane.distanceToPoint(this.origin);
      if (distToPoint === 0) {
        return true;
      }
      var denominator = plane.normal.dot(this.direction);
      if (denominator * distToPoint < 0) {
        return true;
      }
      return false;
    },
    distanceToPlane: function(plane) {
      var denominator = plane.normal.dot(this.direction);
      if (denominator === 0) {
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        }
        return null;
      }
      var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
      return t >= 0 ? t : null;
    },
    intersectPlane: function(plane, optionalTarget) {
      var t = this.distanceToPlane(plane);
      if (t === null) {
        return null;
      }
      return this.at(t, optionalTarget);
    },
    isIntersectionBox: function() {
      var v = new THREE.Vector3();
      return function(box) {
        return this.intersectBox(box, v) !== null;
      };
    }(),
    intersectBox: function(box, optionalTarget) {
      var tmin,
          tmax,
          tymin,
          tymax,
          tzmin,
          tzmax;
      var invdirx = 1 / this.direction.x,
          invdiry = 1 / this.direction.y,
          invdirz = 1 / this.direction.z;
      var origin = this.origin;
      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }
      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }
      if ((tmin > tymax) || (tymin > tmax))
        return null;
      if (tymin > tmin || tmin !== tmin)
        tmin = tymin;
      if (tymax < tmax || tmax !== tmax)
        tmax = tymax;
      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }
      if ((tmin > tzmax) || (tzmin > tmax))
        return null;
      if (tzmin > tmin || tmin !== tmin)
        tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax)
        tmax = tzmax;
      if (tmax < 0)
        return null;
      return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
    },
    intersectTriangle: function() {
      var diff = new THREE.Vector3();
      var edge1 = new THREE.Vector3();
      var edge2 = new THREE.Vector3();
      var normal = new THREE.Vector3();
      return function(a, b, c, backfaceCulling, optionalTarget) {
        edge1.subVectors(b, a);
        edge2.subVectors(c, a);
        normal.crossVectors(edge1, edge2);
        var DdN = this.direction.dot(normal);
        var sign;
        if (DdN > 0) {
          if (backfaceCulling)
            return null;
          sign = 1;
        } else if (DdN < 0) {
          sign = -1;
          DdN = -DdN;
        } else {
          return null;
        }
        diff.subVectors(this.origin, a);
        var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
        if (DdQxE2 < 0) {
          return null;
        }
        var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
        if (DdE1xQ < 0) {
          return null;
        }
        if (DdQxE2 + DdE1xQ > DdN) {
          return null;
        }
        var QdN = -sign * diff.dot(normal);
        if (QdN < 0) {
          return null;
        }
        return this.at(QdN / DdN, optionalTarget);
      };
    }(),
    applyMatrix4: function(matrix4) {
      this.direction.add(this.origin).applyMatrix4(matrix4);
      this.origin.applyMatrix4(matrix4);
      this.direction.sub(this.origin);
      this.direction.normalize();
      return this;
    },
    equals: function(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
  };
  THREE.Sphere = function(center, radius) {
    this.center = (center !== undefined) ? center : new THREE.Vector3();
    this.radius = (radius !== undefined) ? radius : 0;
  };
  THREE.Sphere.prototype = {
    constructor: THREE.Sphere,
    set: function(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    },
    setFromPoints: function() {
      var box = new THREE.Box3();
      return function(points, optionalCenter) {
        var center = this.center;
        if (optionalCenter !== undefined) {
          center.copy(optionalCenter);
        } else {
          box.setFromPoints(points).center(center);
        }
        var maxRadiusSq = 0;
        for (var i = 0,
            il = points.length; i < il; i++) {
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
        }
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    },
    empty: function() {
      return (this.radius <= 0);
    },
    containsPoint: function(point) {
      return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
    },
    distanceToPoint: function(point) {
      return (point.distanceTo(this.center) - this.radius);
    },
    intersectsSphere: function(sphere) {
      var radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
    },
    clampPoint: function(point, optionalTarget) {
      var deltaLengthSq = this.center.distanceToSquared(point);
      var result = optionalTarget || new THREE.Vector3();
      result.copy(point);
      if (deltaLengthSq > (this.radius * this.radius)) {
        result.sub(this.center).normalize();
        result.multiplyScalar(this.radius).add(this.center);
      }
      return result;
    },
    getBoundingBox: function(optionalTarget) {
      var box = optionalTarget || new THREE.Box3();
      box.set(this.center, this.center);
      box.expandByScalar(this.radius);
      return box;
    },
    applyMatrix4: function(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    },
    translate: function(offset) {
      this.center.add(offset);
      return this;
    },
    equals: function(sphere) {
      return sphere.center.equals(this.center) && (sphere.radius === this.radius);
    }
  };
  THREE.Frustum = function(p0, p1, p2, p3, p4, p5) {
    this.planes = [(p0 !== undefined) ? p0 : new THREE.Plane(), (p1 !== undefined) ? p1 : new THREE.Plane(), (p2 !== undefined) ? p2 : new THREE.Plane(), (p3 !== undefined) ? p3 : new THREE.Plane(), (p4 !== undefined) ? p4 : new THREE.Plane(), (p5 !== undefined) ? p5 : new THREE.Plane()];
  };
  THREE.Frustum.prototype = {
    constructor: THREE.Frustum,
    set: function(p0, p1, p2, p3, p4, p5) {
      var planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(frustum) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        planes[i].copy(frustum.planes[i]);
      }
      return this;
    },
    setFromMatrix: function(m) {
      var planes = this.planes;
      var me = m.elements;
      var me0 = me[0],
          me1 = me[1],
          me2 = me[2],
          me3 = me[3];
      var me4 = me[4],
          me5 = me[5],
          me6 = me[6],
          me7 = me[7];
      var me8 = me[8],
          me9 = me[9],
          me10 = me[10],
          me11 = me[11];
      var me12 = me[12],
          me13 = me[13],
          me14 = me[14],
          me15 = me[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
      return this;
    },
    intersectsObject: function() {
      var sphere = new THREE.Sphere();
      return function(object) {
        var geometry = object.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(sphere);
      };
    }(),
    intersectsSphere: function(sphere) {
      var planes = this.planes;
      var center = sphere.center;
      var negRadius = -sphere.radius;
      for (var i = 0; i < 6; i++) {
        var distance = planes[i].distanceToPoint(center);
        if (distance < negRadius) {
          return false;
        }
      }
      return true;
    },
    intersectsBox: function() {
      var p1 = new THREE.Vector3(),
          p2 = new THREE.Vector3();
      return function(box) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
          var plane = planes[i];
          p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
          p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
          p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
          p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
          p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
          p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
          var d1 = plane.distanceToPoint(p1);
          var d2 = plane.distanceToPoint(p2);
          if (d1 < 0 && d2 < 0) {
            return false;
          }
        }
        return true;
      };
    }(),
    containsPoint: function(point) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        if (planes[i].distanceToPoint(point) < 0) {
          return false;
        }
      }
      return true;
    }
  };
  THREE.Plane = function(normal, constant) {
    this.normal = (normal !== undefined) ? normal : new THREE.Vector3(1, 0, 0);
    this.constant = (constant !== undefined) ? constant : 0;
  };
  THREE.Plane.prototype = {
    constructor: THREE.Plane,
    set: function(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    },
    setComponents: function(x, y, z, w) {
      this.normal.set(x, y, z);
      this.constant = w;
      return this;
    },
    setFromNormalAndCoplanarPoint: function(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    },
    setFromCoplanarPoints: function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      return function(a, b, c) {
        var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
        this.setFromNormalAndCoplanarPoint(normal, a);
        return this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    },
    normalize: function() {
      var inverseNormalLength = 1.0 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    },
    negate: function() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    },
    distanceToPoint: function(point) {
      return this.normal.dot(point) + this.constant;
    },
    distanceToSphere: function(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    },
    projectPoint: function(point, optionalTarget) {
      return this.orthoPoint(point, optionalTarget).sub(point).negate();
    },
    orthoPoint: function(point, optionalTarget) {
      var perpendicularMagnitude = this.distanceToPoint(point);
      var result = optionalTarget || new THREE.Vector3();
      return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
    },
    isIntersectionLine: function(line) {
      var startSign = this.distanceToPoint(line.start);
      var endSign = this.distanceToPoint(line.end);
      return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
    },
    intersectLine: function() {
      var v1 = new THREE.Vector3();
      return function(line, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        var direction = line.delta(v1);
        var denominator = this.normal.dot(direction);
        if (denominator === 0) {
          if (this.distanceToPoint(line.start) === 0) {
            return result.copy(line.start);
          }
          return undefined;
        }
        var t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) {
          return undefined;
        }
        return result.copy(direction).multiplyScalar(t).add(line.start);
      };
    }(),
    coplanarPoint: function(optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      return result.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      var m1 = new THREE.Matrix3();
      return function(matrix, optionalNormalMatrix) {
        var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
        var newNormal = v1.copy(this.normal).applyMatrix3(normalMatrix);
        var newCoplanarPoint = this.coplanarPoint(v2);
        newCoplanarPoint.applyMatrix4(matrix);
        this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);
        return this;
      };
    }(),
    translate: function(offset) {
      this.constant = this.constant - offset.dot(this.normal);
      return this;
    },
    equals: function(plane) {
      return plane.normal.equals(this.normal) && (plane.constant === this.constant);
    }
  };
  THREE.Math = {
    generateUUID: function() {
      var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
      var uuid = new Array(36);
      var rnd = 0,
          r;
      return function() {
        for (var i = 0; i < 36; i++) {
          if (i === 8 || i === 13 || i === 18 || i === 23) {
            uuid[i] = '-';
          } else if (i === 14) {
            uuid[i] = '4';
          } else {
            if (rnd <= 0x02)
              rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
            r = rnd & 0xf;
            rnd = rnd >> 4;
            uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];
          }
        }
        return uuid.join('');
      };
    }(),
    clamp: function(value, min, max) {
      return Math.max(min, Math.min(max, value));
    },
    euclideanModulo: function(n, m) {
      return ((n % m) + m) % m;
    },
    mapLinear: function(x, a1, a2, b1, b2) {
      return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    },
    smoothstep: function(x, min, max) {
      if (x <= min)
        return 0;
      if (x >= max)
        return 1;
      x = (x - min) / (max - min);
      return x * x * (3 - 2 * x);
    },
    smootherstep: function(x, min, max) {
      if (x <= min)
        return 0;
      if (x >= max)
        return 1;
      x = (x - min) / (max - min);
      return x * x * x * (x * (x * 6 - 15) + 10);
    },
    random16: function() {
      return (65280 * Math.random() + 255 * Math.random()) / 65535;
    },
    randInt: function(low, high) {
      return low + Math.floor(Math.random() * (high - low + 1));
    },
    randFloat: function(low, high) {
      return low + Math.random() * (high - low);
    },
    randFloatSpread: function(range) {
      return range * (0.5 - Math.random());
    },
    degToRad: function() {
      var degreeToRadiansFactor = Math.PI / 180;
      return function(degrees) {
        return degrees * degreeToRadiansFactor;
      };
    }(),
    radToDeg: function() {
      var radianToDegreesFactor = 180 / Math.PI;
      return function(radians) {
        return radians * radianToDegreesFactor;
      };
    }(),
    isPowerOfTwo: function(value) {
      return (value & (value - 1)) === 0 && value !== 0;
    },
    nearestPowerOfTwo: function(value) {
      return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
    },
    nextPowerOfTwo: function(value) {
      value--;
      value |= value >> 1;
      value |= value >> 2;
      value |= value >> 4;
      value |= value >> 8;
      value |= value >> 16;
      value++;
      return value;
    }
  };
  THREE.Spline = function(points) {
    this.points = points;
    var c = [],
        v3 = {
          x: 0,
          y: 0,
          z: 0
        },
        point,
        intPoint,
        weight,
        w2,
        w3,
        pa,
        pb,
        pc,
        pd;
    this.initFromArray = function(a) {
      this.points = [];
      for (var i = 0; i < a.length; i++) {
        this.points[i] = {
          x: a[i][0],
          y: a[i][1],
          z: a[i][2]
        };
      }
    };
    this.getPoint = function(k) {
      point = (this.points.length - 1) * k;
      intPoint = Math.floor(point);
      weight = point - intPoint;
      c[0] = intPoint === 0 ? intPoint : intPoint - 1;
      c[1] = intPoint;
      c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
      c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
      pa = this.points[c[0]];
      pb = this.points[c[1]];
      pc = this.points[c[2]];
      pd = this.points[c[3]];
      w2 = weight * weight;
      w3 = weight * w2;
      v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
      v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
      v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
      return v3;
    };
    this.getControlPointsArray = function() {
      var i,
          p,
          l = this.points.length,
          coords = [];
      for (i = 0; i < l; i++) {
        p = this.points[i];
        coords[i] = [p.x, p.y, p.z];
      }
      return coords;
    };
    this.getLength = function(nSubDivisions) {
      var i,
          index,
          nSamples,
          position,
          point = 0,
          intPoint = 0,
          oldIntPoint = 0,
          oldPosition = new THREE.Vector3(),
          tmpVec = new THREE.Vector3(),
          chunkLengths = [],
          totalLength = 0;
      chunkLengths[0] = 0;
      if (!nSubDivisions)
        nSubDivisions = 100;
      nSamples = this.points.length * nSubDivisions;
      oldPosition.copy(this.points[0]);
      for (i = 1; i < nSamples; i++) {
        index = i / nSamples;
        position = this.getPoint(index);
        tmpVec.copy(position);
        totalLength += tmpVec.distanceTo(oldPosition);
        oldPosition.copy(position);
        point = (this.points.length - 1) * index;
        intPoint = Math.floor(point);
        if (intPoint !== oldIntPoint) {
          chunkLengths[intPoint] = totalLength;
          oldIntPoint = intPoint;
        }
      }
      chunkLengths[chunkLengths.length] = totalLength;
      return {
        chunks: chunkLengths,
        total: totalLength
      };
    };
    this.reparametrizeByArcLength = function(samplingCoef) {
      var i,
          j,
          index,
          indexCurrent,
          indexNext,
          realDistance,
          sampling,
          position,
          newpoints = [],
          tmpVec = new THREE.Vector3(),
          sl = this.getLength();
      newpoints.push(tmpVec.copy(this.points[0]).clone());
      for (i = 1; i < this.points.length; i++) {
        realDistance = sl.chunks[i] - sl.chunks[i - 1];
        sampling = Math.ceil(samplingCoef * realDistance / sl.total);
        indexCurrent = (i - 1) / (this.points.length - 1);
        indexNext = i / (this.points.length - 1);
        for (j = 1; j < sampling - 1; j++) {
          index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
          position = this.getPoint(index);
          newpoints.push(tmpVec.copy(position).clone());
        }
        newpoints.push(tmpVec.copy(this.points[i]).clone());
      }
      this.points = newpoints;
    };
    function interpolate(p0, p1, p2, p3, t, t2, t3) {
      var v0 = (p2 - p0) * 0.5,
          v1 = (p3 - p1) * 0.5;
      return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
  };
  THREE.Triangle = function(a, b, c) {
    this.a = (a !== undefined) ? a : new THREE.Vector3();
    this.b = (b !== undefined) ? b : new THREE.Vector3();
    this.c = (c !== undefined) ? c : new THREE.Vector3();
  };
  THREE.Triangle.normal = function() {
    var v0 = new THREE.Vector3();
    return function(a, b, c, optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      result.subVectors(c, b);
      v0.subVectors(a, b);
      result.cross(v0);
      var resultLengthSq = result.lengthSq();
      if (resultLengthSq > 0) {
        return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
      }
      return result.set(0, 0, 0);
    };
  }();
  THREE.Triangle.barycoordFromPoint = function() {
    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    return function(point, a, b, c, optionalTarget) {
      v0.subVectors(c, a);
      v1.subVectors(b, a);
      v2.subVectors(point, a);
      var dot00 = v0.dot(v0);
      var dot01 = v0.dot(v1);
      var dot02 = v0.dot(v2);
      var dot11 = v1.dot(v1);
      var dot12 = v1.dot(v2);
      var denom = (dot00 * dot11 - dot01 * dot01);
      var result = optionalTarget || new THREE.Vector3();
      if (denom === 0) {
        return result.set(-2, -1, -1);
      }
      var invDenom = 1 / denom;
      var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return result.set(1 - u - v, v, u);
    };
  }();
  THREE.Triangle.containsPoint = function() {
    var v1 = new THREE.Vector3();
    return function(point, a, b, c) {
      var result = THREE.Triangle.barycoordFromPoint(point, a, b, c, v1);
      return (result.x >= 0) && (result.y >= 0) && ((result.x + result.y) <= 1);
    };
  }();
  THREE.Triangle.prototype = {
    constructor: THREE.Triangle,
    set: function(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    },
    setFromPointsAndIndices: function(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    },
    area: function() {
      var v0 = new THREE.Vector3();
      var v1 = new THREE.Vector3();
      return function() {
        v0.subVectors(this.c, this.b);
        v1.subVectors(this.a, this.b);
        return v0.cross(v1).length() * 0.5;
      };
    }(),
    midpoint: function(optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    normal: function(optionalTarget) {
      return THREE.Triangle.normal(this.a, this.b, this.c, optionalTarget);
    },
    plane: function(optionalTarget) {
      var result = optionalTarget || new THREE.Plane();
      return result.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    barycoordFromPoint: function(point, optionalTarget) {
      return THREE.Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
    },
    containsPoint: function(point) {
      return THREE.Triangle.containsPoint(point, this.a, this.b, this.c);
    },
    equals: function(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  };
  THREE.Channels = function() {
    this.mask = 1;
  };
  THREE.Channels.prototype = {
    constructor: THREE.Channels,
    set: function(channel) {
      this.mask = 1 << channel;
    },
    enable: function(channel) {
      this.mask |= 1 << channel;
    },
    toggle: function(channel) {
      this.mask ^= 1 << channel;
    },
    disable: function(channel) {
      this.mask &= ~(1 << channel);
    }
  };
  THREE.Clock = function(autoStart) {
    this.autoStart = (autoStart !== undefined) ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  };
  THREE.Clock.prototype = {
    constructor: THREE.Clock,
    start: function() {
      this.startTime = self.performance.now();
      this.oldTime = this.startTime;
      this.running = true;
    },
    stop: function() {
      this.getElapsedTime();
      this.running = false;
    },
    getElapsedTime: function() {
      this.getDelta();
      return this.elapsedTime;
    },
    getDelta: function() {
      var diff = 0;
      if (this.autoStart && !this.running) {
        this.start();
      }
      if (this.running) {
        var newTime = self.performance.now();
        diff = 0.001 * (newTime - this.oldTime);
        this.oldTime = newTime;
        this.elapsedTime += diff;
      }
      return diff;
    }
  };
  THREE.EventDispatcher = function() {};
  THREE.EventDispatcher.prototype = {
    constructor: THREE.EventDispatcher,
    apply: function(object) {
      object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
      object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
      object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
      object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
    },
    addEventListener: function(type, listener) {
      if (this._listeners === undefined)
        this._listeners = {};
      var listeners = this._listeners;
      if (listeners[type] === undefined) {
        listeners[type] = [];
      }
      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    },
    hasEventListener: function(type, listener) {
      if (this._listeners === undefined)
        return false;
      var listeners = this._listeners;
      if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
        return true;
      }
      return false;
    },
    removeEventListener: function(type, listener) {
      if (this._listeners === undefined)
        return;
      var listeners = this._listeners;
      var listenerArray = listeners[type];
      if (listenerArray !== undefined) {
        var index = listenerArray.indexOf(listener);
        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    },
    dispatchEvent: function(event) {
      if (this._listeners === undefined)
        return;
      var listeners = this._listeners;
      var listenerArray = listeners[event.type];
      if (listenerArray !== undefined) {
        event.target = this;
        var array = [];
        var length = listenerArray.length;
        for (var i = 0; i < length; i++) {
          array[i] = listenerArray[i];
        }
        for (var i = 0; i < length; i++) {
          array[i].call(this, event);
        }
      }
    }
  };
  (function(THREE) {
    THREE.Raycaster = function(origin, direction, near, far) {
      this.ray = new THREE.Ray(origin, direction);
      this.near = near || 0;
      this.far = far || Infinity;
      this.params = {
        Mesh: {},
        Line: {},
        LOD: {},
        Points: {threshold: 1},
        Sprite: {}
      };
      Object.defineProperties(this.params, {PointCloud: {get: function() {
            console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
            return this.Points;
          }}});
    };
    function descSort(a, b) {
      return a.distance - b.distance;
    }
    function intersectObject(object, raycaster, intersects, recursive) {
      if (object.visible === false)
        return;
      object.raycast(raycaster, intersects);
      if (recursive === true) {
        var children = object.children;
        for (var i = 0,
            l = children.length; i < l; i++) {
          intersectObject(children[i], raycaster, intersects, true);
        }
      }
    }
    THREE.Raycaster.prototype = {
      constructor: THREE.Raycaster,
      linePrecision: 1,
      set: function(origin, direction) {
        this.ray.set(origin, direction);
      },
      setFromCamera: function(coords, camera) {
        if (camera instanceof THREE.PerspectiveCamera) {
          this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
          this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
        } else if (camera instanceof THREE.OrthographicCamera) {
          this.ray.origin.set(coords.x, coords.y, -1).unproject(camera);
          this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
        } else {
          console.error('THREE.Raycaster: Unsupported camera type.');
        }
      },
      intersectObject: function(object, recursive) {
        var intersects = [];
        intersectObject(object, this, intersects, recursive);
        intersects.sort(descSort);
        return intersects;
      },
      intersectObjects: function(objects, recursive) {
        var intersects = [];
        if (Array.isArray(objects) === false) {
          console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
          return intersects;
        }
        for (var i = 0,
            l = objects.length; i < l; i++) {
          intersectObject(objects[i], this, intersects, recursive);
        }
        intersects.sort(descSort);
        return intersects;
      }
    };
  }(THREE));
  THREE.Object3D = function() {
    Object.defineProperty(this, 'id', {value: THREE.Object3DIdCount++});
    this.uuid = THREE.Math.generateUUID();
    this.name = '';
    this.type = 'Object3D';
    this.parent = null;
    this.channels = new THREE.Channels();
    this.children = [];
    this.up = THREE.Object3D.DefaultUp.clone();
    var position = new THREE.Vector3();
    var rotation = new THREE.Euler();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, undefined, false);
    }
    rotation.onChange(onRotationChange);
    quaternion.onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        enumerable: true,
        value: position
      },
      rotation: {
        enumerable: true,
        value: rotation
      },
      quaternion: {
        enumerable: true,
        value: quaternion
      },
      scale: {
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {value: new THREE.Matrix4()},
      normalMatrix: {value: new THREE.Matrix3()}
    });
    this.rotationAutoUpdate = true;
    this.matrix = new THREE.Matrix4();
    this.matrixWorld = new THREE.Matrix4();
    this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.userData = {};
  };
  THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
  THREE.Object3D.DefaultMatrixAutoUpdate = true;
  THREE.Object3D.prototype = {
    constructor: THREE.Object3D,
    get eulerOrder() {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      return this.rotation.order;
    },
    set eulerOrder(value) {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      this.rotation.order = value;
    },
    get useQuaternion() {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    },
    set useQuaternion(value) {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    },
    set renderDepth(value) {
      console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
    },
    applyMatrix: function(matrix) {
      this.matrix.multiplyMatrices(matrix, this.matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    setRotationFromAxisAngle: function(axis, angle) {
      this.quaternion.setFromAxisAngle(axis, angle);
    },
    setRotationFromEuler: function(euler) {
      this.quaternion.setFromEuler(euler, true);
    },
    setRotationFromMatrix: function(m) {
      this.quaternion.setFromRotationMatrix(m);
    },
    setRotationFromQuaternion: function(q) {
      this.quaternion.copy(q);
    },
    rotateOnAxis: function() {
      var q1 = new THREE.Quaternion();
      return function(axis, angle) {
        q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(q1);
        return this;
      };
    }(),
    rotateX: function() {
      var v1 = new THREE.Vector3(1, 0, 0);
      return function(angle) {
        return this.rotateOnAxis(v1, angle);
      };
    }(),
    rotateY: function() {
      var v1 = new THREE.Vector3(0, 1, 0);
      return function(angle) {
        return this.rotateOnAxis(v1, angle);
      };
    }(),
    rotateZ: function() {
      var v1 = new THREE.Vector3(0, 0, 1);
      return function(angle) {
        return this.rotateOnAxis(v1, angle);
      };
    }(),
    translateOnAxis: function() {
      var v1 = new THREE.Vector3();
      return function(axis, distance) {
        v1.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(v1.multiplyScalar(distance));
        return this;
      };
    }(),
    translate: function(distance, axis) {
      console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
      return this.translateOnAxis(axis, distance);
    },
    translateX: function() {
      var v1 = new THREE.Vector3(1, 0, 0);
      return function(distance) {
        return this.translateOnAxis(v1, distance);
      };
    }(),
    translateY: function() {
      var v1 = new THREE.Vector3(0, 1, 0);
      return function(distance) {
        return this.translateOnAxis(v1, distance);
      };
    }(),
    translateZ: function() {
      var v1 = new THREE.Vector3(0, 0, 1);
      return function(distance) {
        return this.translateOnAxis(v1, distance);
      };
    }(),
    localToWorld: function(vector) {
      return vector.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function() {
      var m1 = new THREE.Matrix4();
      return function(vector) {
        return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
      };
    }(),
    lookAt: function() {
      var m1 = new THREE.Matrix4();
      return function(vector) {
        m1.lookAt(vector, this.position, this.up);
        this.quaternion.setFromRotationMatrix(m1);
      };
    }(),
    add: function(object) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      if (object === this) {
        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
        return this;
      }
      if (object instanceof THREE.Object3D) {
        if (object.parent !== null) {
          object.parent.remove(object);
        }
        object.parent = this;
        object.dispatchEvent({type: 'added'});
        this.children.push(object);
      } else {
        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
      }
      return this;
    },
    remove: function(object) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.remove(arguments[i]);
        }
      }
      var index = this.children.indexOf(object);
      if (index !== -1) {
        object.parent = null;
        object.dispatchEvent({type: 'removed'});
        this.children.splice(index, 1);
      }
    },
    getChildByName: function(name) {
      console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
      return this.getObjectByName(name);
    },
    getObjectById: function(id) {
      return this.getObjectByProperty('id', id);
    },
    getObjectByName: function(name) {
      return this.getObjectByProperty('name', name);
    },
    getObjectByProperty: function(name, value) {
      if (this[name] === value)
        return this;
      for (var i = 0,
          l = this.children.length; i < l; i++) {
        var child = this.children[i];
        var object = child.getObjectByProperty(name, value);
        if (object !== undefined) {
          return object;
        }
      }
      return undefined;
    },
    getWorldPosition: function(optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      this.updateMatrixWorld(true);
      return result.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function() {
      var position = new THREE.Vector3();
      var scale = new THREE.Vector3();
      return function(optionalTarget) {
        var result = optionalTarget || new THREE.Quaternion();
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(position, result, scale);
        return result;
      };
    }(),
    getWorldRotation: function() {
      var quaternion = new THREE.Quaternion();
      return function(optionalTarget) {
        var result = optionalTarget || new THREE.Euler();
        this.getWorldQuaternion(quaternion);
        return result.setFromQuaternion(quaternion, this.rotation.order, false);
      };
    }(),
    getWorldScale: function() {
      var position = new THREE.Vector3();
      var quaternion = new THREE.Quaternion();
      return function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(position, quaternion, result);
        return result;
      };
    }(),
    getWorldDirection: function() {
      var quaternion = new THREE.Quaternion();
      return function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        this.getWorldQuaternion(quaternion);
        return result.set(0, 0, 1).applyQuaternion(quaternion);
      };
    }(),
    raycast: function() {},
    traverse: function(callback) {
      callback(this);
      var children = this.children;
      for (var i = 0,
          l = children.length; i < l; i++) {
        children[i].traverse(callback);
      }
    },
    traverseVisible: function(callback) {
      if (this.visible === false)
        return;
      callback(this);
      var children = this.children;
      for (var i = 0,
          l = children.length; i < l; i++) {
        children[i].traverseVisible(callback);
      }
    },
    traverseAncestors: function(callback) {
      var parent = this.parent;
      if (parent !== null) {
        callback(parent);
        parent.traverseAncestors(callback);
      }
    },
    updateMatrix: function() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function(force) {
      if (this.matrixAutoUpdate === true)
        this.updateMatrix();
      if (this.matrixWorldNeedsUpdate === true || force === true) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        this.matrixWorldNeedsUpdate = false;
        force = true;
      }
      for (var i = 0,
          l = this.children.length; i < l; i++) {
        this.children[i].updateMatrixWorld(force);
      }
    },
    toJSON: function(meta) {
      var isRootObject = (meta === undefined);
      var output = {};
      if (isRootObject) {
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {}
        };
        output.metadata = {
          version: 4.4,
          type: 'Object',
          generator: 'Object3D.toJSON'
        };
      }
      var object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== '')
        object.name = this.name;
      if (JSON.stringify(this.userData) !== '{}')
        object.userData = this.userData;
      if (this.castShadow === true)
        object.castShadow = true;
      if (this.receiveShadow === true)
        object.receiveShadow = true;
      if (this.visible === false)
        object.visible = false;
      object.matrix = this.matrix.toArray();
      if (this.geometry !== undefined) {
        if (meta.geometries[this.geometry.uuid] === undefined) {
          meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta);
        }
        object.geometry = this.geometry.uuid;
      }
      if (this.material !== undefined) {
        if (meta.materials[this.material.uuid] === undefined) {
          meta.materials[this.material.uuid] = this.material.toJSON(meta);
        }
        object.material = this.material.uuid;
      }
      if (this.children.length > 0) {
        object.children = [];
        for (var i = 0; i < this.children.length; i++) {
          object.children.push(this.children[i].toJSON(meta).object);
        }
      }
      if (isRootObject) {
        var geometries = extractFromCache(meta.geometries);
        var materials = extractFromCache(meta.materials);
        var textures = extractFromCache(meta.textures);
        var images = extractFromCache(meta.images);
        if (geometries.length > 0)
          output.geometries = geometries;
        if (materials.length > 0)
          output.materials = materials;
        if (textures.length > 0)
          output.textures = textures;
        if (images.length > 0)
          output.images = images;
      }
      output.object = object;
      return output;
      function extractFromCache(cache) {
        var values = [];
        for (var key in cache) {
          var data = cache[key];
          delete data.metadata;
          values.push(data);
        }
        return values;
      }
    },
    clone: function(recursive) {
      return new this.constructor().copy(this, recursive);
    },
    copy: function(source, recursive) {
      if (recursive === undefined)
        recursive = true;
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.rotationAutoUpdate = source.rotationAutoUpdate;
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      if (recursive === true) {
        for (var i = 0; i < source.children.length; i++) {
          var child = source.children[i];
          this.add(child.clone());
        }
      }
      return this;
    }
  };
  THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
  THREE.Object3DIdCount = 0;
  THREE.Face3 = function(a, b, c, normal, color, materialIndex) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
    this.vertexNormals = Array.isArray(normal) ? normal : [];
    this.color = color instanceof THREE.Color ? color : new THREE.Color();
    this.vertexColors = Array.isArray(color) ? color : [];
    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
  };
  THREE.Face3.prototype = {
    constructor: THREE.Face3,
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.a = source.a;
      this.b = source.b;
      this.c = source.c;
      this.normal.copy(source.normal);
      this.color.copy(source.color);
      this.materialIndex = source.materialIndex;
      for (var i = 0,
          il = source.vertexNormals.length; i < il; i++) {
        this.vertexNormals[i] = source.vertexNormals[i].clone();
      }
      for (var i = 0,
          il = source.vertexColors.length; i < il; i++) {
        this.vertexColors[i] = source.vertexColors[i].clone();
      }
      return this;
    }
  };
  THREE.Face4 = function(a, b, c, d, normal, color, materialIndex) {
    console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
    return new THREE.Face3(a, b, c, normal, color, materialIndex);
  };
  THREE.BufferAttribute = function(array, itemSize) {
    this.uuid = THREE.Math.generateUUID();
    this.array = array;
    this.itemSize = itemSize;
    this.dynamic = false;
    this.updateRange = {
      offset: 0,
      count: -1
    };
    this.version = 0;
  };
  THREE.BufferAttribute.prototype = {
    constructor: THREE.BufferAttribute,
    get length() {
      console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');
      return this.array.length;
    },
    get count() {
      return this.array.length / this.itemSize;
    },
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    },
    setDynamic: function(value) {
      this.dynamic = value;
      return this;
    },
    copy: function(source) {
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.dynamic = source.dynamic;
      return this;
    },
    copyAt: function(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;
      for (var i = 0,
          l = this.itemSize; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    },
    copyArray: function(array) {
      this.array.set(array);
      return this;
    },
    copyColorsArray: function(colors) {
      var array = this.array,
          offset = 0;
      for (var i = 0,
          l = colors.length; i < l; i++) {
        var color = colors[i];
        if (color === undefined) {
          console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
          color = new THREE.Color();
        }
        array[offset++] = color.r;
        array[offset++] = color.g;
        array[offset++] = color.b;
      }
      return this;
    },
    copyIndicesArray: function(indices) {
      var array = this.array,
          offset = 0;
      for (var i = 0,
          l = indices.length; i < l; i++) {
        var index = indices[i];
        array[offset++] = index.a;
        array[offset++] = index.b;
        array[offset++] = index.c;
      }
      return this;
    },
    copyVector2sArray: function(vectors) {
      var array = this.array,
          offset = 0;
      for (var i = 0,
          l = vectors.length; i < l; i++) {
        var vector = vectors[i];
        if (vector === undefined) {
          console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
          vector = new THREE.Vector2();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
      }
      return this;
    },
    copyVector3sArray: function(vectors) {
      var array = this.array,
          offset = 0;
      for (var i = 0,
          l = vectors.length; i < l; i++) {
        var vector = vectors[i];
        if (vector === undefined) {
          console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
          vector = new THREE.Vector3();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
      }
      return this;
    },
    copyVector4sArray: function(vectors) {
      var array = this.array,
          offset = 0;
      for (var i = 0,
          l = vectors.length; i < l; i++) {
        var vector = vectors[i];
        if (vector === undefined) {
          console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
          vector = new THREE.Vector4();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
        array[offset++] = vector.w;
      }
      return this;
    },
    set: function(value, offset) {
      if (offset === undefined)
        offset = 0;
      this.array.set(value, offset);
      return this;
    },
    getX: function(index) {
      return this.array[index * this.itemSize];
    },
    setX: function(index, x) {
      this.array[index * this.itemSize] = x;
      return this;
    },
    getY: function(index) {
      return this.array[index * this.itemSize + 1];
    },
    setY: function(index, y) {
      this.array[index * this.itemSize + 1] = y;
      return this;
    },
    getZ: function(index) {
      return this.array[index * this.itemSize + 2];
    },
    setZ: function(index, z) {
      this.array[index * this.itemSize + 2] = z;
      return this;
    },
    getW: function(index) {
      return this.array[index * this.itemSize + 3];
    },
    setW: function(index, w) {
      this.array[index * this.itemSize + 3] = w;
      return this;
    },
    setXY: function(index, x, y) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      return this;
    },
    setXYZ: function(index, x, y, z) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      return this;
    },
    setXYZW: function(index, x, y, z, w) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      this.array[index + 3] = w;
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  };
  THREE.Int8Attribute = function(array, itemSize) {
    return new THREE.BufferAttribute(new Int8Array(array), itemSize);
  };
  THREE.Uint8Attribute = function(array, itemSize) {
    return new THREE.BufferAttribute(new Uint8Array(array), itemSize);
  };
  THREE.Uint8ClampedAttribute = function(array, itemSize) {
    return new THREE.BufferAttribute(new Uint8ClampedArray(array), itemSize);
  };
  THREE.Int16Attribute = function(array, itemSize) {
    return new THREE.BufferAttribute(new Int16Array(array), itemSize);
  };
  THREE.Uint16Attribute = function(array, itemSize) {
    return new THREE.BufferAttribute(new Uint16Array(array), itemSize);
  };
  THREE.Int32Attribute = function(array, itemSize) {
    return new THREE.BufferAttribute(new Int32Array(array), itemSize);
  };
  THREE.Uint32Attribute = function(array, itemSize) {
    return new THREE.BufferAttribute(new Uint32Array(array), itemSize);
  };
  THREE.Float32Attribute = function(array, itemSize) {
    return new THREE.BufferAttribute(new Float32Array(array), itemSize);
  };
  THREE.Float64Attribute = function(array, itemSize) {
    return new THREE.BufferAttribute(new Float64Array(array), itemSize);
  };
  THREE.DynamicBufferAttribute = function(array, itemSize) {
    console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
    return new THREE.BufferAttribute(array, itemSize).setDynamic(true);
  };
  THREE.InstancedBufferAttribute = function(array, itemSize, meshPerAttribute) {
    THREE.BufferAttribute.call(this, array, itemSize);
    this.meshPerAttribute = meshPerAttribute || 1;
  };
  THREE.InstancedBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);
  THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;
  THREE.InstancedBufferAttribute.prototype.copy = function(source) {
    THREE.BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  };
  THREE.InterleavedBuffer = function(array, stride) {
    this.uuid = THREE.Math.generateUUID();
    this.array = array;
    this.stride = stride;
    this.dynamic = false;
    this.updateRange = {
      offset: 0,
      count: -1
    };
    this.version = 0;
  };
  THREE.InterleavedBuffer.prototype = {
    constructor: THREE.InterleavedBuffer,
    get length() {
      return this.array.length;
    },
    get count() {
      return this.array.length / this.stride;
    },
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    },
    setDynamic: function(value) {
      this.dynamic = value;
      return this;
    },
    copy: function(source) {
      this.array = new source.array.constructor(source.array);
      this.stride = source.stride;
      this.dynamic = source.dynamic;
    },
    copyAt: function(index1, attribute, index2) {
      index1 *= this.stride;
      index2 *= attribute.stride;
      for (var i = 0,
          l = this.stride; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    },
    set: function(value, offset) {
      if (offset === undefined)
        offset = 0;
      this.array.set(value, offset);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  };
  THREE.InstancedInterleavedBuffer = function(array, stride, meshPerAttribute) {
    THREE.InterleavedBuffer.call(this, array, stride);
    this.meshPerAttribute = meshPerAttribute || 1;
  };
  THREE.InstancedInterleavedBuffer.prototype = Object.create(THREE.InterleavedBuffer.prototype);
  THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;
  THREE.InstancedInterleavedBuffer.prototype.copy = function(source) {
    THREE.InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  };
  THREE.InterleavedBufferAttribute = function(interleavedBuffer, itemSize, offset) {
    this.uuid = THREE.Math.generateUUID();
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
  };
  THREE.InterleavedBufferAttribute.prototype = {
    constructor: THREE.InterleavedBufferAttribute,
    get length() {
      console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');
      return this.array.length;
    },
    get count() {
      return this.data.array.length / this.data.stride;
    },
    setX: function(index, x) {
      this.data.array[index * this.data.stride + this.offset] = x;
      return this;
    },
    setY: function(index, y) {
      this.data.array[index * this.data.stride + this.offset + 1] = y;
      return this;
    },
    setZ: function(index, z) {
      this.data.array[index * this.data.stride + this.offset + 2] = z;
      return this;
    },
    setW: function(index, w) {
      this.data.array[index * this.data.stride + this.offset + 3] = w;
      return this;
    },
    getX: function(index) {
      return this.data.array[index * this.data.stride + this.offset];
    },
    getY: function(index) {
      return this.data.array[index * this.data.stride + this.offset + 1];
    },
    getZ: function(index) {
      return this.data.array[index * this.data.stride + this.offset + 2];
    },
    getW: function(index) {
      return this.data.array[index * this.data.stride + this.offset + 3];
    },
    setXY: function(index, x, y) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      return this;
    },
    setXYZ: function(index, x, y, z) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      return this;
    },
    setXYZW: function(index, x, y, z, w) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      this.data.array[index + 3] = w;
      return this;
    }
  };
  THREE.Geometry = function() {
    Object.defineProperty(this, 'id', {value: THREE.GeometryIdCount++});
    this.uuid = THREE.Math.generateUUID();
    this.name = '';
    this.type = 'Geometry';
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.verticesNeedUpdate = false;
    this.elementsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
  };
  THREE.Geometry.prototype = {
    constructor: THREE.Geometry,
    applyMatrix: function(matrix) {
      var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
      for (var i = 0,
          il = this.vertices.length; i < il; i++) {
        var vertex = this.vertices[i];
        vertex.applyMatrix4(matrix);
      }
      for (var i = 0,
          il = this.faces.length; i < il; i++) {
        var face = this.faces[i];
        face.normal.applyMatrix3(normalMatrix).normalize();
        for (var j = 0,
            jl = face.vertexNormals.length; j < jl; j++) {
          face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
        }
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      this.verticesNeedUpdate = true;
      this.normalsNeedUpdate = true;
    },
    rotateX: function() {
      var m1;
      return function rotateX(angle) {
        if (m1 === undefined)
          m1 = new THREE.Matrix4();
        m1.makeRotationX(angle);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    rotateY: function() {
      var m1;
      return function rotateY(angle) {
        if (m1 === undefined)
          m1 = new THREE.Matrix4();
        m1.makeRotationY(angle);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    rotateZ: function() {
      var m1;
      return function rotateZ(angle) {
        if (m1 === undefined)
          m1 = new THREE.Matrix4();
        m1.makeRotationZ(angle);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    translate: function() {
      var m1;
      return function translate(x, y, z) {
        if (m1 === undefined)
          m1 = new THREE.Matrix4();
        m1.makeTranslation(x, y, z);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    scale: function() {
      var m1;
      return function scale(x, y, z) {
        if (m1 === undefined)
          m1 = new THREE.Matrix4();
        m1.makeScale(x, y, z);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    lookAt: function() {
      var obj;
      return function lookAt(vector) {
        if (obj === undefined)
          obj = new THREE.Object3D();
        obj.lookAt(vector);
        obj.updateMatrix();
        this.applyMatrix(obj.matrix);
      };
    }(),
    fromBufferGeometry: function(geometry) {
      var scope = this;
      var indices = geometry.index !== null ? geometry.index.array : undefined;
      var attributes = geometry.attributes;
      var vertices = attributes.position.array;
      var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
      var colors = attributes.color !== undefined ? attributes.color.array : undefined;
      var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
      var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
      if (uvs2 !== undefined)
        this.faceVertexUvs[1] = [];
      var tempNormals = [];
      var tempUVs = [];
      var tempUVs2 = [];
      for (var i = 0,
          j = 0,
          k = 0; i < vertices.length; i += 3, j += 2, k += 4) {
        scope.vertices.push(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
        if (normals !== undefined) {
          tempNormals.push(new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]));
        }
        if (colors !== undefined) {
          scope.colors.push(new THREE.Color(colors[i], colors[i + 1], colors[i + 2]));
        }
        if (uvs !== undefined) {
          tempUVs.push(new THREE.Vector2(uvs[j], uvs[j + 1]));
        }
        if (uvs2 !== undefined) {
          tempUVs2.push(new THREE.Vector2(uvs2[j], uvs2[j + 1]));
        }
      }
      function addFace(a, b, c) {
        var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
        var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
        var face = new THREE.Face3(a, b, c, vertexNormals, vertexColors);
        scope.faces.push(face);
        if (uvs !== undefined) {
          scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
        }
        if (uvs2 !== undefined) {
          scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);
        }
      }
      ;
      if (indices !== undefined) {
        var groups = geometry.groups;
        if (groups.length > 0) {
          for (var i = 0; i < groups.length; i++) {
            var group = groups[i];
            var start = group.start;
            var count = group.count;
            for (var j = start,
                jl = start + count; j < jl; j += 3) {
              addFace(indices[j], indices[j + 1], indices[j + 2]);
            }
          }
        } else {
          for (var i = 0; i < indices.length; i += 3) {
            addFace(indices[i], indices[i + 1], indices[i + 2]);
          }
        }
      } else {
        for (var i = 0; i < vertices.length / 3; i += 3) {
          addFace(i, i + 1, i + 2);
        }
      }
      this.computeFaceNormals();
      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }
      return this;
    },
    center: function() {
      this.computeBoundingBox();
      var offset = this.boundingBox.center().negate();
      this.translate(offset.x, offset.y, offset.z);
      return offset;
    },
    normalize: function() {
      this.computeBoundingSphere();
      var center = this.boundingSphere.center;
      var radius = this.boundingSphere.radius;
      var s = radius === 0 ? 1 : 1.0 / radius;
      var matrix = new THREE.Matrix4();
      matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
      this.applyMatrix(matrix);
      return this;
    },
    computeFaceNormals: function() {
      var cb = new THREE.Vector3(),
          ab = new THREE.Vector3();
      for (var f = 0,
          fl = this.faces.length; f < fl; f++) {
        var face = this.faces[f];
        var vA = this.vertices[face.a];
        var vB = this.vertices[face.b];
        var vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        cb.normalize();
        face.normal.copy(cb);
      }
    },
    computeVertexNormals: function(areaWeighted) {
      var v,
          vl,
          f,
          fl,
          face,
          vertices;
      vertices = new Array(this.vertices.length);
      for (v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v] = new THREE.Vector3();
      }
      if (areaWeighted) {
        var vA,
            vB,
            vC;
        var cb = new THREE.Vector3(),
            ab = new THREE.Vector3();
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          vA = this.vertices[face.a];
          vB = this.vertices[face.b];
          vC = this.vertices[face.c];
          cb.subVectors(vC, vB);
          ab.subVectors(vA, vB);
          cb.cross(ab);
          vertices[face.a].add(cb);
          vertices[face.b].add(cb);
          vertices[face.c].add(cb);
        }
      } else {
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          vertices[face.a].add(face.normal);
          vertices[face.b].add(face.normal);
          vertices[face.c].add(face.normal);
        }
      }
      for (v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v].normalize();
      }
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        var vertexNormals = face.vertexNormals;
        if (vertexNormals.length === 3) {
          vertexNormals[0].copy(vertices[face.a]);
          vertexNormals[1].copy(vertices[face.b]);
          vertexNormals[2].copy(vertices[face.c]);
        } else {
          vertexNormals[0] = vertices[face.a].clone();
          vertexNormals[1] = vertices[face.b].clone();
          vertexNormals[2] = vertices[face.c].clone();
        }
      }
    },
    computeMorphNormals: function() {
      var i,
          il,
          f,
          fl,
          face;
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        if (!face.__originalFaceNormal) {
          face.__originalFaceNormal = face.normal.clone();
        } else {
          face.__originalFaceNormal.copy(face.normal);
        }
        if (!face.__originalVertexNormals)
          face.__originalVertexNormals = [];
        for (i = 0, il = face.vertexNormals.length; i < il; i++) {
          if (!face.__originalVertexNormals[i]) {
            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
          } else {
            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
          }
        }
      }
      var tmpGeo = new THREE.Geometry();
      tmpGeo.faces = this.faces;
      for (i = 0, il = this.morphTargets.length; i < il; i++) {
        if (!this.morphNormals[i]) {
          this.morphNormals[i] = {};
          this.morphNormals[i].faceNormals = [];
          this.morphNormals[i].vertexNormals = [];
          var dstNormalsFace = this.morphNormals[i].faceNormals;
          var dstNormalsVertex = this.morphNormals[i].vertexNormals;
          var faceNormal,
              vertexNormals;
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            faceNormal = new THREE.Vector3();
            vertexNormals = {
              a: new THREE.Vector3(),
              b: new THREE.Vector3(),
              c: new THREE.Vector3()
            };
            dstNormalsFace.push(faceNormal);
            dstNormalsVertex.push(vertexNormals);
          }
        }
        var morphNormals = this.morphNormals[i];
        tmpGeo.vertices = this.morphTargets[i].vertices;
        tmpGeo.computeFaceNormals();
        tmpGeo.computeVertexNormals();
        var faceNormal,
            vertexNormals;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          faceNormal = morphNormals.faceNormals[f];
          vertexNormals = morphNormals.vertexNormals[f];
          faceNormal.copy(face.normal);
          vertexNormals.a.copy(face.vertexNormals[0]);
          vertexNormals.b.copy(face.vertexNormals[1]);
          vertexNormals.c.copy(face.vertexNormals[2]);
        }
      }
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        face.normal = face.__originalFaceNormal;
        face.vertexNormals = face.__originalVertexNormals;
      }
    },
    computeTangents: function() {
      console.warn('THREE.Geometry: .computeTangents() has been removed.');
    },
    computeLineDistances: function() {
      var d = 0;
      var vertices = this.vertices;
      for (var i = 0,
          il = vertices.length; i < il; i++) {
        if (i > 0) {
          d += vertices[i].distanceTo(vertices[i - 1]);
        }
        this.lineDistances[i] = d;
      }
    },
    computeBoundingBox: function() {
      if (this.boundingBox === null) {
        this.boundingBox = new THREE.Box3();
      }
      this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new THREE.Sphere();
      }
      this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(geometry, matrix, materialIndexOffset) {
      if (geometry instanceof THREE.Geometry === false) {
        console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
        return;
      }
      var normalMatrix,
          vertexOffset = this.vertices.length,
          vertices1 = this.vertices,
          vertices2 = geometry.vertices,
          faces1 = this.faces,
          faces2 = geometry.faces,
          uvs1 = this.faceVertexUvs[0],
          uvs2 = geometry.faceVertexUvs[0];
      if (materialIndexOffset === undefined)
        materialIndexOffset = 0;
      if (matrix !== undefined) {
        normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
      }
      for (var i = 0,
          il = vertices2.length; i < il; i++) {
        var vertex = vertices2[i];
        var vertexCopy = vertex.clone();
        if (matrix !== undefined)
          vertexCopy.applyMatrix4(matrix);
        vertices1.push(vertexCopy);
      }
      for (i = 0, il = faces2.length; i < il; i++) {
        var face = faces2[i],
            faceCopy,
            normal,
            color,
            faceVertexNormals = face.vertexNormals,
            faceVertexColors = face.vertexColors;
        faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
        faceCopy.normal.copy(face.normal);
        if (normalMatrix !== undefined) {
          faceCopy.normal.applyMatrix3(normalMatrix).normalize();
        }
        for (var j = 0,
            jl = faceVertexNormals.length; j < jl; j++) {
          normal = faceVertexNormals[j].clone();
          if (normalMatrix !== undefined) {
            normal.applyMatrix3(normalMatrix).normalize();
          }
          faceCopy.vertexNormals.push(normal);
        }
        faceCopy.color.copy(face.color);
        for (var j = 0,
            jl = faceVertexColors.length; j < jl; j++) {
          color = faceVertexColors[j];
          faceCopy.vertexColors.push(color.clone());
        }
        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
        faces1.push(faceCopy);
      }
      for (i = 0, il = uvs2.length; i < il; i++) {
        var uv = uvs2[i],
            uvCopy = [];
        if (uv === undefined) {
          continue;
        }
        for (var j = 0,
            jl = uv.length; j < jl; j++) {
          uvCopy.push(uv[j].clone());
        }
        uvs1.push(uvCopy);
      }
    },
    mergeMesh: function(mesh) {
      if (mesh instanceof THREE.Mesh === false) {
        console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
        return;
      }
      mesh.matrixAutoUpdate && mesh.updateMatrix();
      this.merge(mesh.geometry, mesh.matrix);
    },
    mergeVertices: function() {
      var verticesMap = {};
      var unique = [],
          changes = [];
      var v,
          key;
      var precisionPoints = 4;
      var precision = Math.pow(10, precisionPoints);
      var i,
          il,
          face;
      var indices,
          j,
          jl;
      for (i = 0, il = this.vertices.length; i < il; i++) {
        v = this.vertices[i];
        key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
        if (verticesMap[key] === undefined) {
          verticesMap[key] = i;
          unique.push(this.vertices[i]);
          changes[i] = unique.length - 1;
        } else {
          changes[i] = changes[verticesMap[key]];
        }
      }
      var faceIndicesToRemove = [];
      for (i = 0, il = this.faces.length; i < il; i++) {
        face = this.faces[i];
        face.a = changes[face.a];
        face.b = changes[face.b];
        face.c = changes[face.c];
        indices = [face.a, face.b, face.c];
        var dupIndex = -1;
        for (var n = 0; n < 3; n++) {
          if (indices[n] === indices[(n + 1) % 3]) {
            dupIndex = n;
            faceIndicesToRemove.push(i);
            break;
          }
        }
      }
      for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
        var idx = faceIndicesToRemove[i];
        this.faces.splice(idx, 1);
        for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
          this.faceVertexUvs[j].splice(idx, 1);
        }
      }
      var diff = this.vertices.length - unique.length;
      this.vertices = unique;
      return diff;
    },
    sortFacesByMaterialIndex: function() {
      var faces = this.faces;
      var length = faces.length;
      for (var i = 0; i < length; i++) {
        faces[i]._id = i;
      }
      function materialIndexSort(a, b) {
        return a.materialIndex - b.materialIndex;
      }
      faces.sort(materialIndexSort);
      var uvs1 = this.faceVertexUvs[0];
      var uvs2 = this.faceVertexUvs[1];
      var newUvs1,
          newUvs2;
      if (uvs1 && uvs1.length === length)
        newUvs1 = [];
      if (uvs2 && uvs2.length === length)
        newUvs2 = [];
      for (var i = 0; i < length; i++) {
        var id = faces[i]._id;
        if (newUvs1)
          newUvs1.push(uvs1[id]);
        if (newUvs2)
          newUvs2.push(uvs2[id]);
      }
      if (newUvs1)
        this.faceVertexUvs[0] = newUvs1;
      if (newUvs2)
        this.faceVertexUvs[1] = newUvs2;
    },
    toJSON: function() {
      var data = {metadata: {
          version: 4.4,
          type: 'Geometry',
          generator: 'Geometry.toJSON'
        }};
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== '')
        data.name = this.name;
      if (this.parameters !== undefined) {
        var parameters = this.parameters;
        for (var key in parameters) {
          if (parameters[key] !== undefined)
            data[key] = parameters[key];
        }
        return data;
      }
      var vertices = [];
      for (var i = 0; i < this.vertices.length; i++) {
        var vertex = this.vertices[i];
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
      var faces = [];
      var normals = [];
      var normalsHash = {};
      var colors = [];
      var colorsHash = {};
      var uvs = [];
      var uvsHash = {};
      for (var i = 0; i < this.faces.length; i++) {
        var face = this.faces[i];
        var hasMaterial = false;
        var hasFaceUv = false;
        var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
        var hasFaceNormal = face.normal.length() > 0;
        var hasFaceVertexNormal = face.vertexNormals.length > 0;
        var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
        var hasFaceVertexColor = face.vertexColors.length > 0;
        var faceType = 0;
        faceType = setBit(faceType, 0, 0);
        faceType = setBit(faceType, 1, hasMaterial);
        faceType = setBit(faceType, 2, hasFaceUv);
        faceType = setBit(faceType, 3, hasFaceVertexUv);
        faceType = setBit(faceType, 4, hasFaceNormal);
        faceType = setBit(faceType, 5, hasFaceVertexNormal);
        faceType = setBit(faceType, 6, hasFaceColor);
        faceType = setBit(faceType, 7, hasFaceVertexColor);
        faces.push(faceType);
        faces.push(face.a, face.b, face.c);
        if (hasFaceVertexUv) {
          var faceVertexUvs = this.faceVertexUvs[0][i];
          faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
        }
        if (hasFaceNormal) {
          faces.push(getNormalIndex(face.normal));
        }
        if (hasFaceVertexNormal) {
          var vertexNormals = face.vertexNormals;
          faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
        }
        if (hasFaceColor) {
          faces.push(getColorIndex(face.color));
        }
        if (hasFaceVertexColor) {
          var vertexColors = face.vertexColors;
          faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
        }
      }
      function setBit(value, position, enabled) {
        return enabled ? value | (1 << position) : value & (~(1 << position));
      }
      function getNormalIndex(normal) {
        var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
        if (normalsHash[hash] !== undefined) {
          return normalsHash[hash];
        }
        normalsHash[hash] = normals.length / 3;
        normals.push(normal.x, normal.y, normal.z);
        return normalsHash[hash];
      }
      function getColorIndex(color) {
        var hash = color.r.toString() + color.g.toString() + color.b.toString();
        if (colorsHash[hash] !== undefined) {
          return colorsHash[hash];
        }
        colorsHash[hash] = colors.length;
        colors.push(color.getHex());
        return colorsHash[hash];
      }
      function getUvIndex(uv) {
        var hash = uv.x.toString() + uv.y.toString();
        if (uvsHash[hash] !== undefined) {
          return uvsHash[hash];
        }
        uvsHash[hash] = uvs.length / 2;
        uvs.push(uv.x, uv.y);
        return uvsHash[hash];
      }
      data.data = {};
      data.data.vertices = vertices;
      data.data.normals = normals;
      if (colors.length > 0)
        data.data.colors = colors;
      if (uvs.length > 0)
        data.data.uvs = [uvs];
      data.data.faces = faces;
      return data;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.vertices = [];
      this.faces = [];
      this.faceVertexUvs = [[]];
      var vertices = source.vertices;
      for (var i = 0,
          il = vertices.length; i < il; i++) {
        this.vertices.push(vertices[i].clone());
      }
      var faces = source.faces;
      for (var i = 0,
          il = faces.length; i < il; i++) {
        this.faces.push(faces[i].clone());
      }
      for (var i = 0,
          il = source.faceVertexUvs.length; i < il; i++) {
        var faceVertexUvs = source.faceVertexUvs[i];
        if (this.faceVertexUvs[i] === undefined) {
          this.faceVertexUvs[i] = [];
        }
        for (var j = 0,
            jl = faceVertexUvs.length; j < jl; j++) {
          var uvs = faceVertexUvs[j],
              uvsCopy = [];
          for (var k = 0,
              kl = uvs.length; k < kl; k++) {
            var uv = uvs[k];
            uvsCopy.push(uv.clone());
          }
          this.faceVertexUvs[i].push(uvsCopy);
        }
      }
      return this;
    },
    dispose: function() {
      this.dispatchEvent({type: 'dispose'});
    }
  };
  THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
  THREE.GeometryIdCount = 0;
  THREE.DirectGeometry = function() {
    Object.defineProperty(this, 'id', {value: THREE.GeometryIdCount++});
    this.uuid = THREE.Math.generateUUID();
    this.name = '';
    this.type = 'DirectGeometry';
    this.indices = [];
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;
  };
  THREE.DirectGeometry.prototype = {
    constructor: THREE.DirectGeometry,
    computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
    computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
    computeFaceNormals: function() {
      console.warn('THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.');
    },
    computeVertexNormals: function() {
      console.warn('THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.');
    },
    computeGroups: function(geometry) {
      var group;
      var groups = [];
      var materialIndex;
      var faces = geometry.faces;
      for (var i = 0; i < faces.length; i++) {
        var face = faces[i];
        if (face.materialIndex !== materialIndex) {
          materialIndex = face.materialIndex;
          if (group !== undefined) {
            group.count = (i * 3) - group.start;
            groups.push(group);
          }
          group = {
            start: i * 3,
            materialIndex: materialIndex
          };
        }
      }
      if (group !== undefined) {
        group.count = (i * 3) - group.start;
        groups.push(group);
      }
      this.groups = groups;
    },
    fromGeometry: function(geometry) {
      var faces = geometry.faces;
      var vertices = geometry.vertices;
      var faceVertexUvs = geometry.faceVertexUvs;
      var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
      var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
      var morphTargets = geometry.morphTargets;
      var morphTargetsLength = morphTargets.length;
      if (morphTargetsLength > 0) {
        var morphTargetsPosition = [];
        for (var i = 0; i < morphTargetsLength; i++) {
          morphTargetsPosition[i] = [];
        }
        this.morphTargets.position = morphTargetsPosition;
      }
      var morphNormals = geometry.morphNormals;
      var morphNormalsLength = morphNormals.length;
      if (morphNormalsLength > 0) {
        var morphTargetsNormal = [];
        for (var i = 0; i < morphNormalsLength; i++) {
          morphTargetsNormal[i] = [];
        }
        this.morphTargets.normal = morphTargetsNormal;
      }
      var skinIndices = geometry.skinIndices;
      var skinWeights = geometry.skinWeights;
      var hasSkinIndices = skinIndices.length === vertices.length;
      var hasSkinWeights = skinWeights.length === vertices.length;
      for (var i = 0; i < faces.length; i++) {
        var face = faces[i];
        this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
        var vertexNormals = face.vertexNormals;
        if (vertexNormals.length === 3) {
          this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
        } else {
          var normal = face.normal;
          this.normals.push(normal, normal, normal);
        }
        var vertexColors = face.vertexColors;
        if (vertexColors.length === 3) {
          this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
        } else {
          var color = face.color;
          this.colors.push(color, color, color);
        }
        if (hasFaceVertexUv === true) {
          var vertexUvs = faceVertexUvs[0][i];
          if (vertexUvs !== undefined) {
            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
          } else {
            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
            this.uvs.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
          }
        }
        if (hasFaceVertexUv2 === true) {
          var vertexUvs = faceVertexUvs[1][i];
          if (vertexUvs !== undefined) {
            this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
          } else {
            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
            this.uvs2.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
          }
        }
        for (var j = 0; j < morphTargetsLength; j++) {
          var morphTarget = morphTargets[j].vertices;
          morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
        }
        for (var j = 0; j < morphNormalsLength; j++) {
          var morphNormal = morphNormals[j].vertexNormals[i];
          morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
        }
        if (hasSkinIndices) {
          this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
        }
        if (hasSkinWeights) {
          this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
        }
      }
      this.computeGroups(geometry);
      this.verticesNeedUpdate = geometry.verticesNeedUpdate;
      this.normalsNeedUpdate = geometry.normalsNeedUpdate;
      this.colorsNeedUpdate = geometry.colorsNeedUpdate;
      this.uvsNeedUpdate = geometry.uvsNeedUpdate;
      this.groupsNeedUpdate = geometry.groupsNeedUpdate;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({type: 'dispose'});
    }
  };
  THREE.EventDispatcher.prototype.apply(THREE.DirectGeometry.prototype);
  THREE.BufferGeometry = function() {
    Object.defineProperty(this, 'id', {value: THREE.GeometryIdCount++});
    this.uuid = THREE.Math.generateUUID();
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
      start: 0,
      count: Infinity
    };
  };
  THREE.BufferGeometry.prototype = {
    constructor: THREE.BufferGeometry,
    addIndex: function(index) {
      console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
      this.setIndex(index);
    },
    getIndex: function() {
      return this.index;
    },
    setIndex: function(index) {
      this.index = index;
    },
    addAttribute: function(name, attribute) {
      if (attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false) {
        console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
        this.addAttribute(name, new THREE.BufferAttribute(arguments[1], arguments[2]));
        return;
      }
      if (name === 'index') {
        console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
        this.setIndex(attribute);
        return;
      }
      this.attributes[name] = attribute;
    },
    getAttribute: function(name) {
      return this.attributes[name];
    },
    removeAttribute: function(name) {
      delete this.attributes[name];
    },
    get drawcalls() {
      console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
      return this.groups;
    },
    get offsets() {
      console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
      return this.groups;
    },
    addDrawCall: function(start, count, indexOffset) {
      if (indexOffset !== undefined) {
        console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
      }
      console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
      this.addGroup(start, count);
    },
    clearDrawCalls: function() {
      console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
      this.clearGroups();
    },
    addGroup: function(start, count, materialIndex) {
      this.groups.push({
        start: start,
        count: count,
        materialIndex: materialIndex !== undefined ? materialIndex : 0
      });
    },
    clearGroups: function() {
      this.groups = [];
    },
    setDrawRange: function(start, count) {
      this.drawRange.start = start;
      this.drawRange.count = count;
    },
    applyMatrix: function(matrix) {
      var position = this.attributes.position;
      if (position !== undefined) {
        matrix.applyToVector3Array(position.array);
        position.needsUpdate = true;
      }
      var normal = this.attributes.normal;
      if (normal !== undefined) {
        var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
        normalMatrix.applyToVector3Array(normal.array);
        normal.needsUpdate = true;
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
    },
    rotateX: function() {
      var m1;
      return function rotateX(angle) {
        if (m1 === undefined)
          m1 = new THREE.Matrix4();
        m1.makeRotationX(angle);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    rotateY: function() {
      var m1;
      return function rotateY(angle) {
        if (m1 === undefined)
          m1 = new THREE.Matrix4();
        m1.makeRotationY(angle);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    rotateZ: function() {
      var m1;
      return function rotateZ(angle) {
        if (m1 === undefined)
          m1 = new THREE.Matrix4();
        m1.makeRotationZ(angle);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    translate: function() {
      var m1;
      return function translate(x, y, z) {
        if (m1 === undefined)
          m1 = new THREE.Matrix4();
        m1.makeTranslation(x, y, z);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    scale: function() {
      var m1;
      return function scale(x, y, z) {
        if (m1 === undefined)
          m1 = new THREE.Matrix4();
        m1.makeScale(x, y, z);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    lookAt: function() {
      var obj;
      return function lookAt(vector) {
        if (obj === undefined)
          obj = new THREE.Object3D();
        obj.lookAt(vector);
        obj.updateMatrix();
        this.applyMatrix(obj.matrix);
      };
    }(),
    center: function() {
      this.computeBoundingBox();
      var offset = this.boundingBox.center().negate();
      this.translate(offset.x, offset.y, offset.z);
      return offset;
    },
    setFromObject: function(object) {
      var geometry = object.geometry;
      if (object instanceof THREE.Points || object instanceof THREE.Line) {
        var positions = new THREE.Float32Attribute(geometry.vertices.length * 3, 3);
        var colors = new THREE.Float32Attribute(geometry.colors.length * 3, 3);
        this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
        this.addAttribute('color', colors.copyColorsArray(geometry.colors));
        if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
          var lineDistances = new THREE.Float32Attribute(geometry.lineDistances.length, 1);
          this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
        }
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
      } else if (object instanceof THREE.Mesh) {
        if (geometry instanceof THREE.Geometry) {
          this.fromGeometry(geometry);
        }
      }
      return this;
    },
    updateFromObject: function(object) {
      var geometry = object.geometry;
      if (object instanceof THREE.Mesh) {
        var direct = geometry.__directGeometry;
        if (direct === undefined) {
          return this.fromGeometry(geometry);
        }
        direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
        direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
        direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
        direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
        direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
        geometry.verticesNeedUpdate = false;
        geometry.normalsNeedUpdate = false;
        geometry.colorsNeedUpdate = false;
        geometry.uvsNeedUpdate = false;
        geometry.groupsNeedUpdate = false;
        geometry = direct;
      }
      if (geometry.verticesNeedUpdate === true) {
        var attribute = this.attributes.position;
        if (attribute !== undefined) {
          attribute.copyVector3sArray(geometry.vertices);
          attribute.needsUpdate = true;
        }
        geometry.verticesNeedUpdate = false;
      }
      if (geometry.normalsNeedUpdate === true) {
        var attribute = this.attributes.normal;
        if (attribute !== undefined) {
          attribute.copyVector3sArray(geometry.normals);
          attribute.needsUpdate = true;
        }
        geometry.normalsNeedUpdate = false;
      }
      if (geometry.colorsNeedUpdate === true) {
        var attribute = this.attributes.color;
        if (attribute !== undefined) {
          attribute.copyColorsArray(geometry.colors);
          attribute.needsUpdate = true;
        }
        geometry.colorsNeedUpdate = false;
      }
      if (geometry.uvsNeedUpdate) {
        var attribute = this.attributes.uv;
        if (attribute !== undefined) {
          attribute.copyVector2sArray(geometry.uvs);
          attribute.needsUpdate = true;
        }
        geometry.uvsNeedUpdate = false;
      }
      if (geometry.lineDistancesNeedUpdate) {
        var attribute = this.attributes.lineDistance;
        if (attribute !== undefined) {
          attribute.copyArray(geometry.lineDistances);
          attribute.needsUpdate = true;
        }
        geometry.lineDistancesNeedUpdate = false;
      }
      if (geometry.groupsNeedUpdate) {
        geometry.computeGroups(object.geometry);
        this.groups = geometry.groups;
        geometry.groupsNeedUpdate = false;
      }
      return this;
    },
    fromGeometry: function(geometry) {
      geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry(geometry);
      return this.fromDirectGeometry(geometry.__directGeometry);
    },
    fromDirectGeometry: function(geometry) {
      var positions = new Float32Array(geometry.vertices.length * 3);
      this.addAttribute('position', new THREE.BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
      if (geometry.normals.length > 0) {
        var normals = new Float32Array(geometry.normals.length * 3);
        this.addAttribute('normal', new THREE.BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
      }
      if (geometry.colors.length > 0) {
        var colors = new Float32Array(geometry.colors.length * 3);
        this.addAttribute('color', new THREE.BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
      }
      if (geometry.uvs.length > 0) {
        var uvs = new Float32Array(geometry.uvs.length * 2);
        this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
      }
      if (geometry.uvs2.length > 0) {
        var uvs2 = new Float32Array(geometry.uvs2.length * 2);
        this.addAttribute('uv2', new THREE.BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
      }
      if (geometry.indices.length > 0) {
        var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
        var indices = new TypeArray(geometry.indices.length * 3);
        this.setIndex(new THREE.BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
      }
      this.groups = geometry.groups;
      for (var name in geometry.morphTargets) {
        var array = [];
        var morphTargets = geometry.morphTargets[name];
        for (var i = 0,
            l = morphTargets.length; i < l; i++) {
          var morphTarget = morphTargets[i];
          var attribute = new THREE.Float32Attribute(morphTarget.length * 3, 3);
          array.push(attribute.copyVector3sArray(morphTarget));
        }
        this.morphAttributes[name] = array;
      }
      if (geometry.skinIndices.length > 0) {
        var skinIndices = new THREE.Float32Attribute(geometry.skinIndices.length * 4, 4);
        this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
      }
      if (geometry.skinWeights.length > 0) {
        var skinWeights = new THREE.Float32Attribute(geometry.skinWeights.length * 4, 4);
        this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
      }
      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }
      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
      return this;
    },
    computeBoundingBox: function() {
      var vector = new THREE.Vector3();
      return function() {
        if (this.boundingBox === null) {
          this.boundingBox = new THREE.Box3();
        }
        var positions = this.attributes.position.array;
        if (positions) {
          var bb = this.boundingBox;
          bb.makeEmpty();
          for (var i = 0,
              il = positions.length; i < il; i += 3) {
            vector.fromArray(positions, i);
            bb.expandByPoint(vector);
          }
        }
        if (positions === undefined || positions.length === 0) {
          this.boundingBox.min.set(0, 0, 0);
          this.boundingBox.max.set(0, 0, 0);
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
          console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
      };
    }(),
    computeBoundingSphere: function() {
      var box = new THREE.Box3();
      var vector = new THREE.Vector3();
      return function() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new THREE.Sphere();
        }
        var positions = this.attributes.position.array;
        if (positions) {
          box.makeEmpty();
          var center = this.boundingSphere.center;
          for (var i = 0,
              il = positions.length; i < il; i += 3) {
            vector.fromArray(positions, i);
            box.expandByPoint(vector);
          }
          box.center(center);
          var maxRadiusSq = 0;
          for (var i = 0,
              il = positions.length; i < il; i += 3) {
            vector.fromArray(positions, i);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
          }
          this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
          if (isNaN(this.boundingSphere.radius)) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
      };
    }(),
    computeFaceNormals: function() {},
    computeVertexNormals: function() {
      var index = this.index;
      var attributes = this.attributes;
      var groups = this.groups;
      if (attributes.position) {
        var positions = attributes.position.array;
        if (attributes.normal === undefined) {
          this.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(positions.length), 3));
        } else {
          var normals = attributes.normal.array;
          for (var i = 0,
              il = normals.length; i < il; i++) {
            normals[i] = 0;
          }
        }
        var normals = attributes.normal.array;
        var vA,
            vB,
            vC,
            pA = new THREE.Vector3(),
            pB = new THREE.Vector3(),
            pC = new THREE.Vector3(),
            cb = new THREE.Vector3(),
            ab = new THREE.Vector3();
        if (index) {
          var indices = index.array;
          if (groups.length === 0) {
            this.addGroup(0, indices.length);
          }
          for (var j = 0,
              jl = groups.length; j < jl; ++j) {
            var group = groups[j];
            var start = group.start;
            var count = group.count;
            for (var i = start,
                il = start + count; i < il; i += 3) {
              vA = indices[i + 0] * 3;
              vB = indices[i + 1] * 3;
              vC = indices[i + 2] * 3;
              pA.fromArray(positions, vA);
              pB.fromArray(positions, vB);
              pC.fromArray(positions, vC);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normals[vA] += cb.x;
              normals[vA + 1] += cb.y;
              normals[vA + 2] += cb.z;
              normals[vB] += cb.x;
              normals[vB + 1] += cb.y;
              normals[vB + 2] += cb.z;
              normals[vC] += cb.x;
              normals[vC + 1] += cb.y;
              normals[vC + 2] += cb.z;
            }
          }
        } else {
          for (var i = 0,
              il = positions.length; i < il; i += 9) {
            pA.fromArray(positions, i);
            pB.fromArray(positions, i + 3);
            pC.fromArray(positions, i + 6);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normals[i] = cb.x;
            normals[i + 1] = cb.y;
            normals[i + 2] = cb.z;
            normals[i + 3] = cb.x;
            normals[i + 4] = cb.y;
            normals[i + 5] = cb.z;
            normals[i + 6] = cb.x;
            normals[i + 7] = cb.y;
            normals[i + 8] = cb.z;
          }
        }
        this.normalizeNormals();
        attributes.normal.needsUpdate = true;
      }
    },
    computeTangents: function() {
      console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
    },
    computeOffsets: function(size) {
      console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
    },
    merge: function(geometry, offset) {
      if (geometry instanceof THREE.BufferGeometry === false) {
        console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
        return;
      }
      if (offset === undefined)
        offset = 0;
      var attributes = this.attributes;
      for (var key in attributes) {
        if (geometry.attributes[key] === undefined)
          continue;
        var attribute1 = attributes[key];
        var attributeArray1 = attribute1.array;
        var attribute2 = geometry.attributes[key];
        var attributeArray2 = attribute2.array;
        var attributeSize = attribute2.itemSize;
        for (var i = 0,
            j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
          attributeArray1[j] = attributeArray2[i];
        }
      }
      return this;
    },
    normalizeNormals: function() {
      var normals = this.attributes.normal.array;
      var x,
          y,
          z,
          n;
      for (var i = 0,
          il = normals.length; i < il; i += 3) {
        x = normals[i];
        y = normals[i + 1];
        z = normals[i + 2];
        n = 1.0 / Math.sqrt(x * x + y * y + z * z);
        normals[i] *= n;
        normals[i + 1] *= n;
        normals[i + 2] *= n;
      }
    },
    toJSON: function() {
      var data = {metadata: {
          version: 4.4,
          type: 'BufferGeometry',
          generator: 'BufferGeometry.toJSON'
        }};
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== '')
        data.name = this.name;
      if (this.parameters !== undefined) {
        var parameters = this.parameters;
        for (var key in parameters) {
          if (parameters[key] !== undefined)
            data[key] = parameters[key];
        }
        return data;
      }
      data.data = {attributes: {}};
      var index = this.index;
      if (index !== null) {
        var array = Array.prototype.slice.call(index.array);
        data.data.index = {
          type: index.array.constructor.name,
          array: array
        };
      }
      var attributes = this.attributes;
      for (var key in attributes) {
        var attribute = attributes[key];
        var array = Array.prototype.slice.call(attribute.array);
        data.data.attributes[key] = {
          itemSize: attribute.itemSize,
          type: attribute.array.constructor.name,
          array: array
        };
      }
      var groups = this.groups;
      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }
      var boundingSphere = this.boundingSphere;
      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }
      return data;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      var index = source.index;
      if (index !== null) {
        this.setIndex(index.clone());
      }
      var attributes = source.attributes;
      for (var name in attributes) {
        var attribute = attributes[name];
        this.addAttribute(name, attribute.clone());
      }
      var groups = source.groups;
      for (var i = 0,
          l = groups.length; i < l; i++) {
        var group = groups[i];
        this.addGroup(group.start, group.count);
      }
      return this;
    },
    dispose: function() {
      this.dispatchEvent({type: 'dispose'});
    }
  };
  THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
  THREE.BufferGeometry.MaxIndex = 65535;
  THREE.InstancedBufferGeometry = function() {
    THREE.BufferGeometry.call(this);
    this.type = 'InstancedBufferGeometry';
    this.maxInstancedCount = undefined;
  };
  THREE.InstancedBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
  THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;
  THREE.InstancedBufferGeometry.prototype.addGroup = function(start, count, instances) {
    this.groups.push({
      start: start,
      count: count,
      instances: instances
    });
  };
  THREE.InstancedBufferGeometry.prototype.copy = function(source) {
    var index = source.index;
    if (index !== null) {
      this.setIndex(index.clone());
    }
    var attributes = source.attributes;
    for (var name in attributes) {
      var attribute = attributes[name];
      this.addAttribute(name, attribute.clone());
    }
    var groups = source.groups;
    for (var i = 0,
        l = groups.length; i < l; i++) {
      var group = groups[i];
      this.addGroup(group.start, group.count, group.instances);
    }
    return this;
  };
  THREE.EventDispatcher.prototype.apply(THREE.InstancedBufferGeometry.prototype);
  THREE.AnimationAction = function(clip, startTime, timeScale, weight, loop) {
    if (clip === undefined)
      throw new Error('clip is null');
    this.clip = clip;
    this.localRoot = null;
    this.startTime = startTime || 0;
    this.timeScale = timeScale || 1;
    this.weight = weight || 1;
    this.loop = loop || THREE.LoopRepeat;
    this.loopCount = 0;
    this.enabled = true;
    this.actionTime = -this.startTime;
    this.clipTime = 0;
    this.propertyBindings = [];
  };
  THREE.AnimationAction.prototype = {
    constructor: THREE.AnimationAction,
    setLocalRoot: function(localRoot) {
      this.localRoot = localRoot;
      return this;
    },
    updateTime: function(clipDeltaTime) {
      var previousClipTime = this.clipTime;
      var previousLoopCount = this.loopCount;
      var previousActionTime = this.actionTime;
      var duration = this.clip.duration;
      this.actionTime = this.actionTime + clipDeltaTime;
      if (this.loop === THREE.LoopOnce) {
        this.loopCount = 0;
        this.clipTime = Math.min(Math.max(this.actionTime, 0), duration);
        if (this.clipTime !== previousClipTime) {
          if (this.clipTime === duration) {
            this.mixer.dispatchEvent({
              type: 'finished',
              action: this,
              direction: 1
            });
          } else if (this.clipTime === 0) {
            this.mixer.dispatchEvent({
              type: 'finished',
              action: this,
              direction: -1
            });
          }
        }
        return this.clipTime;
      }
      this.loopCount = Math.floor(this.actionTime / duration);
      var newClipTime = this.actionTime - this.loopCount * duration;
      newClipTime = newClipTime % duration;
      if (this.loop == THREE.LoopPingPong) {
        if (Math.abs(this.loopCount % 2) === 1) {
          newClipTime = duration - newClipTime;
        }
      }
      this.clipTime = newClipTime;
      if (this.loopCount !== previousLoopCount) {
        this.mixer.dispatchEvent({
          type: 'loop',
          action: this,
          loopDelta: (this.loopCount - this.loopCount)
        });
      }
      return this.clipTime;
    },
    syncWith: function(action) {
      this.actionTime = action.actionTime;
      this.timeScale = action.timeScale;
      return this;
    },
    warpToDuration: function(duration) {
      this.timeScale = this.clip.duration / duration;
      return this;
    },
    init: function(time) {
      this.clipTime = time - this.startTime;
      return this;
    },
    update: function(clipDeltaTime) {
      this.updateTime(clipDeltaTime);
      var clipResults = this.clip.getAt(this.clipTime);
      return clipResults;
    },
    getTimeScaleAt: function(time) {
      if (this.timeScale.getAt) {
        return this.timeScale.getAt(time);
      }
      return this.timeScale;
    },
    getWeightAt: function(time) {
      if (this.weight.getAt) {
        return this.weight.getAt(time);
      }
      return this.weight;
    }
  };
  THREE.AnimationClip = function(name, duration, tracks) {
    this.name = name;
    this.tracks = tracks;
    this.duration = (duration !== undefined) ? duration : -1;
    if (this.duration < 0) {
      for (var i = 0; i < this.tracks.length; i++) {
        var track = this.tracks[i];
        this.duration = Math.max(track.keys[track.keys.length - 1].time);
      }
    }
    this.trim();
    this.optimize();
    this.results = [];
  };
  THREE.AnimationClip.prototype = {
    constructor: THREE.AnimationClip,
    getAt: function(clipTime) {
      clipTime = Math.max(0, Math.min(clipTime, this.duration));
      for (var i = 0; i < this.tracks.length; i++) {
        var track = this.tracks[i];
        this.results[i] = track.getAt(clipTime);
      }
      return this.results;
    },
    trim: function() {
      for (var i = 0; i < this.tracks.length; i++) {
        this.tracks[i].trim(0, this.duration);
      }
      return this;
    },
    optimize: function() {
      for (var i = 0; i < this.tracks.length; i++) {
        this.tracks[i].optimize();
      }
      return this;
    }
  };
  THREE.AnimationClip.CreateFromMorphTargetSequence = function(name, morphTargetSequence, fps) {
    var numMorphTargets = morphTargetSequence.length;
    var tracks = [];
    for (var i = 0; i < numMorphTargets; i++) {
      var keys = [];
      keys.push({
        time: (i + numMorphTargets - 1) % numMorphTargets,
        value: 0
      });
      keys.push({
        time: i,
        value: 1
      });
      keys.push({
        time: (i + 1) % numMorphTargets,
        value: 0
      });
      keys.sort(THREE.KeyframeTrack.keyComparer);
      if (keys[0].time === 0) {
        keys.push({
          time: numMorphTargets,
          value: keys[0].value
        });
      }
      tracks.push(new THREE.NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', keys).scale(1.0 / fps));
    }
    return new THREE.AnimationClip(name, -1, tracks);
  };
  THREE.AnimationClip.findByName = function(clipArray, name) {
    for (var i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }
    return null;
  };
  THREE.AnimationClip.CreateClipsFromMorphTargetSequences = function(morphTargets, fps) {
    var animationToMorphTargets = {};
    var pattern = /^([\w-]*?)([\d]+)$/;
    for (var i = 0,
        il = morphTargets.length; i < il; i++) {
      var morphTarget = morphTargets[i];
      var parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        var name = parts[1];
        var animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    var clips = [];
    for (var name in animationToMorphTargets) {
      clips.push(THREE.AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps));
    }
    return clips;
  };
  THREE.AnimationClip.parse = function(json) {
    var tracks = [];
    for (var i = 0; i < json.tracks.length; i++) {
      tracks.push(THREE.KeyframeTrack.parse(json.tracks[i]).scale(1.0 / json.fps));
    }
    return new THREE.AnimationClip(json.name, json.duration, tracks);
  };
  THREE.AnimationClip.parseAnimation = function(animation, bones, nodeName) {
    if (!animation) {
      console.error("  no animation in JSONLoader data");
      return null;
    }
    var convertTrack = function(trackName, animationKeys, propertyName, trackType, animationKeyToValueFunc) {
      var keys = [];
      for (var k = 0; k < animationKeys.length; k++) {
        var animationKey = animationKeys[k];
        if (animationKey[propertyName] !== undefined) {
          keys.push({
            time: animationKey.time,
            value: animationKeyToValueFunc(animationKey)
          });
        }
      }
      if (keys.length > 0) {
        return new trackType(trackName, keys);
      }
      return null;
    };
    var tracks = [];
    var clipName = animation.name || 'default';
    var duration = animation.length || -1;
    var fps = animation.fps || 30;
    var hierarchyTracks = animation.hierarchy || [];
    for (var h = 0; h < hierarchyTracks.length; h++) {
      var animationKeys = hierarchyTracks[h].keys;
      if (!animationKeys || animationKeys.length == 0) {
        continue;
      }
      if (animationKeys[0].morphTargets) {
        var morphTargetNames = {};
        for (var k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        }
        for (var morphTargetName in morphTargetNames) {
          var keys = [];
          for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
            var animationKey = animationKeys[k];
            keys.push({
              time: animationKey.time,
              value: ((animationKey.morphTarget === morphTargetName) ? 1 : 0)
            });
          }
          tracks.push(new THREE.NumberKeyframeTrack(nodeName + '.morphTargetInfluence[' + morphTargetName + ']', keys));
        }
        duration = morphTargetNames.length * (fps || 1.0);
      } else {
        var boneName = nodeName + '.bones[' + bones[h].name + ']';
        var positionTrack = convertTrack(boneName + '.position', animationKeys, 'pos', THREE.VectorKeyframeTrack, function(animationKey) {
          return new THREE.Vector3().fromArray(animationKey.pos);
        });
        if (positionTrack)
          tracks.push(positionTrack);
        var quaternionTrack = convertTrack(boneName + '.quaternion', animationKeys, 'rot', THREE.QuaternionKeyframeTrack, function(animationKey) {
          if (animationKey.rot.slerp) {
            return animationKey.rot.clone();
          } else {
            return new THREE.Quaternion().fromArray(animationKey.rot);
          }
        });
        if (quaternionTrack)
          tracks.push(quaternionTrack);
        var scaleTrack = convertTrack(boneName + '.scale', animationKeys, 'scl', THREE.VectorKeyframeTrack, function(animationKey) {
          return new THREE.Vector3().fromArray(animationKey.scl);
        });
        if (scaleTrack)
          tracks.push(scaleTrack);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    var clip = new THREE.AnimationClip(clipName, duration, tracks);
    return clip;
  };
  THREE.AnimationMixer = function(root) {
    this.root = root;
    this.time = 0;
    this.timeScale = 1.0;
    this.actions = [];
    this.propertyBindingMap = {};
  };
  THREE.AnimationMixer.prototype = {
    constructor: THREE.AnimationMixer,
    addAction: function(action) {
      this.actions.push(action);
      action.init(this.time);
      action.mixer = this;
      var tracks = action.clip.tracks;
      var root = action.localRoot || this.root;
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        var propertyBindingKey = root.uuid + '-' + track.name;
        var propertyBinding = this.propertyBindingMap[propertyBindingKey];
        if (propertyBinding === undefined) {
          propertyBinding = new THREE.PropertyBinding(root, track.name);
          this.propertyBindingMap[propertyBindingKey] = propertyBinding;
        }
        action.propertyBindings.push(propertyBinding);
        propertyBinding.referenceCount += 1;
      }
    },
    removeAllActions: function() {
      for (var i = 0; i < this.actions.length; i++) {
        this.actions[i].mixer = null;
      }
      for (var properyBindingKey in this.propertyBindingMap) {
        this.propertyBindingMap[properyBindingKey].unbind();
      }
      this.actions = [];
      this.propertyBindingMap = {};
      return this;
    },
    removeAction: function(action) {
      var index = this.actions.indexOf(action);
      if (index !== -1) {
        this.actions.splice(index, 1);
        action.mixer = null;
      }
      var root = action.localRoot || this.root;
      var tracks = action.clip.tracks;
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        var propertyBindingKey = root.uuid + '-' + track.name;
        var propertyBinding = this.propertyBindingMap[propertyBindingKey];
        propertyBinding.referenceCount -= 1;
        if (propertyBinding.referenceCount <= 0) {
          propertyBinding.unbind();
          delete this.propertyBindingMap[propertyBindingKey];
        }
      }
      return this;
    },
    findActionByName: function(name) {
      for (var i = 0; i < this.actions.length; i++) {
        if (this.actions[i].name === name)
          return this.actions[i];
      }
      return null;
    },
    play: function(action, optionalFadeInDuration) {
      action.startTime = this.time;
      this.addAction(action);
      return this;
    },
    fadeOut: function(action, duration) {
      var keys = [];
      keys.push({
        time: this.time,
        value: 1
      });
      keys.push({
        time: this.time + duration,
        value: 0
      });
      action.weight = new THREE.NumberKeyframeTrack("weight", keys);
      return this;
    },
    fadeIn: function(action, duration) {
      var keys = [];
      keys.push({
        time: this.time,
        value: 0
      });
      keys.push({
        time: this.time + duration,
        value: 1
      });
      action.weight = new THREE.NumberKeyframeTrack("weight", keys);
      return this;
    },
    warp: function(action, startTimeScale, endTimeScale, duration) {
      var keys = [];
      keys.push({
        time: this.time,
        value: startTimeScale
      });
      keys.push({
        time: this.time + duration,
        value: endTimeScale
      });
      action.timeScale = new THREE.NumberKeyframeTrack("timeScale", keys);
      return this;
    },
    crossFade: function(fadeOutAction, fadeInAction, duration, warp) {
      this.fadeOut(fadeOutAction, duration);
      this.fadeIn(fadeInAction, duration);
      if (warp) {
        var startEndRatio = fadeOutAction.clip.duration / fadeInAction.clip.duration;
        var endStartRatio = 1.0 / startEndRatio;
        this.warp(fadeOutAction, 1.0, startEndRatio, duration);
        this.warp(fadeInAction, endStartRatio, 1.0, duration);
      }
      return this;
    },
    update: function(deltaTime) {
      var mixerDeltaTime = deltaTime * this.timeScale;
      this.time += mixerDeltaTime;
      for (var i = 0; i < this.actions.length; i++) {
        var action = this.actions[i];
        var weight = action.getWeightAt(this.time);
        var actionTimeScale = action.getTimeScaleAt(this.time);
        var actionDeltaTime = mixerDeltaTime * actionTimeScale;
        var actionResults = action.update(actionDeltaTime);
        if (action.weight <= 0 || !action.enabled)
          continue;
        for (var j = 0; j < actionResults.length; j++) {
          var name = action.clip.tracks[j].name;
          action.propertyBindings[j].accumulate(actionResults[j], weight);
        }
      }
      for (var propertyBindingKey in this.propertyBindingMap) {
        this.propertyBindingMap[propertyBindingKey].apply();
      }
      return this;
    }
  };
  THREE.EventDispatcher.prototype.apply(THREE.AnimationMixer.prototype);
  THREE.AnimationUtils = {
    getEqualsFunc: function(exemplarValue) {
      if (exemplarValue.equals) {
        return function equals_object(a, b) {
          return a.equals(b);
        };
      }
      return function equals_primitive(a, b) {
        return (a === b);
      };
    },
    clone: function(exemplarValue) {
      var typeName = typeof exemplarValue;
      if (typeName === "object") {
        if (exemplarValue.clone) {
          return exemplarValue.clone();
        }
        console.error("can not figure out how to copy exemplarValue", exemplarValue);
      }
      return exemplarValue;
    },
    lerp: function(a, b, alpha, interTrack) {
      var lerpFunc = THREE.AnimationUtils.getLerpFunc(a, interTrack);
      return lerpFunc(a, b, alpha);
    },
    lerp_object: function(a, b, alpha) {
      return a.lerp(b, alpha);
    },
    slerp_object: function(a, b, alpha) {
      return a.slerp(b, alpha);
    },
    lerp_number: function(a, b, alpha) {
      return a * (1 - alpha) + b * alpha;
    },
    lerp_boolean: function(a, b, alpha) {
      return (alpha < 0.5) ? a : b;
    },
    lerp_boolean_immediate: function(a, b, alpha) {
      return a;
    },
    lerp_string: function(a, b, alpha) {
      return (alpha < 0.5) ? a : b;
    },
    lerp_string_immediate: function(a, b, alpha) {
      return a;
    },
    getLerpFunc: function(exemplarValue, interTrack) {
      if (exemplarValue === undefined || exemplarValue === null)
        throw new Error("examplarValue is null");
      var typeName = typeof exemplarValue;
      switch (typeName) {
        case "object":
          if (exemplarValue.lerp) {
            return THREE.AnimationUtils.lerp_object;
          }
          if (exemplarValue.slerp) {
            return THREE.AnimationUtils.slerp_object;
          }
          break;
        case "number":
          return THREE.AnimationUtils.lerp_number;
        case "boolean":
          if (interTrack) {
            return THREE.AnimationUtils.lerp_boolean;
          } else {
            return THREE.AnimationUtils.lerp_boolean_immediate;
          }
        case "string":
          if (interTrack) {
            return THREE.AnimationUtils.lerp_string;
          } else {
            return THREE.AnimationUtils.lerp_string_immediate;
          }
      }
    }
  };
  THREE.KeyframeTrack = function(name, keys) {
    if (name === undefined)
      throw new Error("track name is undefined");
    if (keys === undefined || keys.length === 0)
      throw new Error("no keys in track named " + name);
    this.name = name;
    this.keys = keys;
    this.lastIndex = 0;
    this.validate();
    this.optimize();
  };
  THREE.KeyframeTrack.prototype = {
    constructor: THREE.KeyframeTrack,
    getAt: function(time) {
      while ((this.lastIndex < this.keys.length) && (time >= this.keys[this.lastIndex].time)) {
        this.lastIndex++;
      }
      ;
      while ((this.lastIndex > 0) && (time < this.keys[this.lastIndex - 1].time)) {
        this.lastIndex--;
      }
      if (this.lastIndex >= this.keys.length) {
        this.setResult(this.keys[this.keys.length - 1].value);
        return this.result;
      }
      if (this.lastIndex === 0) {
        this.setResult(this.keys[0].value);
        return this.result;
      }
      var prevKey = this.keys[this.lastIndex - 1];
      this.setResult(prevKey.value);
      if (prevKey.constantToNext) {
        return this.result;
      }
      var currentKey = this.keys[this.lastIndex];
      var alpha = (time - prevKey.time) / (currentKey.time - prevKey.time);
      this.result = this.lerpValues(this.result, currentKey.value, alpha);
      return this.result;
    },
    shift: function(timeOffset) {
      if (timeOffset !== 0.0) {
        for (var i = 0; i < this.keys.length; i++) {
          this.keys[i].time += timeOffset;
        }
      }
      return this;
    },
    scale: function(timeScale) {
      if (timeScale !== 1.0) {
        for (var i = 0; i < this.keys.length; i++) {
          this.keys[i].time *= timeScale;
        }
      }
      return this;
    },
    trim: function(startTime, endTime) {
      var firstKeysToRemove = 0;
      for (var i = 1; i < this.keys.length; i++) {
        if (this.keys[i] <= startTime) {
          firstKeysToRemove++;
        }
      }
      var lastKeysToRemove = 0;
      for (var i = this.keys.length - 2; i > 0; i++) {
        if (this.keys[i] >= endTime) {
          lastKeysToRemove++;
        } else {
          break;
        }
      }
      if ((firstKeysToRemove + lastKeysToRemove) > 0) {
        this.keys = this.keys.splice(firstKeysToRemove, this.keys.length - lastKeysToRemove - firstKeysToRemove);
        ;
      }
      return this;
    },
    validate: function() {
      var prevKey = null;
      if (this.keys.length === 0) {
        console.error("  track is empty, no keys", this);
        return;
      }
      for (var i = 0; i < this.keys.length; i++) {
        var currKey = this.keys[i];
        if (!currKey) {
          console.error("  key is null in track", this, i);
          return;
        }
        if ((typeof currKey.time) !== 'number' || isNaN(currKey.time)) {
          console.error("  key.time is not a valid number", this, i, currKey);
          return;
        }
        if (currKey.value === undefined || currKey.value === null) {
          console.error("  key.value is null in track", this, i, currKey);
          return;
        }
        if (prevKey && prevKey.time > currKey.time) {
          console.error("  key.time is less than previous key time, out of order keys", this, i, currKey, prevKey);
          return;
        }
        prevKey = currKey;
      }
      return this;
    },
    optimize: function() {
      var newKeys = [];
      var prevKey = this.keys[0];
      newKeys.push(prevKey);
      var equalsFunc = THREE.AnimationUtils.getEqualsFunc(prevKey.value);
      for (var i = 1; i < this.keys.length - 1; i++) {
        var currKey = this.keys[i];
        var nextKey = this.keys[i + 1];
        if ((prevKey.time === currKey.time)) {
          continue;
        }
        if (this.compareValues(prevKey.value, currKey.value) && this.compareValues(currKey.value, nextKey.value)) {
          continue;
        }
        prevKey.constantToNext = this.compareValues(prevKey.value, currKey.value);
        newKeys.push(currKey);
        prevKey = currKey;
      }
      newKeys.push(this.keys[this.keys.length - 1]);
      this.keys = newKeys;
      return this;
    }
  };
  THREE.KeyframeTrack.keyComparer = function keyComparator(key0, key1) {
    return key0.time - key1.time;
  };
  THREE.KeyframeTrack.parse = function(json) {
    if (json.type === undefined)
      throw new Error("track type undefined, can not parse");
    var trackType = THREE.KeyframeTrack.GetTrackTypeForTypeName(json.type);
    return trackType.parse(json);
  };
  THREE.KeyframeTrack.GetTrackTypeForTypeName = function(typeName) {
    switch (typeName.toLowerCase()) {
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return THREE.VectorKeyframeTrack;
      case "quaternion":
        return THREE.QuaternionKeyframeTrack;
      case "integer":
      case "scalar":
      case "double":
      case "float":
      case "number":
        return THREE.NumberKeyframeTrack;
      case "bool":
      case "boolean":
        return THREE.BooleanKeyframeTrack;
      case "string":
        return THREE.StringKeyframeTrack;
    }
    ;
    throw new Error("Unsupported typeName: " + typeName);
  };
  THREE.PropertyBinding = function(rootNode, trackName) {
    this.rootNode = rootNode;
    this.trackName = trackName;
    this.referenceCount = 0;
    this.originalValue = null;
    var parseResults = THREE.PropertyBinding.parseTrackName(trackName);
    this.directoryName = parseResults.directoryName;
    this.nodeName = parseResults.nodeName;
    this.objectName = parseResults.objectName;
    this.objectIndex = parseResults.objectIndex;
    this.propertyName = parseResults.propertyName;
    this.propertyIndex = parseResults.propertyIndex;
    this.node = THREE.PropertyBinding.findNode(rootNode, this.nodeName) || rootNode;
    this.cumulativeValue = null;
    this.cumulativeWeight = 0;
  };
  THREE.PropertyBinding.prototype = {
    constructor: THREE.PropertyBinding,
    reset: function() {
      this.cumulativeValue = null;
      this.cumulativeWeight = 0;
    },
    accumulate: function(value, weight) {
      if (!this.isBound)
        this.bind();
      if (this.cumulativeWeight === 0) {
        if (weight > 0) {
          if (this.cumulativeValue === null) {
            this.cumulativeValue = THREE.AnimationUtils.clone(value);
          }
          this.cumulativeWeight = weight;
        }
      } else {
        var lerpAlpha = weight / (this.cumulativeWeight + weight);
        this.cumulativeValue = this.lerpValue(this.cumulativeValue, value, lerpAlpha);
        this.cumulativeWeight += weight;
      }
    },
    unbind: function() {
      if (!this.isBound)
        return;
      this.setValue(this.originalValue);
      this.setValue = null;
      this.getValue = null;
      this.lerpValue = null;
      this.equalsValue = null;
      this.triggerDirty = null;
      this.isBound = false;
    },
    bind: function() {
      if (this.isBound)
        return;
      var targetObject = this.node;
      if (!targetObject) {
        console.error("  trying to update node for track: " + this.trackName + " but it wasn't found.");
        return;
      }
      if (this.objectName) {
        if (this.objectName === "materials") {
          if (!targetObject.material) {
            console.error('  can not bind to material as node does not have a material', this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error('  can not bind to material.materials as node.material does not have a materials array', this);
            return;
          }
          targetObject = targetObject.material.materials;
        } else if (this.objectName === "bones") {
          if (!targetObject.skeleton) {
            console.error('  can not bind to bones as node does not have a skeleton', this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (var i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === this.objectIndex) {
              this.objectIndex = i;
              break;
            }
          }
        } else {
          if (targetObject[this.objectName] === undefined) {
            console.error('  can not bind to objectName of node, undefined', this);
            return;
          }
          targetObject = targetObject[this.objectName];
        }
        if (this.objectIndex !== undefined) {
          if (targetObject[this.objectIndex] === undefined) {
            console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject);
            return;
          }
          targetObject = targetObject[this.objectIndex];
        }
      }
      var nodeProperty = targetObject[this.propertyName];
      if (!nodeProperty) {
        console.error("  trying to update property for track: " + this.nodeName + '.' + this.propertyName + " but it wasn't found.", targetObject);
        return;
      }
      if (this.propertyIndex !== undefined) {
        if (this.propertyName === "morphTargetInfluences") {
          if (!targetObject.geometry) {
            console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry', this);
          }
          if (!targetObject.geometry.morphTargets) {
            console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this);
          }
          for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
            if (targetObject.geometry.morphTargets[i].name === this.propertyIndex) {
              this.propertyIndex = i;
              break;
            }
          }
        }
        this.setValue = function setValue_propertyIndexed(value) {
          if (!this.equalsValue(nodeProperty[this.propertyIndex], value)) {
            nodeProperty[this.propertyIndex] = value;
            return true;
          }
          return false;
        };
        this.getValue = function getValue_propertyIndexed() {
          return nodeProperty[this.propertyIndex];
        };
      } else if (nodeProperty.copy) {
        this.setValue = function setValue_propertyObject(value) {
          if (!this.equalsValue(nodeProperty, value)) {
            nodeProperty.copy(value);
            return true;
          }
          return false;
        };
        this.getValue = function getValue_propertyObject() {
          return nodeProperty;
        };
      } else {
        this.setValue = function setValue_property(value) {
          if (!this.equalsValue(targetObject[this.propertyName], value)) {
            targetObject[this.propertyName] = value;
            return true;
          }
          return false;
        };
        this.getValue = function getValue_property() {
          return targetObject[this.propertyName];
        };
      }
      if (targetObject.needsUpdate !== undefined) {
        this.triggerDirty = function triggerDirty_needsUpdate() {
          this.node.needsUpdate = true;
        };
      } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
        this.triggerDirty = function triggerDirty_matrixWorldNeedsUpdate() {
          targetObject.matrixWorldNeedsUpdate = true;
        };
      }
      this.originalValue = this.getValue();
      this.equalsValue = THREE.AnimationUtils.getEqualsFunc(this.originalValue);
      this.lerpValue = THREE.AnimationUtils.getLerpFunc(this.originalValue, true);
      this.isBound = true;
    },
    apply: function() {
      if (!this.isBound)
        this.bind();
      if (this.cumulativeWeight > 0) {
        if (this.cumulativeWeight < 1) {
          var remainingWeight = 1 - this.cumulativeWeight;
          var lerpAlpha = remainingWeight / (this.cumulativeWeight + remainingWeight);
          this.cumulativeValue = this.lerpValue(this.cumulativeValue, this.originalValue, lerpAlpha);
        }
        var valueChanged = this.setValue(this.cumulativeValue);
        if (valueChanged && this.triggerDirty) {
          this.triggerDirty();
        }
        this.cumulativeValue = null;
        this.cumulativeWeight = 0;
      }
    }
  };
  THREE.PropertyBinding.parseTrackName = function(trackName) {
    var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
    var matches = re.exec(trackName);
    if (!matches) {
      throw new Error("cannot parse trackName at all: " + trackName);
    }
    if (matches.index === re.lastIndex) {
      re.lastIndex++;
    }
    var results = {
      directoryName: matches[1],
      nodeName: matches[3],
      objectName: matches[5],
      objectIndex: matches[7],
      propertyName: matches[9],
      propertyIndex: matches[11]
    };
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("can not parse propertyName from trackName: " + trackName);
    }
    return results;
  };
  THREE.PropertyBinding.findNode = function(root, nodeName) {
    function searchSkeleton(skeleton) {
      for (var i = 0; i < skeleton.bones.length; i++) {
        var bone = skeleton.bones[i];
        if (bone.name === nodeName) {
          return bone;
        }
      }
      return null;
    }
    function searchNodeSubtree(children) {
      for (var i = 0; i < children.length; i++) {
        var childNode = children[i];
        if (childNode.name === nodeName || childNode.uuid === nodeName) {
          return childNode;
        }
        var result = searchNodeSubtree(childNode.children);
        if (result)
          return result;
      }
      return null;
    }
    if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      var bone = searchSkeleton(root.skeleton);
      if (bone) {
        return bone;
      }
    }
    if (root.children) {
      var subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  };
  THREE.VectorKeyframeTrack = function(name, keys) {
    THREE.KeyframeTrack.call(this, name, keys);
    this.result = this.keys[0].value.clone();
  };
  THREE.VectorKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
  THREE.VectorKeyframeTrack.prototype.constructor = THREE.VectorKeyframeTrack;
  THREE.VectorKeyframeTrack.prototype.setResult = function(value) {
    this.result.copy(value);
  };
  THREE.VectorKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
    return value0.lerp(value1, alpha);
  };
  THREE.VectorKeyframeTrack.prototype.compareValues = function(value0, value1) {
    return value0.equals(value1);
  };
  THREE.VectorKeyframeTrack.prototype.clone = function() {
    var clonedKeys = [];
    for (var i = 0; i < this.keys.length; i++) {
      var key = this.keys[i];
      clonedKeys.push({
        time: key.time,
        value: key.value.clone()
      });
    }
    return new THREE.VectorKeyframeTrack(this.name, clonedKeys);
  };
  THREE.VectorKeyframeTrack.parse = function(json) {
    var elementCount = json.keys[0].value.length;
    var valueType = THREE['Vector' + elementCount];
    var keys = [];
    for (var i = 0; i < json.keys.length; i++) {
      var jsonKey = json.keys[i];
      keys.push({
        value: new valueType().fromArray(jsonKey.value),
        time: jsonKey.time
      });
    }
    return new THREE.VectorKeyframeTrack(json.name, keys);
  };
  THREE.QuaternionKeyframeTrack = function(name, keys) {
    THREE.KeyframeTrack.call(this, name, keys);
    this.result = this.keys[0].value.clone();
  };
  THREE.QuaternionKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
  THREE.QuaternionKeyframeTrack.prototype.constructor = THREE.QuaternionKeyframeTrack;
  THREE.QuaternionKeyframeTrack.prototype.setResult = function(value) {
    this.result.copy(value);
  };
  THREE.QuaternionKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
    return value0.slerp(value1, alpha);
  };
  THREE.QuaternionKeyframeTrack.prototype.compareValues = function(value0, value1) {
    return value0.equals(value1);
  };
  THREE.QuaternionKeyframeTrack.prototype.multiply = function(quat) {
    for (var i = 0; i < this.keys.length; i++) {
      this.keys[i].value.multiply(quat);
    }
    return this;
  };
  THREE.QuaternionKeyframeTrack.prototype.clone = function() {
    var clonedKeys = [];
    for (var i = 0; i < this.keys.length; i++) {
      var key = this.keys[i];
      clonedKeys.push({
        time: key.time,
        value: key.value.clone()
      });
    }
    return new THREE.QuaternionKeyframeTrack(this.name, clonedKeys);
  };
  THREE.QuaternionKeyframeTrack.parse = function(json) {
    var keys = [];
    for (var i = 0; i < json.keys.length; i++) {
      var jsonKey = json.keys[i];
      keys.push({
        value: new THREE.Quaternion().fromArray(jsonKey.value),
        time: jsonKey.time
      });
    }
    return new THREE.QuaternionKeyframeTrack(json.name, keys);
  };
  THREE.StringKeyframeTrack = function(name, keys) {
    THREE.KeyframeTrack.call(this, name, keys);
    this.result = this.keys[0].value;
  };
  THREE.StringKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
  THREE.StringKeyframeTrack.prototype.constructor = THREE.StringKeyframeTrack;
  THREE.StringKeyframeTrack.prototype.setResult = function(value) {
    this.result = value;
  };
  THREE.StringKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
    return (alpha < 1.0) ? value0 : value1;
  };
  THREE.StringKeyframeTrack.prototype.compareValues = function(value0, value1) {
    return (value0 === value1);
  };
  THREE.StringKeyframeTrack.prototype.clone = function() {
    var clonedKeys = [];
    for (var i = 0; i < this.keys.length; i++) {
      var key = this.keys[i];
      clonedKeys.push({
        time: key.time,
        value: key.value
      });
    }
    return new THREE.StringKeyframeTrack(this.name, clonedKeys);
  };
  THREE.StringKeyframeTrack.parse = function(json) {
    return new THREE.StringKeyframeTrack(json.name, json.keys);
  };
  THREE.BooleanKeyframeTrack = function(name, keys) {
    THREE.KeyframeTrack.call(this, name, keys);
    this.result = this.keys[0].value;
  };
  THREE.BooleanKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
  THREE.BooleanKeyframeTrack.prototype.constructor = THREE.BooleanKeyframeTrack;
  THREE.BooleanKeyframeTrack.prototype.setResult = function(value) {
    this.result = value;
  };
  THREE.BooleanKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
    return (alpha < 1.0) ? value0 : value1;
  };
  THREE.BooleanKeyframeTrack.prototype.compareValues = function(value0, value1) {
    return (value0 === value1);
  };
  THREE.BooleanKeyframeTrack.prototype.clone = function() {
    var clonedKeys = [];
    for (var i = 0; i < this.keys.length; i++) {
      var key = this.keys[i];
      clonedKeys.push({
        time: key.time,
        value: key.value
      });
    }
    return new THREE.BooleanKeyframeTrack(this.name, clonedKeys);
  };
  THREE.BooleanKeyframeTrack.parse = function(json) {
    return new THREE.BooleanKeyframeTrack(json.name, json.keys);
  };
  THREE.NumberKeyframeTrack = function(name, keys) {
    THREE.KeyframeTrack.call(this, name, keys);
    this.result = this.keys[0].value;
  };
  THREE.NumberKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
  THREE.NumberKeyframeTrack.prototype.constructor = THREE.NumberKeyframeTrack;
  THREE.NumberKeyframeTrack.prototype.setResult = function(value) {
    this.result = value;
  };
  THREE.NumberKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
    return value0 * (1 - alpha) + value1 * alpha;
  };
  THREE.NumberKeyframeTrack.prototype.compareValues = function(value0, value1) {
    return (value0 === value1);
  };
  THREE.NumberKeyframeTrack.prototype.clone = function() {
    var clonedKeys = [];
    for (var i = 0; i < this.keys.length; i++) {
      var key = this.keys[i];
      clonedKeys.push({
        time: key.time,
        value: key.value
      });
    }
    return new THREE.NumberKeyframeTrack(this.name, clonedKeys);
  };
  THREE.NumberKeyframeTrack.parse = function(json) {
    return new THREE.NumberKeyframeTrack(json.name, json.keys);
  };
  THREE.Camera = function() {
    THREE.Object3D.call(this);
    this.type = 'Camera';
    this.matrixWorldInverse = new THREE.Matrix4();
    this.projectionMatrix = new THREE.Matrix4();
  };
  THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
  THREE.Camera.prototype.constructor = THREE.Camera;
  THREE.Camera.prototype.getWorldDirection = function() {
    var quaternion = new THREE.Quaternion();
    return function(optionalTarget) {
      var result = optionalTarget || new THREE.Vector3();
      this.getWorldQuaternion(quaternion);
      return result.set(0, 0, -1).applyQuaternion(quaternion);
    };
  }();
  THREE.Camera.prototype.lookAt = function() {
    var m1 = new THREE.Matrix4();
    return function(vector) {
      m1.lookAt(this.position, vector, this.up);
      this.quaternion.setFromRotationMatrix(m1);
    };
  }();
  THREE.Camera.prototype.clone = function() {
    return new this.constructor().copy(this);
  };
  THREE.Camera.prototype.copy = function(source) {
    THREE.Object3D.prototype.copy.call(this, source);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    return this;
  };
  THREE.CubeCamera = function(near, far, cubeResolution) {
    THREE.Object3D.call(this);
    this.type = 'CubeCamera';
    var fov = 90,
        aspect = 1;
    var cameraPX = new THREE.PerspectiveCamera(fov, aspect, near, far);
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
    this.add(cameraPX);
    var cameraNX = new THREE.PerspectiveCamera(fov, aspect, near, far);
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));
    this.add(cameraNX);
    var cameraPY = new THREE.PerspectiveCamera(fov, aspect, near, far);
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
    this.add(cameraPY);
    var cameraNY = new THREE.PerspectiveCamera(fov, aspect, near, far);
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new THREE.Vector3(0, -1, 0));
    this.add(cameraNY);
    var cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
    this.add(cameraPZ);
    var cameraNZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));
    this.add(cameraNZ);
    this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution, cubeResolution, {
      format: THREE.RGBFormat,
      magFilter: THREE.LinearFilter,
      minFilter: THREE.LinearFilter
    });
    this.updateCubeMap = function(renderer, scene) {
      if (this.parent === null)
        this.updateMatrixWorld();
      var renderTarget = this.renderTarget;
      var generateMipmaps = renderTarget.texture.generateMipmaps;
      renderTarget.texture.generateMipmaps = false;
      renderTarget.activeCubeFace = 0;
      renderer.render(scene, cameraPX, renderTarget);
      renderTarget.activeCubeFace = 1;
      renderer.render(scene, cameraNX, renderTarget);
      renderTarget.activeCubeFace = 2;
      renderer.render(scene, cameraPY, renderTarget);
      renderTarget.activeCubeFace = 3;
      renderer.render(scene, cameraNY, renderTarget);
      renderTarget.activeCubeFace = 4;
      renderer.render(scene, cameraPZ, renderTarget);
      renderTarget.texture.generateMipmaps = generateMipmaps;
      renderTarget.activeCubeFace = 5;
      renderer.render(scene, cameraNZ, renderTarget);
      renderer.setRenderTarget(null);
    };
  };
  THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
  THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
  THREE.OrthographicCamera = function(left, right, top, bottom, near, far) {
    THREE.Camera.call(this);
    this.type = 'OrthographicCamera';
    this.zoom = 1;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = (near !== undefined) ? near : 0.1;
    this.far = (far !== undefined) ? far : 2000;
    this.updateProjectionMatrix();
  };
  THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
  THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
  THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
    var dx = (this.right - this.left) / (2 * this.zoom);
    var dy = (this.top - this.bottom) / (2 * this.zoom);
    var cx = (this.right + this.left) / 2;
    var cy = (this.top + this.bottom) / 2;
    this.projectionMatrix.makeOrthographic(cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far);
  };
  THREE.OrthographicCamera.prototype.copy = function(source) {
    THREE.Camera.prototype.copy.call(this, source);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    return this;
  };
  THREE.OrthographicCamera.prototype.toJSON = function(meta) {
    var data = THREE.Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    return data;
  };
  THREE.PerspectiveCamera = function(fov, aspect, near, far) {
    THREE.Camera.call(this);
    this.type = 'PerspectiveCamera';
    this.zoom = 1;
    this.fov = fov !== undefined ? fov : 50;
    this.aspect = aspect !== undefined ? aspect : 1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.updateProjectionMatrix();
  };
  THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
  THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
  THREE.PerspectiveCamera.prototype.setLens = function(focalLength, frameHeight) {
    if (frameHeight === undefined)
      frameHeight = 24;
    this.fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));
    this.updateProjectionMatrix();
  };
  THREE.PerspectiveCamera.prototype.setViewOffset = function(fullWidth, fullHeight, x, y, width, height) {
    this.fullWidth = fullWidth;
    this.fullHeight = fullHeight;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.updateProjectionMatrix();
  };
  THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
    var fov = THREE.Math.radToDeg(2 * Math.atan(Math.tan(THREE.Math.degToRad(this.fov) * 0.5) / this.zoom));
    if (this.fullWidth) {
      var aspect = this.fullWidth / this.fullHeight;
      var top = Math.tan(THREE.Math.degToRad(fov * 0.5)) * this.near;
      var bottom = -top;
      var left = aspect * bottom;
      var right = aspect * top;
      var width = Math.abs(right - left);
      var height = Math.abs(top - bottom);
      this.projectionMatrix.makeFrustum(left + this.x * width / this.fullWidth, left + (this.x + this.width) * width / this.fullWidth, top - (this.y + this.height) * height / this.fullHeight, top - this.y * height / this.fullHeight, this.near, this.far);
    } else {
      this.projectionMatrix.makePerspective(fov, this.aspect, this.near, this.far);
    }
  };
  THREE.PerspectiveCamera.prototype.copy = function(source) {
    THREE.Camera.prototype.copy.call(this, source);
    this.fov = source.fov;
    this.aspect = source.aspect;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    return this;
  };
  THREE.PerspectiveCamera.prototype.toJSON = function(meta) {
    var data = THREE.Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.fov = this.fov;
    data.object.aspect = this.aspect;
    data.object.near = this.near;
    data.object.far = this.far;
    return data;
  };
  THREE.Light = function(color) {
    THREE.Object3D.call(this);
    this.type = 'Light';
    this.color = new THREE.Color(color);
    this.receiveShadow = undefined;
  };
  THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
  THREE.Light.prototype.constructor = THREE.Light;
  Object.defineProperties(THREE.Light.prototype, {
    onlyShadow: {set: function(value) {
        console.warn('THREE.Light: .onlyShadow has been removed.');
      }},
    shadowCameraFov: {set: function(value) {
        this.shadow.camera.fov = value;
      }},
    shadowCameraLeft: {set: function(value) {
        this.shadow.camera.left = value;
      }},
    shadowCameraRight: {set: function(value) {
        this.shadow.camera.right = value;
      }},
    shadowCameraTop: {set: function(value) {
        this.shadow.camera.top = value;
      }},
    shadowCameraBottom: {set: function(value) {
        this.shadow.camera.bottom = value;
      }},
    shadowCameraNear: {set: function(value) {
        this.shadow.camera.near = value;
      }},
    shadowCameraFar: {set: function(value) {
        this.shadow.camera.far = value;
      }},
    shadowCameraVisible: {set: function(value) {
        console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow ) instead.');
      }},
    shadowBias: {set: function(value) {
        this.shadow.bias = value;
      }},
    shadowDarkness: {set: function(value) {
        this.shadow.darkness = value;
      }},
    shadowMapWidth: {set: function(value) {
        this.shadow.mapSize.width = value;
      }},
    shadowMapHeight: {set: function(value) {
        this.shadow.mapSize.height = value;
      }}
  });
  THREE.Light.prototype.copy = function(source) {
    THREE.Object3D.prototype.copy.call(this, source);
    this.color.copy(source.color);
    return this;
  };
  THREE.Light.prototype.toJSON = function(meta) {
    var data = THREE.Object3D.prototype.toJSON.call(this, meta);
    data.object.color = this.color.getHex();
    if (this.groundColor !== undefined)
      data.object.groundColor = this.groundColor.getHex();
    if (this.intensity !== undefined)
      data.object.intensity = this.intensity;
    if (this.distance !== undefined)
      data.object.distance = this.distance;
    if (this.angle !== undefined)
      data.object.angle = this.angle;
    if (this.decay !== undefined)
      data.object.decay = this.decay;
    if (this.exponent !== undefined)
      data.object.exponent = this.exponent;
    return data;
  };
  THREE.LightShadow = function(camera) {
    this.camera = camera;
    this.bias = 0;
    this.darkness = 1;
    this.mapSize = new THREE.Vector2(512, 512);
    this.map = null;
    this.matrix = null;
  };
  THREE.LightShadow.prototype = {
    constructor: THREE.LightShadow,
    copy: function(source) {
      this.camera = source.camera.clone();
      this.bias = source.bias;
      this.darkness = source.darkness;
      this.mapSize.copy(source.mapSize);
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  };
  THREE.AmbientLight = function(color) {
    THREE.Light.call(this, color);
    this.type = 'AmbientLight';
    this.castShadow = undefined;
  };
  THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
  THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
  THREE.DirectionalLight = function(color, intensity) {
    THREE.Light.call(this, color);
    this.type = 'DirectionalLight';
    this.position.set(0, 1, 0);
    this.updateMatrix();
    this.target = new THREE.Object3D();
    this.intensity = (intensity !== undefined) ? intensity : 1;
    this.shadow = new THREE.LightShadow(new THREE.OrthographicCamera(-500, 500, 500, -500, 50, 5000));
  };
  THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
  THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
  THREE.DirectionalLight.prototype.copy = function(source) {
    THREE.Light.prototype.copy.call(this, source);
    this.intensity = source.intensity;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  };
  THREE.HemisphereLight = function(skyColor, groundColor, intensity) {
    THREE.Light.call(this, skyColor);
    this.type = 'HemisphereLight';
    this.castShadow = undefined;
    this.position.set(0, 1, 0);
    this.updateMatrix();
    this.groundColor = new THREE.Color(groundColor);
    this.intensity = (intensity !== undefined) ? intensity : 1;
  };
  THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
  THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;
  THREE.HemisphereLight.prototype.copy = function(source) {
    THREE.Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    this.intensity = source.intensity;
    return this;
  };
  THREE.PointLight = function(color, intensity, distance, decay) {
    THREE.Light.call(this, color);
    this.type = 'PointLight';
    this.intensity = (intensity !== undefined) ? intensity : 1;
    this.distance = (distance !== undefined) ? distance : 0;
    this.decay = (decay !== undefined) ? decay : 1;
    this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90, 1, 1, 500));
  };
  THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
  THREE.PointLight.prototype.constructor = THREE.PointLight;
  THREE.PointLight.prototype.copy = function(source) {
    THREE.Light.prototype.copy.call(this, source);
    this.intensity = source.intensity;
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  };
  THREE.SpotLight = function(color, intensity, distance, angle, exponent, decay) {
    THREE.Light.call(this, color);
    this.type = 'SpotLight';
    this.position.set(0, 1, 0);
    this.updateMatrix();
    this.target = new THREE.Object3D();
    this.intensity = (intensity !== undefined) ? intensity : 1;
    this.distance = (distance !== undefined) ? distance : 0;
    this.angle = (angle !== undefined) ? angle : Math.PI / 3;
    this.exponent = (exponent !== undefined) ? exponent : 10;
    this.decay = (decay !== undefined) ? decay : 1;
    this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(50, 1, 50, 5000));
  };
  THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
  THREE.SpotLight.prototype.constructor = THREE.SpotLight;
  THREE.SpotLight.prototype.copy = function(source) {
    THREE.Light.prototype.copy.call(this, source);
    this.intensity = source.intensity;
    this.distance = source.distance;
    this.angle = source.angle;
    this.exponent = source.exponent;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  };
  THREE.Cache = {
    enabled: false,
    files: {},
    add: function(key, file) {
      if (this.enabled === false)
        return;
      this.files[key] = file;
    },
    get: function(key) {
      if (this.enabled === false)
        return;
      return this.files[key];
    },
    remove: function(key) {
      delete this.files[key];
    },
    clear: function() {
      this.files = {};
    }
  };
  THREE.Loader = function() {
    this.onLoadStart = function() {};
    this.onLoadProgress = function() {};
    this.onLoadComplete = function() {};
  };
  THREE.Loader.prototype = {
    constructor: THREE.Loader,
    crossOrigin: undefined,
    extractUrlBase: function(url) {
      var parts = url.split('/');
      if (parts.length === 1)
        return './';
      parts.pop();
      return parts.join('/') + '/';
    },
    initMaterials: function(materials, texturePath, crossOrigin) {
      var array = [];
      for (var i = 0; i < materials.length; ++i) {
        array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
      }
      return array;
    },
    createMaterial: (function() {
      var color,
          textureLoader,
          materialLoader;
      return function(m, texturePath, crossOrigin) {
        if (color === undefined)
          color = new THREE.Color();
        if (textureLoader === undefined)
          textureLoader = new THREE.TextureLoader();
        if (materialLoader === undefined)
          materialLoader = new THREE.MaterialLoader();
        var textures = {};
        function loadTexture(path, repeat, offset, wrap, anisotropy) {
          var fullPath = texturePath + path;
          var loader = THREE.Loader.Handlers.get(fullPath);
          var texture;
          if (loader !== null) {
            texture = loader.load(fullPath);
          } else {
            textureLoader.setCrossOrigin(crossOrigin);
            texture = textureLoader.load(fullPath);
          }
          if (repeat !== undefined) {
            texture.repeat.fromArray(repeat);
            if (repeat[0] !== 1)
              texture.wrapS = THREE.RepeatWrapping;
            if (repeat[1] !== 1)
              texture.wrapT = THREE.RepeatWrapping;
          }
          if (offset !== undefined) {
            texture.offset.fromArray(offset);
          }
          if (wrap !== undefined) {
            if (wrap[0] === 'repeat')
              texture.wrapS = THREE.RepeatWrapping;
            if (wrap[0] === 'mirror')
              texture.wrapS = THREE.MirroredRepeatWrapping;
            if (wrap[1] === 'repeat')
              texture.wrapT = THREE.RepeatWrapping;
            if (wrap[1] === 'mirror')
              texture.wrapT = THREE.MirroredRepeatWrapping;
          }
          if (anisotropy !== undefined) {
            texture.anisotropy = anisotropy;
          }
          var uuid = THREE.Math.generateUUID();
          textures[uuid] = texture;
          return uuid;
        }
        var json = {
          uuid: THREE.Math.generateUUID(),
          type: 'MeshLambertMaterial'
        };
        for (var name in m) {
          var value = m[name];
          switch (name) {
            case 'DbgColor':
              json.color = value;
              break;
            case 'DbgIndex':
            case 'opticalDensity':
            case 'illumination':
              break;
            case 'DbgName':
              json.name = value;
              break;
            case 'blending':
              json.blending = THREE[value];
              break;
            case 'colorDiffuse':
              json.color = color.fromArray(value).getHex();
              break;
            case 'colorSpecular':
              json.specular = color.fromArray(value).getHex();
              break;
            case 'colorEmissive':
              json.emissive = color.fromArray(value).getHex();
              break;
            case 'specularCoef':
              json.shininess = value;
              break;
            case 'shading':
              if (value.toLowerCase() === 'basic')
                json.type = 'MeshBasicMaterial';
              if (value.toLowerCase() === 'phong')
                json.type = 'MeshPhongMaterial';
              break;
            case 'mapDiffuse':
              json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
              break;
            case 'mapDiffuseRepeat':
            case 'mapDiffuseOffset':
            case 'mapDiffuseWrap':
            case 'mapDiffuseAnisotropy':
              break;
            case 'mapLight':
              json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
              break;
            case 'mapLightRepeat':
            case 'mapLightOffset':
            case 'mapLightWrap':
            case 'mapLightAnisotropy':
              break;
            case 'mapAO':
              json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
              break;
            case 'mapAORepeat':
            case 'mapAOOffset':
            case 'mapAOWrap':
            case 'mapAOAnisotropy':
              break;
            case 'mapBump':
              json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
              break;
            case 'mapBumpScale':
              json.bumpScale = value;
              break;
            case 'mapBumpRepeat':
            case 'mapBumpOffset':
            case 'mapBumpWrap':
            case 'mapBumpAnisotropy':
              break;
            case 'mapNormal':
              json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
              break;
            case 'mapNormalFactor':
              json.normalScale = [value, value];
              break;
            case 'mapNormalRepeat':
            case 'mapNormalOffset':
            case 'mapNormalWrap':
            case 'mapNormalAnisotropy':
              break;
            case 'mapSpecular':
              json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
              break;
            case 'mapSpecularRepeat':
            case 'mapSpecularOffset':
            case 'mapSpecularWrap':
            case 'mapSpecularAnisotropy':
              break;
            case 'mapAlpha':
              json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
              break;
            case 'mapAlphaRepeat':
            case 'mapAlphaOffset':
            case 'mapAlphaWrap':
            case 'mapAlphaAnisotropy':
              break;
            case 'flipSided':
              json.side = THREE.BackSide;
              break;
            case 'doubleSided':
              json.side = THREE.DoubleSide;
              break;
            case 'transparency':
              console.warn('THREE.Loader: transparency has been renamed to opacity');
              json.opacity = value;
              break;
            case 'opacity':
            case 'transparent':
            case 'depthTest':
            case 'depthWrite':
            case 'transparent':
            case 'visible':
            case 'wireframe':
              json[name] = value;
              break;
            case 'vertexColors':
              if (value === true)
                json.vertexColors = THREE.VertexColors;
              if (value === 'face')
                json.vertexColors = THREE.FaceColors;
              break;
            default:
              console.error('Loader.createMaterial: Unsupported', name, value);
              break;
          }
        }
        if (json.type !== 'MeshPhongMaterial')
          delete json.specular;
        if (json.opacity < 1)
          json.transparent = true;
        materialLoader.setTextures(textures);
        return materialLoader.parse(json);
      };
    })()
  };
  THREE.Loader.Handlers = {
    handlers: [],
    add: function(regex, loader) {
      this.handlers.push(regex, loader);
    },
    get: function(file) {
      var handlers = this.handlers;
      for (var i = 0,
          l = handlers.length; i < l; i += 2) {
        var regex = handlers[i];
        var loader = handlers[i + 1];
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    }
  };
  THREE.XHRLoader = function(manager) {
    this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
  };
  THREE.XHRLoader.prototype = {
    constructor: THREE.XHRLoader,
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var cached = THREE.Cache.get(url);
      if (cached !== undefined) {
        if (onLoad) {
          setTimeout(function() {
            onLoad(cached);
          }, 0);
        }
        return cached;
      }
      var request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.addEventListener('load', function(event) {
        var response = event.target.response;
        THREE.Cache.add(url, response);
        if (onLoad)
          onLoad(response);
        scope.manager.itemEnd(url);
      }, false);
      if (onProgress !== undefined) {
        request.addEventListener('progress', function(event) {
          onProgress(event);
        }, false);
      }
      request.addEventListener('error', function(event) {
        if (onError)
          onError(event);
        scope.manager.itemError(url);
      }, false);
      if (this.crossOrigin !== undefined)
        request.crossOrigin = this.crossOrigin;
      if (this.responseType !== undefined)
        request.responseType = this.responseType;
      if (this.withCredentials !== undefined)
        request.withCredentials = this.withCredentials;
      request.send(null);
      scope.manager.itemStart(url);
      return request;
    },
    setResponseType: function(value) {
      this.responseType = value;
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
    },
    setWithCredentials: function(value) {
      this.withCredentials = value;
    }
  };
  THREE.ImageLoader = function(manager) {
    this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
  };
  THREE.ImageLoader.prototype = {
    constructor: THREE.ImageLoader,
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var cached = THREE.Cache.get(url);
      if (cached !== undefined) {
        scope.manager.itemStart(url);
        if (onLoad) {
          setTimeout(function() {
            onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
        } else {
          scope.manager.itemEnd(url);
        }
        return cached;
      }
      var image = document.createElement('img');
      image.addEventListener('load', function(event) {
        THREE.Cache.add(url, this);
        if (onLoad)
          onLoad(this);
        scope.manager.itemEnd(url);
      }, false);
      if (onProgress !== undefined) {
        image.addEventListener('progress', function(event) {
          onProgress(event);
        }, false);
      }
      image.addEventListener('error', function(event) {
        if (onError)
          onError(event);
        scope.manager.itemError(url);
      }, false);
      if (this.crossOrigin !== undefined)
        image.crossOrigin = this.crossOrigin;
      scope.manager.itemStart(url);
      image.src = url;
      return image;
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
    }
  };
  THREE.JSONLoader = function(manager) {
    if (typeof manager === 'boolean') {
      console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
      manager = undefined;
    }
    this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    this.withCredentials = false;
  };
  THREE.JSONLoader.prototype = {
    constructor: THREE.JSONLoader,
    get statusDomElement() {
      if (this._statusDomElement === undefined) {
        this._statusDomElement = document.createElement('div');
      }
      console.warn('THREE.JSONLoader: .statusDomElement has been removed.');
      return this._statusDomElement;
    },
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var texturePath = this.texturePath && (typeof this.texturePath === "string") ? this.texturePath : THREE.Loader.prototype.extractUrlBase(url);
      var loader = new THREE.XHRLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function(text) {
        var json = JSON.parse(text);
        var metadata = json.metadata;
        if (metadata !== undefined) {
          if (metadata.type === 'object') {
            console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
            return;
          }
          if (metadata.type === 'scene') {
            console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');
            return;
          }
        }
        var object = scope.parse(json, texturePath);
        onLoad(object.geometry, object.materials);
      });
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
    },
    setTexturePath: function(value) {
      this.texturePath = value;
    },
    parse: function(json, texturePath) {
      var geometry = new THREE.Geometry(),
          scale = (json.scale !== undefined) ? 1.0 / json.scale : 1.0;
      parseModel(scale);
      parseSkin();
      parseMorphing(scale);
      parseAnimations();
      geometry.computeFaceNormals();
      geometry.computeBoundingSphere();
      function parseModel(scale) {
        function isBitSet(value, position) {
          return value & (1 << position);
        }
        var i,
            j,
            fi,
            offset,
            zLength,
            colorIndex,
            normalIndex,
            uvIndex,
            materialIndex,
            type,
            isQuad,
            hasMaterial,
            hasFaceVertexUv,
            hasFaceNormal,
            hasFaceVertexNormal,
            hasFaceColor,
            hasFaceVertexColor,
            vertex,
            face,
            faceA,
            faceB,
            hex,
            normal,
            uvLayer,
            uv,
            u,
            v,
            faces = json.faces,
            vertices = json.vertices,
            normals = json.normals,
            colors = json.colors,
            nUvLayers = 0;
        if (json.uvs !== undefined) {
          for (i = 0; i < json.uvs.length; i++) {
            if (json.uvs[i].length)
              nUvLayers++;
          }
          for (i = 0; i < nUvLayers; i++) {
            geometry.faceVertexUvs[i] = [];
          }
        }
        offset = 0;
        zLength = vertices.length;
        while (offset < zLength) {
          vertex = new THREE.Vector3();
          vertex.x = vertices[offset++] * scale;
          vertex.y = vertices[offset++] * scale;
          vertex.z = vertices[offset++] * scale;
          geometry.vertices.push(vertex);
        }
        offset = 0;
        zLength = faces.length;
        while (offset < zLength) {
          type = faces[offset++];
          isQuad = isBitSet(type, 0);
          hasMaterial = isBitSet(type, 1);
          hasFaceVertexUv = isBitSet(type, 3);
          hasFaceNormal = isBitSet(type, 4);
          hasFaceVertexNormal = isBitSet(type, 5);
          hasFaceColor = isBitSet(type, 6);
          hasFaceVertexColor = isBitSet(type, 7);
          if (isQuad) {
            faceA = new THREE.Face3();
            faceA.a = faces[offset];
            faceA.b = faces[offset + 1];
            faceA.c = faces[offset + 3];
            faceB = new THREE.Face3();
            faceB.a = faces[offset + 1];
            faceB.b = faces[offset + 2];
            faceB.c = faces[offset + 3];
            offset += 4;
            if (hasMaterial) {
              materialIndex = faces[offset++];
              faceA.materialIndex = materialIndex;
              faceB.materialIndex = materialIndex;
            }
            fi = geometry.faces.length;
            if (hasFaceVertexUv) {
              for (i = 0; i < nUvLayers; i++) {
                uvLayer = json.uvs[i];
                geometry.faceVertexUvs[i][fi] = [];
                geometry.faceVertexUvs[i][fi + 1] = [];
                for (j = 0; j < 4; j++) {
                  uvIndex = faces[offset++];
                  u = uvLayer[uvIndex * 2];
                  v = uvLayer[uvIndex * 2 + 1];
                  uv = new THREE.Vector2(u, v);
                  if (j !== 2)
                    geometry.faceVertexUvs[i][fi].push(uv);
                  if (j !== 0)
                    geometry.faceVertexUvs[i][fi + 1].push(uv);
                }
              }
            }
            if (hasFaceNormal) {
              normalIndex = faces[offset++] * 3;
              faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
              faceB.normal.copy(faceA.normal);
            }
            if (hasFaceVertexNormal) {
              for (i = 0; i < 4; i++) {
                normalIndex = faces[offset++] * 3;
                normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                if (i !== 2)
                  faceA.vertexNormals.push(normal);
                if (i !== 0)
                  faceB.vertexNormals.push(normal);
              }
            }
            if (hasFaceColor) {
              colorIndex = faces[offset++];
              hex = colors[colorIndex];
              faceA.color.setHex(hex);
              faceB.color.setHex(hex);
            }
            if (hasFaceVertexColor) {
              for (i = 0; i < 4; i++) {
                colorIndex = faces[offset++];
                hex = colors[colorIndex];
                if (i !== 2)
                  faceA.vertexColors.push(new THREE.Color(hex));
                if (i !== 0)
                  faceB.vertexColors.push(new THREE.Color(hex));
              }
            }
            geometry.faces.push(faceA);
            geometry.faces.push(faceB);
          } else {
            face = new THREE.Face3();
            face.a = faces[offset++];
            face.b = faces[offset++];
            face.c = faces[offset++];
            if (hasMaterial) {
              materialIndex = faces[offset++];
              face.materialIndex = materialIndex;
            }
            fi = geometry.faces.length;
            if (hasFaceVertexUv) {
              for (i = 0; i < nUvLayers; i++) {
                uvLayer = json.uvs[i];
                geometry.faceVertexUvs[i][fi] = [];
                for (j = 0; j < 3; j++) {
                  uvIndex = faces[offset++];
                  u = uvLayer[uvIndex * 2];
                  v = uvLayer[uvIndex * 2 + 1];
                  uv = new THREE.Vector2(u, v);
                  geometry.faceVertexUvs[i][fi].push(uv);
                }
              }
            }
            if (hasFaceNormal) {
              normalIndex = faces[offset++] * 3;
              face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
            }
            if (hasFaceVertexNormal) {
              for (i = 0; i < 3; i++) {
                normalIndex = faces[offset++] * 3;
                normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                face.vertexNormals.push(normal);
              }
            }
            if (hasFaceColor) {
              colorIndex = faces[offset++];
              face.color.setHex(colors[colorIndex]);
            }
            if (hasFaceVertexColor) {
              for (i = 0; i < 3; i++) {
                colorIndex = faces[offset++];
                face.vertexColors.push(new THREE.Color(colors[colorIndex]));
              }
            }
            geometry.faces.push(face);
          }
        }
      }
      ;
      function parseSkin() {
        var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;
        if (json.skinWeights) {
          for (var i = 0,
              l = json.skinWeights.length; i < l; i += influencesPerVertex) {
            var x = json.skinWeights[i];
            var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
            var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
            var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;
            geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));
          }
        }
        if (json.skinIndices) {
          for (var i = 0,
              l = json.skinIndices.length; i < l; i += influencesPerVertex) {
            var a = json.skinIndices[i];
            var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
            var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
            var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;
            geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));
          }
        }
        geometry.bones = json.bones;
        if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
          console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' + geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
        }
      }
      ;
      function parseMorphing(scale) {
        if (json.morphTargets !== undefined) {
          for (var i = 0,
              l = json.morphTargets.length; i < l; i++) {
            geometry.morphTargets[i] = {};
            geometry.morphTargets[i].name = json.morphTargets[i].name;
            geometry.morphTargets[i].vertices = [];
            var dstVertices = geometry.morphTargets[i].vertices;
            var srcVertices = json.morphTargets[i].vertices;
            for (var v = 0,
                vl = srcVertices.length; v < vl; v += 3) {
              var vertex = new THREE.Vector3();
              vertex.x = srcVertices[v] * scale;
              vertex.y = srcVertices[v + 1] * scale;
              vertex.z = srcVertices[v + 2] * scale;
              dstVertices.push(vertex);
            }
          }
        }
        if (json.morphColors !== undefined && json.morphColors.length > 0) {
          console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
          var faces = geometry.faces;
          var morphColors = json.morphColors[0].colors;
          for (var i = 0,
              l = faces.length; i < l; i++) {
            faces[i].color.fromArray(morphColors, i * 3);
          }
        }
      }
      function parseAnimations() {
        var outputAnimations = [];
        var animations = [];
        if (json.animation !== undefined) {
          animations.push(json.animation);
        }
        if (json.animations !== undefined) {
          if (json.animations.length) {
            animations = animations.concat(json.animations);
          } else {
            animations.push(json.animations);
          }
        }
        for (var i = 0; i < animations.length; i++) {
          var clip = THREE.AnimationClip.parseAnimation(animations[i], geometry.bones);
          if (clip)
            outputAnimations.push(clip);
        }
        if (geometry.morphTargets) {
          var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
          outputAnimations = outputAnimations.concat(morphAnimationClips);
        }
        if (outputAnimations.length > 0)
          geometry.animations = outputAnimations;
      }
      ;
      if (json.materials === undefined || json.materials.length === 0) {
        return {geometry: geometry};
      } else {
        var materials = THREE.Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
        return {
          geometry: geometry,
          materials: materials
        };
      }
    }
  };
  THREE.LoadingManager = function(onLoad, onProgress, onError) {
    var scope = this;
    var isLoading = false,
        itemsLoaded = 0,
        itemsTotal = 0;
    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== undefined) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== undefined) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== undefined) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== undefined) {
        scope.onError(url);
      }
    };
  };
  THREE.DefaultLoadingManager = new THREE.LoadingManager();
  THREE.BufferGeometryLoader = function(manager) {
    this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
  };
  THREE.BufferGeometryLoader.prototype = {
    constructor: THREE.BufferGeometryLoader,
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new THREE.XHRLoader(scope.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.load(url, function(text) {
        onLoad(scope.parse(JSON.parse(text)));
      }, onProgress, onError);
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
    },
    parse: function(json) {
      var geometry = new THREE.BufferGeometry();
      var index = json.data.index;
      if (index !== undefined) {
        var typedArray = new self[index.type](index.array);
        geometry.setIndex(new THREE.BufferAttribute(typedArray, 1));
      }
      var attributes = json.data.attributes;
      for (var key in attributes) {
        var attribute = attributes[key];
        var typedArray = new self[attribute.type](attribute.array);
        geometry.addAttribute(key, new THREE.BufferAttribute(typedArray, attribute.itemSize));
      }
      var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
      if (groups !== undefined) {
        for (var i = 0,
            n = groups.length; i !== n; ++i) {
          var group = groups[i];
          geometry.addGroup(group.start, group.count);
        }
      }
      var boundingSphere = json.data.boundingSphere;
      if (boundingSphere !== undefined) {
        var center = new THREE.Vector3();
        if (boundingSphere.center !== undefined) {
          center.fromArray(boundingSphere.center);
        }
        geometry.boundingSphere = new THREE.Sphere(center, boundingSphere.radius);
      }
      return geometry;
    }
  };
  THREE.MaterialLoader = function(manager) {
    this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    this.textures = {};
  };
  THREE.MaterialLoader.prototype = {
    constructor: THREE.MaterialLoader,
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new THREE.XHRLoader(scope.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.load(url, function(text) {
        onLoad(scope.parse(JSON.parse(text)));
      }, onProgress, onError);
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
    },
    setTextures: function(value) {
      this.textures = value;
    },
    getTexture: function(name) {
      var textures = this.textures;
      if (textures[name] === undefined) {
        console.warn('THREE.MaterialLoader: Undefined texture', name);
      }
      return textures[name];
    },
    parse: function(json) {
      var material = new THREE[json.type];
      material.uuid = json.uuid;
      if (json.name !== undefined)
        material.name = json.name;
      if (json.color !== undefined)
        material.color.setHex(json.color);
      if (json.emissive !== undefined)
        material.emissive.setHex(json.emissive);
      if (json.specular !== undefined)
        material.specular.setHex(json.specular);
      if (json.shininess !== undefined)
        material.shininess = json.shininess;
      if (json.uniforms !== undefined)
        material.uniforms = json.uniforms;
      if (json.vertexShader !== undefined)
        material.vertexShader = json.vertexShader;
      if (json.fragmentShader !== undefined)
        material.fragmentShader = json.fragmentShader;
      if (json.vertexColors !== undefined)
        material.vertexColors = json.vertexColors;
      if (json.shading !== undefined)
        material.shading = json.shading;
      if (json.blending !== undefined)
        material.blending = json.blending;
      if (json.side !== undefined)
        material.side = json.side;
      if (json.opacity !== undefined)
        material.opacity = json.opacity;
      if (json.transparent !== undefined)
        material.transparent = json.transparent;
      if (json.alphaTest !== undefined)
        material.alphaTest = json.alphaTest;
      if (json.depthTest !== undefined)
        material.depthTest = json.depthTest;
      if (json.depthWrite !== undefined)
        material.depthWrite = json.depthWrite;
      if (json.wireframe !== undefined)
        material.wireframe = json.wireframe;
      if (json.wireframeLinewidth !== undefined)
        material.wireframeLinewidth = json.wireframeLinewidth;
      if (json.size !== undefined)
        material.size = json.size;
      if (json.sizeAttenuation !== undefined)
        material.sizeAttenuation = json.sizeAttenuation;
      if (json.map !== undefined)
        material.map = this.getTexture(json.map);
      if (json.alphaMap !== undefined) {
        material.alphaMap = this.getTexture(json.alphaMap);
        material.transparent = true;
      }
      if (json.bumpMap !== undefined)
        material.bumpMap = this.getTexture(json.bumpMap);
      if (json.bumpScale !== undefined)
        material.bumpScale = json.bumpScale;
      if (json.normalMap !== undefined)
        material.normalMap = this.getTexture(json.normalMap);
      if (json.normalScale)
        material.normalScale = new THREE.Vector2(json.normalScale, json.normalScale);
      if (json.displacementMap !== undefined)
        material.displacementMap = this.getTexture(json.displacementMap);
      if (json.displacementScale !== undefined)
        material.displacementScale = json.displacementScale;
      if (json.displacementBias !== undefined)
        material.displacementBias = json.displacementBias;
      if (json.specularMap !== undefined)
        material.specularMap = this.getTexture(json.specularMap);
      if (json.envMap !== undefined) {
        material.envMap = this.getTexture(json.envMap);
        material.combine = THREE.MultiplyOperation;
      }
      if (json.reflectivity)
        material.reflectivity = json.reflectivity;
      if (json.lightMap !== undefined)
        material.lightMap = this.getTexture(json.lightMap);
      if (json.lightMapIntensity !== undefined)
        material.lightMapIntensity = json.lightMapIntensity;
      if (json.aoMap !== undefined)
        material.aoMap = this.getTexture(json.aoMap);
      if (json.aoMapIntensity !== undefined)
        material.aoMapIntensity = json.aoMapIntensity;
      if (json.materials !== undefined) {
        for (var i = 0,
            l = json.materials.length; i < l; i++) {
          material.materials.push(this.parse(json.materials[i]));
        }
      }
      return material;
    }
  };
  THREE.ObjectLoader = function(manager) {
    this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    this.texturePath = '';
  };
  THREE.ObjectLoader.prototype = {
    constructor: THREE.ObjectLoader,
    load: function(url, onLoad, onProgress, onError) {
      if (this.texturePath === '') {
        this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
      }
      var scope = this;
      var loader = new THREE.XHRLoader(scope.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.load(url, function(text) {
        scope.parse(JSON.parse(text), onLoad);
      }, onProgress, onError);
    },
    setTexturePath: function(value) {
      this.texturePath = value;
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
    },
    parse: function(json, onLoad) {
      var geometries = this.parseGeometries(json.geometries);
      var images = this.parseImages(json.images, function() {
        if (onLoad !== undefined)
          onLoad(object);
      });
      var textures = this.parseTextures(json.textures, images);
      var materials = this.parseMaterials(json.materials, textures);
      var object = this.parseObject(json.object, geometries, materials);
      if (json.animations) {
        object.animations = this.parseAnimations(json.animations);
      }
      if (json.images === undefined || json.images.length === 0) {
        if (onLoad !== undefined)
          onLoad(object);
      }
      return object;
    },
    parseGeometries: function(json) {
      var geometries = {};
      if (json !== undefined) {
        var geometryLoader = new THREE.JSONLoader();
        var bufferGeometryLoader = new THREE.BufferGeometryLoader();
        for (var i = 0,
            l = json.length; i < l; i++) {
          var geometry;
          var data = json[i];
          switch (data.type) {
            case 'PlaneGeometry':
            case 'PlaneBufferGeometry':
              geometry = new THREE[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
              break;
            case 'BoxGeometry':
            case 'CubeGeometry':
              geometry = new THREE.BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
              break;
            case 'CircleBufferGeometry':
              geometry = new THREE.CircleBufferGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
              break;
            case 'CircleGeometry':
              geometry = new THREE.CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
              break;
            case 'CylinderGeometry':
              geometry = new THREE.CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
              break;
            case 'SphereGeometry':
              geometry = new THREE.SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
              break;
            case 'SphereBufferGeometry':
              geometry = new THREE.SphereBufferGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
              break;
            case 'DodecahedronGeometry':
              geometry = new THREE.DodecahedronGeometry(data.radius, data.detail);
              break;
            case 'IcosahedronGeometry':
              geometry = new THREE.IcosahedronGeometry(data.radius, data.detail);
              break;
            case 'OctahedronGeometry':
              geometry = new THREE.OctahedronGeometry(data.radius, data.detail);
              break;
            case 'TetrahedronGeometry':
              geometry = new THREE.TetrahedronGeometry(data.radius, data.detail);
              break;
            case 'RingGeometry':
              geometry = new THREE.RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
              break;
            case 'TorusGeometry':
              geometry = new THREE.TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
              break;
            case 'TorusKnotGeometry':
              geometry = new THREE.TorusKnotGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.p, data.q, data.heightScale);
              break;
            case 'BufferGeometry':
              geometry = bufferGeometryLoader.parse(data);
              break;
            case 'Geometry':
              geometry = geometryLoader.parse(data.data, this.texturePath).geometry;
              break;
            default:
              console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
              continue;
          }
          geometry.uuid = data.uuid;
          if (data.name !== undefined)
            geometry.name = data.name;
          geometries[data.uuid] = geometry;
        }
      }
      return geometries;
    },
    parseMaterials: function(json, textures) {
      var materials = {};
      if (json !== undefined) {
        var loader = new THREE.MaterialLoader();
        loader.setTextures(textures);
        for (var i = 0,
            l = json.length; i < l; i++) {
          var material = loader.parse(json[i]);
          materials[material.uuid] = material;
        }
      }
      return materials;
    },
    parseAnimations: function(json) {
      var animations = [];
      for (var i = 0; i < json.length; i++) {
        var clip = THREE.AnimationClip.parse(json[i]);
        animations.push(clip);
      }
      return animations;
    },
    parseImages: function(json, onLoad) {
      var scope = this;
      var images = {};
      function loadImage(url) {
        scope.manager.itemStart(url);
        return loader.load(url, function() {
          scope.manager.itemEnd(url);
        });
      }
      if (json !== undefined && json.length > 0) {
        var manager = new THREE.LoadingManager(onLoad);
        var loader = new THREE.ImageLoader(manager);
        loader.setCrossOrigin(this.crossOrigin);
        for (var i = 0,
            l = json.length; i < l; i++) {
          var image = json[i];
          var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
          images[image.uuid] = loadImage(path);
        }
      }
      return images;
    },
    parseTextures: function(json, images) {
      function parseConstant(value) {
        if (typeof(value) === 'number')
          return value;
        console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
        return THREE[value];
      }
      var textures = {};
      if (json !== undefined) {
        for (var i = 0,
            l = json.length; i < l; i++) {
          var data = json[i];
          if (data.image === undefined) {
            console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
          }
          if (images[data.image] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined image', data.image);
          }
          var texture = new THREE.Texture(images[data.image]);
          texture.needsUpdate = true;
          texture.uuid = data.uuid;
          if (data.name !== undefined)
            texture.name = data.name;
          if (data.mapping !== undefined)
            texture.mapping = parseConstant(data.mapping);
          if (data.offset !== undefined)
            texture.offset = new THREE.Vector2(data.offset[0], data.offset[1]);
          if (data.repeat !== undefined)
            texture.repeat = new THREE.Vector2(data.repeat[0], data.repeat[1]);
          if (data.minFilter !== undefined)
            texture.minFilter = parseConstant(data.minFilter);
          if (data.magFilter !== undefined)
            texture.magFilter = parseConstant(data.magFilter);
          if (data.anisotropy !== undefined)
            texture.anisotropy = data.anisotropy;
          if (Array.isArray(data.wrap)) {
            texture.wrapS = parseConstant(data.wrap[0]);
            texture.wrapT = parseConstant(data.wrap[1]);
          }
          textures[data.uuid] = texture;
        }
      }
      return textures;
    },
    parseObject: function() {
      var matrix = new THREE.Matrix4();
      return function(data, geometries, materials) {
        var object;
        function getGeometry(name) {
          if (geometries[name] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined geometry', name);
          }
          return geometries[name];
        }
        function getMaterial(name) {
          if (name === undefined)
            return undefined;
          if (materials[name] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined material', name);
          }
          return materials[name];
        }
        switch (data.type) {
          case 'Scene':
            object = new THREE.Scene();
            break;
          case 'PerspectiveCamera':
            object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
            break;
          case 'OrthographicCamera':
            object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
            break;
          case 'AmbientLight':
            object = new THREE.AmbientLight(data.color);
            break;
          case 'DirectionalLight':
            object = new THREE.DirectionalLight(data.color, data.intensity);
            break;
          case 'PointLight':
            object = new THREE.PointLight(data.color, data.intensity, data.distance, data.decay);
            break;
          case 'SpotLight':
            object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay);
            break;
          case 'HemisphereLight':
            object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);
            break;
          case 'Mesh':
            object = new THREE.Mesh(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case 'LOD':
            object = new THREE.LOD();
            break;
          case 'Line':
            object = new THREE.Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
            break;
          case 'PointCloud':
          case 'Points':
            object = new THREE.Points(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case 'Sprite':
            object = new THREE.Sprite(getMaterial(data.material));
            break;
          case 'Group':
            object = new THREE.Group();
            break;
          default:
            object = new THREE.Object3D();
        }
        object.uuid = data.uuid;
        if (data.name !== undefined)
          object.name = data.name;
        if (data.matrix !== undefined) {
          matrix.fromArray(data.matrix);
          matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
          if (data.position !== undefined)
            object.position.fromArray(data.position);
          if (data.rotation !== undefined)
            object.rotation.fromArray(data.rotation);
          if (data.scale !== undefined)
            object.scale.fromArray(data.scale);
        }
        if (data.castShadow !== undefined)
          object.castShadow = data.castShadow;
        if (data.receiveShadow !== undefined)
          object.receiveShadow = data.receiveShadow;
        if (data.visible !== undefined)
          object.visible = data.visible;
        if (data.userData !== undefined)
          object.userData = data.userData;
        if (data.children !== undefined) {
          for (var child in data.children) {
            object.add(this.parseObject(data.children[child], geometries, materials));
          }
        }
        if (data.type === 'LOD') {
          var levels = data.levels;
          for (var l = 0; l < levels.length; l++) {
            var level = levels[l];
            var child = object.getObjectByProperty('uuid', level.object);
            if (child !== undefined) {
              object.addLevel(child, level.distance);
            }
          }
        }
        return object;
      };
    }()
  };
  THREE.TextureLoader = function(manager) {
    this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
  };
  THREE.TextureLoader.prototype = {
    constructor: THREE.TextureLoader,
    load: function(url, onLoad, onProgress, onError) {
      var texture = new THREE.Texture();
      var loader = new THREE.ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.load(url, function(image) {
        texture.image = image;
        texture.needsUpdate = true;
        if (onLoad !== undefined) {
          onLoad(texture);
        }
      }, onProgress, onError);
      return texture;
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
    }
  };
  THREE.CubeTextureLoader = function(manager) {
    this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
  };
  THREE.CubeTextureLoader.prototype = {
    constructor: THREE.CubeTextureLoader,
    load: function(urls, onLoad, onProgress, onError) {
      var texture = new THREE.CubeTexture([]);
      var loader = new THREE.ImageLoader();
      loader.setCrossOrigin(this.crossOrigin);
      var loaded = 0;
      function loadTexture(i) {
        loader.load(urls[i], function(image) {
          texture.images[i] = image;
          loaded++;
          if (loaded === 6) {
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }
        }, undefined, onError);
      }
      for (var i = 0; i < urls.length; ++i) {
        loadTexture(i);
      }
      return texture;
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
    }
  };
  THREE.DataTextureLoader = THREE.BinaryTextureLoader = function(manager) {
    this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    this._parser = null;
  };
  THREE.BinaryTextureLoader.prototype = {
    constructor: THREE.BinaryTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var texture = new THREE.DataTexture();
      var loader = new THREE.XHRLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setResponseType('arraybuffer');
      loader.load(url, function(buffer) {
        var texData = scope._parser(buffer);
        if (!texData)
          return;
        if (undefined !== texData.image) {
          texture.image = texData.image;
        } else if (undefined !== texData.data) {
          texture.image.width = texData.width;
          texture.image.height = texData.height;
          texture.image.data = texData.data;
        }
        texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
        texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;
        texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
        texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;
        texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
        if (undefined !== texData.format) {
          texture.format = texData.format;
        }
        if (undefined !== texData.type) {
          texture.type = texData.type;
        }
        if (undefined !== texData.mipmaps) {
          texture.mipmaps = texData.mipmaps;
        }
        if (1 === texData.mipmapCount) {
          texture.minFilter = THREE.LinearFilter;
        }
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture, texData);
      }, onProgress, onError);
      return texture;
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
    }
  };
  THREE.CompressedTextureLoader = function(manager) {
    this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    this._parser = null;
  };
  THREE.CompressedTextureLoader.prototype = {
    constructor: THREE.CompressedTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var images = [];
      var texture = new THREE.CompressedTexture();
      texture.image = images;
      var loader = new THREE.XHRLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setResponseType('arraybuffer');
      if (Array.isArray(url)) {
        var loaded = 0;
        var loadTexture = function(i) {
          loader.load(url[i], function(buffer) {
            var texDatas = scope._parser(buffer, true);
            images[i] = {
              width: texDatas.width,
              height: texDatas.height,
              format: texDatas.format,
              mipmaps: texDatas.mipmaps
            };
            loaded += 1;
            if (loaded === 6) {
              if (texDatas.mipmapCount === 1)
                texture.minFilter = THREE.LinearFilter;
              texture.format = texDatas.format;
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, onProgress, onError);
        };
        for (var i = 0,
            il = url.length; i < il; ++i) {
          loadTexture(i);
        }
      } else {
        loader.load(url, function(buffer) {
          var texDatas = scope._parser(buffer, true);
          if (texDatas.isCubemap) {
            var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
            for (var f = 0; f < faces; f++) {
              images[f] = {mipmaps: []};
              for (var i = 0; i < texDatas.mipmapCount; i++) {
                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                images[f].format = texDatas.format;
                images[f].width = texDatas.width;
                images[f].height = texDatas.height;
              }
            }
          } else {
            texture.image.width = texDatas.width;
            texture.image.height = texDatas.height;
            texture.mipmaps = texDatas.mipmaps;
          }
          if (texDatas.mipmapCount === 1) {
            texture.minFilter = THREE.LinearFilter;
          }
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }, onProgress, onError);
      }
      return texture;
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
    }
  };
  THREE.Material = function() {
    Object.defineProperty(this, 'id', {value: THREE.MaterialIdCount++});
    this.uuid = THREE.Math.generateUUID();
    this.name = '';
    this.type = 'Material';
    this.side = THREE.FrontSide;
    this.opacity = 1;
    this.transparent = false;
    this.blending = THREE.NormalBlending;
    this.blendSrc = THREE.SrcAlphaFactor;
    this.blendDst = THREE.OneMinusSrcAlphaFactor;
    this.blendEquation = THREE.AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = THREE.LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.alphaTest = 0;
    this.overdraw = 0;
    this.visible = true;
    this._needsUpdate = true;
  };
  THREE.Material.prototype = {
    constructor: THREE.Material,
    get needsUpdate() {
      return this._needsUpdate;
    },
    set needsUpdate(value) {
      if (value === true)
        this.update();
      this._needsUpdate = value;
    },
    setValues: function(values) {
      if (values === undefined)
        return;
      for (var key in values) {
        var newValue = values[key];
        if (newValue === undefined) {
          console.warn("THREE.Material: '" + key + "' parameter is undefined.");
          continue;
        }
        var currentValue = this[key];
        if (currentValue === undefined) {
          console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
          continue;
        }
        if (currentValue instanceof THREE.Color) {
          currentValue.set(newValue);
        } else if (currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3) {
          currentValue.copy(newValue);
        } else if (key === 'overdraw') {
          this[key] = Number(newValue);
        } else {
          this[key] = newValue;
        }
      }
    },
    toJSON: function(meta) {
      var data = {metadata: {
          version: 4.4,
          type: 'Material',
          generator: 'Material.toJSON'
        }};
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== '')
        data.name = this.name;
      if (this.color instanceof THREE.Color)
        data.color = this.color.getHex();
      if (this.emissive instanceof THREE.Color)
        data.emissive = this.emissive.getHex();
      if (this.specular instanceof THREE.Color)
        data.specular = this.specular.getHex();
      if (this.shininess !== undefined)
        data.shininess = this.shininess;
      if (this.map instanceof THREE.Texture)
        data.map = this.map.toJSON(meta).uuid;
      if (this.alphaMap instanceof THREE.Texture)
        data.alphaMap = this.alphaMap.toJSON(meta).uuid;
      if (this.lightMap instanceof THREE.Texture)
        data.lightMap = this.lightMap.toJSON(meta).uuid;
      if (this.bumpMap instanceof THREE.Texture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }
      if (this.normalMap instanceof THREE.Texture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalScale = this.normalScale;
      }
      if (this.displacementMap instanceof THREE.Texture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }
      if (this.specularMap instanceof THREE.Texture)
        data.specularMap = this.specularMap.toJSON(meta).uuid;
      if (this.envMap instanceof THREE.Texture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        data.reflectivity = this.reflectivity;
      }
      if (this.size !== undefined)
        data.size = this.size;
      if (this.sizeAttenuation !== undefined)
        data.sizeAttenuation = this.sizeAttenuation;
      if (this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors)
        data.vertexColors = this.vertexColors;
      if (this.shading !== undefined && this.shading !== THREE.SmoothShading)
        data.shading = this.shading;
      if (this.blending !== undefined && this.blending !== THREE.NormalBlending)
        data.blending = this.blending;
      if (this.side !== undefined && this.side !== THREE.FrontSide)
        data.side = this.side;
      if (this.opacity < 1)
        data.opacity = this.opacity;
      if (this.transparent === true)
        data.transparent = this.transparent;
      if (this.alphaTest > 0)
        data.alphaTest = this.alphaTest;
      if (this.wireframe === true)
        data.wireframe = this.wireframe;
      if (this.wireframeLinewidth > 1)
        data.wireframeLinewidth = this.wireframeLinewidth;
      return data;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.name = source.name;
      this.side = source.side;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.blending = source.blending;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.alphaTest = source.alphaTest;
      this.overdraw = source.overdraw;
      this.visible = source.visible;
      return this;
    },
    update: function() {
      this.dispatchEvent({type: 'update'});
    },
    dispose: function() {
      this.dispatchEvent({type: 'dispose'});
    },
    get wrapAround() {
      console.warn('THREE.' + this.type + ': .wrapAround has been removed.');
    },
    set wrapAround(boolean) {
      console.warn('THREE.' + this.type + ': .wrapAround has been removed.');
    },
    get wrapRGB() {
      console.warn('THREE.' + this.type + ': .wrapRGB has been removed.');
      return new THREE.Color();
    }
  };
  THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
  THREE.MaterialIdCount = 0;
  THREE.LineBasicMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = 'LineBasicMaterial';
    this.color = new THREE.Color(0xffffff);
    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';
    this.vertexColors = THREE.NoColors;
    this.fog = true;
    this.setValues(parameters);
  };
  THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
  THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
  THREE.LineBasicMaterial.prototype.copy = function(source) {
    THREE.Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.vertexColors = source.vertexColors;
    this.fog = source.fog;
    return this;
  };
  THREE.LineDashedMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = 'LineDashedMaterial';
    this.color = new THREE.Color(0xffffff);
    this.linewidth = 1;
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.vertexColors = false;
    this.fog = true;
    this.setValues(parameters);
  };
  THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
  THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
  THREE.LineDashedMaterial.prototype.copy = function(source) {
    THREE.Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    this.vertexColors = source.vertexColors;
    this.fog = source.fog;
    return this;
  };
  THREE.MeshBasicMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = 'MeshBasicMaterial';
    this.color = new THREE.Color(0xffffff);
    this.map = null;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.fog = true;
    this.shading = THREE.SmoothShading;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.vertexColors = THREE.NoColors;
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
  };
  THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
  THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
  THREE.MeshBasicMaterial.prototype.copy = function(source) {
    THREE.Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.fog = source.fog;
    this.shading = source.shading;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.vertexColors = source.vertexColors;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
  };
  THREE.MeshLambertMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = 'MeshLambertMaterial';
    this.color = new THREE.Color(0xffffff);
    this.emissive = new THREE.Color(0x000000);
    this.map = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.fog = true;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.vertexColors = THREE.NoColors;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  };
  THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
  THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
  THREE.MeshLambertMaterial.prototype.copy = function(source) {
    THREE.Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.emissive.copy(source.emissive);
    this.map = source.map;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.fog = source.fog;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.vertexColors = source.vertexColors;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };
  THREE.MeshPhongMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = 'MeshPhongMaterial';
    this.color = new THREE.Color(0xffffff);
    this.emissive = new THREE.Color(0x000000);
    this.specular = new THREE.Color(0x111111);
    this.shininess = 30;
    this.metal = false;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalScale = new THREE.Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.fog = true;
    this.shading = THREE.SmoothShading;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.vertexColors = THREE.NoColors;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  };
  THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
  THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
  THREE.MeshPhongMaterial.prototype.copy = function(source) {
    THREE.Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.emissive.copy(source.emissive);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.metal = source.metal;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissiveMap = source.emissiveMap;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.fog = source.fog;
    this.shading = source.shading;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.vertexColors = source.vertexColors;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };
  THREE.MeshDepthMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = 'MeshDepthMaterial';
    this.morphTargets = false;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.setValues(parameters);
  };
  THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
  THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
  THREE.MeshDepthMaterial.prototype.copy = function(source) {
    THREE.Material.prototype.copy.call(this, source);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  };
  THREE.MeshNormalMaterial = function(parameters) {
    THREE.Material.call(this, parameters);
    this.type = 'MeshNormalMaterial';
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.morphTargets = false;
    this.setValues(parameters);
  };
  THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
  THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
  THREE.MeshNormalMaterial.prototype.copy = function(source) {
    THREE.Material.prototype.copy.call(this, source);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  };
  THREE.MultiMaterial = function(materials) {
    this.uuid = THREE.Math.generateUUID();
    this.type = 'MultiMaterial';
    this.materials = materials instanceof Array ? materials : [];
    this.visible = true;
  };
  THREE.MultiMaterial.prototype = {
    constructor: THREE.MultiMaterial,
    toJSON: function() {
      var output = {
        metadata: {
          version: 4.2,
          type: 'material',
          generator: 'MaterialExporter'
        },
        uuid: this.uuid,
        type: this.type,
        materials: []
      };
      for (var i = 0,
          l = this.materials.length; i < l; i++) {
        output.materials.push(this.materials[i].toJSON());
      }
      output.visible = this.visible;
      return output;
    },
    clone: function() {
      var material = new this.constructor();
      for (var i = 0; i < this.materials.length; i++) {
        material.materials.push(this.materials[i].clone());
      }
      material.visible = this.visible;
      return material;
    }
  };
  THREE.MeshFaceMaterial = THREE.MultiMaterial;
  THREE.PointsMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = 'PointsMaterial';
    this.color = new THREE.Color(0xffffff);
    this.map = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.vertexColors = THREE.NoColors;
    this.fog = true;
    this.setValues(parameters);
  };
  THREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype);
  THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;
  THREE.PointsMaterial.prototype.copy = function(source) {
    THREE.Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.vertexColors = source.vertexColors;
    this.fog = source.fog;
    return this;
  };
  THREE.PointCloudMaterial = function(parameters) {
    console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
    return new THREE.PointsMaterial(parameters);
  };
  THREE.ParticleBasicMaterial = function(parameters) {
    console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
    return new THREE.PointsMaterial(parameters);
  };
  THREE.ParticleSystemMaterial = function(parameters) {
    console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
    return new THREE.PointsMaterial(parameters);
  };
  THREE.ShaderMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = 'ShaderMaterial';
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
    this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
    this.shading = THREE.SmoothShading;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.vertexColors = THREE.NoColors;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.derivatives = false;
    this.defaultAttributeValues = {
      'color': [1, 1, 1],
      'uv': [0, 0],
      'uv2': [0, 0]
    };
    this.index0AttributeName = undefined;
    if (parameters !== undefined) {
      if (parameters.attributes !== undefined) {
        console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
      }
      this.setValues(parameters);
    }
  };
  THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
  THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
  THREE.ShaderMaterial.prototype.copy = function(source) {
    THREE.Material.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = THREE.UniformsUtils.clone(source.uniforms);
    this.attributes = source.attributes;
    this.defines = source.defines;
    this.shading = source.shading;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.fog = source.fog;
    this.lights = source.lights;
    this.vertexColors = source.vertexColors;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.derivatives = source.derivatives;
    return this;
  };
  THREE.ShaderMaterial.prototype.toJSON = function(meta) {
    var data = THREE.Material.prototype.toJSON.call(this, meta);
    data.uniforms = this.uniforms;
    data.attributes = this.attributes;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    return data;
  };
  THREE.RawShaderMaterial = function(parameters) {
    THREE.ShaderMaterial.call(this, parameters);
    this.type = 'RawShaderMaterial';
  };
  THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
  THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
  THREE.SpriteMaterial = function(parameters) {
    THREE.Material.call(this);
    this.type = 'SpriteMaterial';
    this.color = new THREE.Color(0xffffff);
    this.map = null;
    this.rotation = 0;
    this.fog = false;
    this.setValues(parameters);
  };
  THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
  THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
  THREE.SpriteMaterial.prototype.copy = function(source) {
    THREE.Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.rotation = source.rotation;
    this.fog = source.fog;
    return this;
  };
  THREE.Texture = function(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Object.defineProperty(this, 'id', {value: THREE.TextureIdCount++});
    this.uuid = THREE.Math.generateUUID();
    this.name = '';
    this.sourceFile = '';
    this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;
    this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
    this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
    this.format = format !== undefined ? format : THREE.RGBAFormat;
    this.type = type !== undefined ? type : THREE.UnsignedByteType;
    this.offset = new THREE.Vector2(0, 0);
    this.repeat = new THREE.Vector2(1, 1);
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.version = 0;
    this.onUpdate = null;
  };
  THREE.Texture.DEFAULT_IMAGE = undefined;
  THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
  THREE.Texture.prototype = {
    constructor: THREE.Texture,
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.image = source.image;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      return this;
    },
    toJSON: function(meta) {
      if (meta.textures[this.uuid] !== undefined) {
        return meta.textures[this.uuid];
      }
      function getDataURL(image) {
        var canvas;
        if (image.toDataURL !== undefined) {
          canvas = image;
        } else {
          canvas = document.createElement('canvas');
          canvas.width = image.width;
          canvas.height = image.height;
          canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
          return canvas.toDataURL('image/jpeg', 0.6);
        } else {
          return canvas.toDataURL('image/png');
        }
      }
      var output = {
        metadata: {
          version: 4.4,
          type: 'Texture',
          generator: 'Texture.toJSON'
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        wrap: [this.wrapS, this.wrapT],
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy
      };
      if (this.image !== undefined) {
        var image = this.image;
        if (image.uuid === undefined) {
          image.uuid = THREE.Math.generateUUID();
        }
        if (meta.images[image.uuid] === undefined) {
          meta.images[image.uuid] = {
            uuid: image.uuid,
            url: getDataURL(image)
          };
        }
        output.image = image.uuid;
      }
      meta.textures[this.uuid] = output;
      return output;
    },
    dispose: function() {
      this.dispatchEvent({type: 'dispose'});
    },
    transformUv: function(uv) {
      if (this.mapping !== THREE.UVMapping)
        return;
      uv.multiply(this.repeat);
      uv.add(this.offset);
      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case THREE.RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;
          case THREE.ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;
          case THREE.MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }
            break;
        }
      }
      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case THREE.RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;
          case THREE.ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;
          case THREE.MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }
            break;
        }
      }
      if (this.flipY) {
        uv.y = 1 - uv.y;
      }
    }
  };
  THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
  THREE.TextureIdCount = 0;
  THREE.CanvasTexture = function(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    THREE.Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  };
  THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
  THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;
  THREE.CubeTexture = function(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
    THREE.Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.images = images;
    this.flipY = false;
  };
  THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);
  THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
  THREE.CubeTexture.prototype.copy = function(source) {
    THREE.Texture.prototype.copy.call(this, source);
    this.images = source.images;
    return this;
  };
  THREE.CompressedTexture = function(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
    THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {
      width: width,
      height: height
    };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  };
  THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
  THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
  THREE.DataTexture = function(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
    THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {
      data: data,
      width: width,
      height: height
    };
    this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  };
  THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
  THREE.DataTexture.prototype.constructor = THREE.DataTexture;
  THREE.VideoTexture = function(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    THREE.Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.generateMipmaps = false;
    var scope = this;
    function update() {
      requestAnimationFrame(update);
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        scope.needsUpdate = true;
      }
    }
    update();
  };
  THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);
  THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
  THREE.Group = function() {
    THREE.Object3D.call(this);
    this.type = 'Group';
  };
  THREE.Group.prototype = Object.create(THREE.Object3D.prototype);
  THREE.Group.prototype.constructor = THREE.Group;
  THREE.Points = function(geometry, material) {
    THREE.Object3D.call(this);
    this.type = 'Points';
    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.PointsMaterial({color: Math.random() * 0xffffff});
  };
  THREE.Points.prototype = Object.create(THREE.Object3D.prototype);
  THREE.Points.prototype.constructor = THREE.Points;
  THREE.Points.prototype.raycast = (function() {
    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    return function raycast(raycaster, intersects) {
      var object = this;
      var geometry = object.geometry;
      var threshold = raycaster.params.Points.threshold;
      inverseMatrix.getInverse(this.matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      if (geometry.boundingBox !== null) {
        if (ray.isIntersectionBox(geometry.boundingBox) === false) {
          return;
        }
      }
      var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localThresholdSq = localThreshold * localThreshold;
      var position = new THREE.Vector3();
      function testPoint(point, index) {
        var rayPointDistanceSq = ray.distanceSqToPoint(point);
        if (rayPointDistanceSq < localThresholdSq) {
          var intersectPoint = ray.closestPointToPoint(point);
          intersectPoint.applyMatrix4(object.matrixWorld);
          var distance = raycaster.ray.origin.distanceTo(intersectPoint);
          if (distance < raycaster.near || distance > raycaster.far)
            return;
          intersects.push({
            distance: distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint.clone(),
            index: index,
            face: null,
            object: object
          });
        }
      }
      if (geometry instanceof THREE.BufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;
        if (index !== null) {
          var indices = index.array;
          for (var i = 0,
              il = indices.length; i < il; i++) {
            var a = indices[i];
            position.fromArray(positions, a * 3);
            testPoint(position, a);
          }
        } else {
          for (var i = 0,
              l = positions.length / 3; i < l; i++) {
            position.fromArray(positions, i * 3);
            testPoint(position, i);
          }
        }
      } else {
        var vertices = geometry.vertices;
        for (var i = 0,
            l = vertices.length; i < l; i++) {
          testPoint(vertices[i], i);
        }
      }
    };
  }());
  THREE.Points.prototype.clone = function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  };
  THREE.PointCloud = function(geometry, material) {
    console.warn('THREE.PointCloud has been renamed to THREE.Points.');
    return new THREE.Points(geometry, material);
  };
  THREE.ParticleSystem = function(geometry, material) {
    console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
    return new THREE.Points(geometry, material);
  };
  THREE.Line = function(geometry, material, mode) {
    if (mode === 1) {
      console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
      return new THREE.LineSegments(geometry, material);
    }
    THREE.Object3D.call(this);
    this.type = 'Line';
    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.LineBasicMaterial({color: Math.random() * 0xffffff});
  };
  THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
  THREE.Line.prototype.constructor = THREE.Line;
  THREE.Line.prototype.raycast = (function() {
    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();
    return function raycast(raycaster, intersects) {
      var precision = raycaster.linePrecision;
      var precisionSq = precision * precision;
      var geometry = this.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(this.matrixWorld);
      if (raycaster.ray.isIntersectionSphere(sphere) === false) {
        return;
      }
      inverseMatrix.getInverse(this.matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      var vStart = new THREE.Vector3();
      var vEnd = new THREE.Vector3();
      var interSegment = new THREE.Vector3();
      var interRay = new THREE.Vector3();
      var step = this instanceof THREE.LineSegments ? 2 : 1;
      if (geometry instanceof THREE.BufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        if (index !== null) {
          var indices = index.array;
          var positions = attributes.position.array;
          for (var i = 0,
              l = indices.length - 1; i < l; i += step) {
            var a = indices[i];
            var b = indices[i + 1];
            vStart.fromArray(positions, a * 3);
            vEnd.fromArray(positions, b * 3);
            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > precisionSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects.push({
              distance: distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        } else {
          var positions = attributes.position.array;
          for (var i = 0,
              l = positions.length / 3 - 1; i < l; i += step) {
            vStart.fromArray(positions, 3 * i);
            vEnd.fromArray(positions, 3 * i + 3);
            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > precisionSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects.push({
              distance: distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      } else if (geometry instanceof THREE.Geometry) {
        var vertices = geometry.vertices;
        var nbVertices = vertices.length;
        for (var i = 0; i < nbVertices - 1; i += step) {
          var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
          if (distSq > precisionSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          var distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects.push({
            distance: distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    };
  }());
  THREE.Line.prototype.clone = function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  };
  THREE.LineStrip = 0;
  THREE.LinePieces = 1;
  THREE.LineSegments = function(geometry, material) {
    THREE.Line.call(this, geometry, material);
    this.type = 'LineSegments';
  };
  THREE.LineSegments.prototype = Object.create(THREE.Line.prototype);
  THREE.LineSegments.prototype.constructor = THREE.LineSegments;
  THREE.Mesh = function(geometry, material) {
    THREE.Object3D.call(this);
    this.type = 'Mesh';
    this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
    this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({color: Math.random() * 0xffffff});
    this.updateMorphTargets();
  };
  THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
  THREE.Mesh.prototype.constructor = THREE.Mesh;
  THREE.Mesh.prototype.updateMorphTargets = function() {
    if (this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0) {
      this.morphTargetBase = -1;
      this.morphTargetInfluences = [];
      this.morphTargetDictionary = {};
      for (var m = 0,
          ml = this.geometry.morphTargets.length; m < ml; m++) {
        this.morphTargetInfluences.push(0);
        this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;
      }
    }
  };
  THREE.Mesh.prototype.getMorphTargetIndexByName = function(name) {
    if (this.morphTargetDictionary[name] !== undefined) {
      return this.morphTargetDictionary[name];
    }
    console.warn('THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.');
    return 0;
  };
  THREE.Mesh.prototype.raycast = (function() {
    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();
    var vA = new THREE.Vector3();
    var vB = new THREE.Vector3();
    var vC = new THREE.Vector3();
    var tempA = new THREE.Vector3();
    var tempB = new THREE.Vector3();
    var tempC = new THREE.Vector3();
    var uvA = new THREE.Vector2();
    var uvB = new THREE.Vector2();
    var uvC = new THREE.Vector2();
    var barycoord = new THREE.Vector3();
    var intersectionPoint = new THREE.Vector3();
    var intersectionPointWorld = new THREE.Vector3();
    function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
      THREE.Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
      uv1.multiplyScalar(barycoord.x);
      uv2.multiplyScalar(barycoord.y);
      uv3.multiplyScalar(barycoord.z);
      uv1.add(uv2).add(uv3);
      return uv1.clone();
    }
    function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
      var intersect;
      var material = object.material;
      if (material.side === THREE.BackSide) {
        intersect = ray.intersectTriangle(pC, pB, pA, true, point);
      } else {
        intersect = ray.intersectTriangle(pA, pB, pC, material.side !== THREE.DoubleSide, point);
      }
      if (intersect === null)
        return null;
      intersectionPointWorld.copy(point);
      intersectionPointWorld.applyMatrix4(object.matrixWorld);
      var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
      if (distance < raycaster.near || distance > raycaster.far)
        return null;
      return {
        distance: distance,
        point: intersectionPointWorld.clone(),
        object: object
      };
    }
    function checkBufferGeometryIntersection(object, raycaster, ray, positions, uvs, a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      var intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
      if (intersection) {
        if (uvs) {
          uvA.fromArray(uvs, a * 2);
          uvB.fromArray(uvs, b * 2);
          uvC.fromArray(uvs, c * 2);
          intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
        }
        intersection.face = new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC));
        intersection.faceIndex = a;
      }
      return intersection;
    }
    return function raycast(raycaster, intersects) {
      var geometry = this.geometry;
      var material = this.material;
      if (material === undefined)
        return;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      var matrixWorld = this.matrixWorld;
      sphere.copy(geometry.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      if (raycaster.ray.isIntersectionSphere(sphere) === false)
        return;
      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      if (geometry.boundingBox !== null) {
        if (ray.isIntersectionBox(geometry.boundingBox) === false)
          return;
      }
      var uvs,
          intersection;
      if (geometry instanceof THREE.BufferGeometry) {
        var a,
            b,
            c;
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;
        if (attributes.uv !== undefined) {
          uvs = attributes.uv.array;
        }
        if (index !== null) {
          var indices = index.array;
          for (var i = 0,
              l = indices.length; i < l; i += 3) {
            a = indices[i];
            b = indices[i + 1];
            c = indices[i + 2];
            intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects.push(intersection);
            }
          }
        } else {
          for (var i = 0,
              l = positions.length; i < l; i += 9) {
            a = i / 3;
            b = a + 1;
            c = a + 2;
            intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
            if (intersection) {
              intersection.index = a;
              intersects.push(intersection);
            }
          }
        }
      } else if (geometry instanceof THREE.Geometry) {
        var fvA,
            fvB,
            fvC;
        var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
        var materials = isFaceMaterial === true ? material.materials : null;
        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var faceVertexUvs = geometry.faceVertexUvs[0];
        if (faceVertexUvs.length > 0)
          uvs = faceVertexUvs;
        for (var f = 0,
            fl = faces.length; f < fl; f++) {
          var face = faces[f];
          var faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;
          if (faceMaterial === undefined)
            continue;
          fvA = vertices[face.a];
          fvB = vertices[face.b];
          fvC = vertices[face.c];
          if (faceMaterial.morphTargets === true) {
            var morphTargets = geometry.morphTargets;
            var morphInfluences = this.morphTargetInfluences;
            vA.set(0, 0, 0);
            vB.set(0, 0, 0);
            vC.set(0, 0, 0);
            for (var t = 0,
                tl = morphTargets.length; t < tl; t++) {
              var influence = morphInfluences[t];
              if (influence === 0)
                continue;
              var targets = morphTargets[t].vertices;
              vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
              vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
              vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
            }
            vA.add(fvA);
            vB.add(fvB);
            vC.add(fvC);
            fvA = vA;
            fvB = vB;
            fvC = vC;
          }
          intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
          if (intersection) {
            if (uvs) {
              var uvs_f = uvs[f];
              uvA.copy(uvs_f[0]);
              uvB.copy(uvs_f[1]);
              uvC.copy(uvs_f[2]);
              intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
            }
            intersection.face = face;
            intersection.faceIndex = f;
            intersects.push(intersection);
          }
        }
      }
    };
  }());
  THREE.Mesh.prototype.clone = function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  };
  THREE.Bone = function(skin) {
    THREE.Object3D.call(this);
    this.type = 'Bone';
    this.skin = skin;
  };
  THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
  THREE.Bone.prototype.constructor = THREE.Bone;
  THREE.Bone.prototype.copy = function(source) {
    THREE.Object3D.prototype.copy.call(this, source);
    this.skin = source.skin;
    return this;
  };
  THREE.Skeleton = function(bones, boneInverses, useVertexTexture) {
    this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
    this.identityMatrix = new THREE.Matrix4();
    bones = bones || [];
    this.bones = bones.slice(0);
    if (this.useVertexTexture) {
      var size = Math.sqrt(this.bones.length * 4);
      size = THREE.Math.nextPowerOfTwo(Math.ceil(size));
      size = Math.max(size, 4);
      this.boneTextureWidth = size;
      this.boneTextureHeight = size;
      this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
      this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);
    } else {
      this.boneMatrices = new Float32Array(16 * this.bones.length);
    }
    if (boneInverses === undefined) {
      this.calculateInverses();
    } else {
      if (this.bones.length === boneInverses.length) {
        this.boneInverses = boneInverses.slice(0);
      } else {
        console.warn('THREE.Skeleton bonInverses is the wrong length.');
        this.boneInverses = [];
        for (var b = 0,
            bl = this.bones.length; b < bl; b++) {
          this.boneInverses.push(new THREE.Matrix4());
        }
      }
    }
  };
  THREE.Skeleton.prototype.calculateInverses = function() {
    this.boneInverses = [];
    for (var b = 0,
        bl = this.bones.length; b < bl; b++) {
      var inverse = new THREE.Matrix4();
      if (this.bones[b]) {
        inverse.getInverse(this.bones[b].matrixWorld);
      }
      this.boneInverses.push(inverse);
    }
  };
  THREE.Skeleton.prototype.pose = function() {
    var bone;
    for (var b = 0,
        bl = this.bones.length; b < bl; b++) {
      bone = this.bones[b];
      if (bone) {
        bone.matrixWorld.getInverse(this.boneInverses[b]);
      }
    }
    for (var b = 0,
        bl = this.bones.length; b < bl; b++) {
      bone = this.bones[b];
      if (bone) {
        if (bone.parent) {
          bone.matrix.getInverse(bone.parent.matrixWorld);
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  };
  THREE.Skeleton.prototype.update = (function() {
    var offsetMatrix = new THREE.Matrix4();
    return function update() {
      for (var b = 0,
          bl = this.bones.length; b < bl; b++) {
        var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
        offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
        offsetMatrix.flattenToArrayOffset(this.boneMatrices, b * 16);
      }
      if (this.useVertexTexture) {
        this.boneTexture.needsUpdate = true;
      }
    };
  })();
  THREE.Skeleton.prototype.clone = function() {
    return new THREE.Skeleton(this.bones, this.boneInverses, this.useVertexTexture);
  };
  THREE.SkinnedMesh = function(geometry, material, useVertexTexture) {
    THREE.Mesh.call(this, geometry, material);
    this.type = 'SkinnedMesh';
    this.bindMode = "attached";
    this.bindMatrix = new THREE.Matrix4();
    this.bindMatrixInverse = new THREE.Matrix4();
    var bones = [];
    if (this.geometry && this.geometry.bones !== undefined) {
      var bone,
          gbone;
      for (var b = 0,
          bl = this.geometry.bones.length; b < bl; ++b) {
        gbone = this.geometry.bones[b];
        bone = new THREE.Bone(this);
        bones.push(bone);
        bone.name = gbone.name;
        bone.position.fromArray(gbone.pos);
        bone.quaternion.fromArray(gbone.rotq);
        if (gbone.scl !== undefined)
          bone.scale.fromArray(gbone.scl);
      }
      for (var b = 0,
          bl = this.geometry.bones.length; b < bl; ++b) {
        gbone = this.geometry.bones[b];
        if (gbone.parent !== -1 && gbone.parent !== null) {
          bones[gbone.parent].add(bones[b]);
        } else {
          this.add(bones[b]);
        }
      }
    }
    this.normalizeSkinWeights();
    this.updateMatrixWorld(true);
    this.bind(new THREE.Skeleton(bones, undefined, useVertexTexture), this.matrixWorld);
  };
  THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
  THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
  THREE.SkinnedMesh.prototype.bind = function(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === undefined) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.getInverse(bindMatrix);
  };
  THREE.SkinnedMesh.prototype.pose = function() {
    this.skeleton.pose();
  };
  THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
    if (this.geometry instanceof THREE.Geometry) {
      for (var i = 0; i < this.geometry.skinIndices.length; i++) {
        var sw = this.geometry.skinWeights[i];
        var scale = 1.0 / sw.lengthManhattan();
        if (scale !== Infinity) {
          sw.multiplyScalar(scale);
        } else {
          sw.set(1);
        }
      }
    } else {}
  };
  THREE.SkinnedMesh.prototype.updateMatrixWorld = function(force) {
    THREE.Mesh.prototype.updateMatrixWorld.call(this, true);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.getInverse(this.matrixWorld);
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.getInverse(this.bindMatrix);
    } else {
      console.warn('THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode);
    }
  };
  THREE.SkinnedMesh.prototype.clone = function() {
    return new this.constructor(this.geometry, this.material, this.useVertexTexture).copy(this);
  };
  THREE.LOD = function() {
    THREE.Object3D.call(this);
    this.type = 'LOD';
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      },
      objects: {get: function() {
          console.warn('THREE.LOD: .objects has been renamed to .levels.');
          return this.levels;
        }}
    });
  };
  THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
  THREE.LOD.prototype.constructor = THREE.LOD;
  THREE.LOD.prototype.addLevel = function(object, distance) {
    if (distance === undefined)
      distance = 0;
    distance = Math.abs(distance);
    var levels = this.levels;
    for (var l = 0; l < levels.length; l++) {
      if (distance < levels[l].distance) {
        break;
      }
    }
    levels.splice(l, 0, {
      distance: distance,
      object: object
    });
    this.add(object);
  };
  THREE.LOD.prototype.getObjectForDistance = function(distance) {
    var levels = this.levels;
    for (var i = 1,
        l = levels.length; i < l; i++) {
      if (distance < levels[i].distance) {
        break;
      }
    }
    return levels[i - 1].object;
  };
  THREE.LOD.prototype.raycast = (function() {
    var matrixPosition = new THREE.Vector3();
    return function raycast(raycaster, intersects) {
      matrixPosition.setFromMatrixPosition(this.matrixWorld);
      var distance = raycaster.ray.origin.distanceTo(matrixPosition);
      this.getObjectForDistance(distance).raycast(raycaster, intersects);
    };
  }());
  THREE.LOD.prototype.update = function() {
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    return function update(camera) {
      var levels = this.levels;
      if (levels.length > 1) {
        v1.setFromMatrixPosition(camera.matrixWorld);
        v2.setFromMatrixPosition(this.matrixWorld);
        var distance = v1.distanceTo(v2);
        levels[0].object.visible = true;
        for (var i = 1,
            l = levels.length; i < l; i++) {
          if (distance >= levels[i].distance) {
            levels[i - 1].object.visible = false;
            levels[i].object.visible = true;
          } else {
            break;
          }
        }
        for (; i < l; i++) {
          levels[i].object.visible = false;
        }
      }
    };
  }();
  THREE.LOD.prototype.copy = function(source) {
    THREE.Object3D.prototype.copy.call(this, source, false);
    var levels = source.levels;
    for (var i = 0,
        l = levels.length; i < l; i++) {
      var level = levels[i];
      this.addLevel(level.object.clone(), level.distance);
    }
    return this;
  };
  THREE.LOD.prototype.toJSON = function(meta) {
    var data = THREE.Object3D.prototype.toJSON.call(this, meta);
    data.object.levels = [];
    var levels = this.levels;
    for (var i = 0,
        l = levels.length; i < l; i++) {
      var level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }
    return data;
  };
  THREE.Sprite = (function() {
    var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
    var vertices = new Float32Array([-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0]);
    var uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
    var geometry = new THREE.BufferGeometry();
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    return function Sprite(material) {
      THREE.Object3D.call(this);
      this.type = 'Sprite';
      this.geometry = geometry;
      this.material = (material !== undefined) ? material : new THREE.SpriteMaterial();
    };
  })();
  THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
  THREE.Sprite.prototype.constructor = THREE.Sprite;
  THREE.Sprite.prototype.raycast = (function() {
    var matrixPosition = new THREE.Vector3();
    return function raycast(raycaster, intersects) {
      matrixPosition.setFromMatrixPosition(this.matrixWorld);
      var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);
      var guessSizeSq = this.scale.x * this.scale.y;
      if (distanceSq > guessSizeSq) {
        return;
      }
      intersects.push({
        distance: Math.sqrt(distanceSq),
        point: this.position,
        face: null,
        object: this
      });
    };
  }());
  THREE.Sprite.prototype.clone = function() {
    return new this.constructor(this.material).copy(this);
  };
  THREE.Particle = THREE.Sprite;
  THREE.LensFlare = function(texture, size, distance, blending, color) {
    THREE.Object3D.call(this);
    this.lensFlares = [];
    this.positionScreen = new THREE.Vector3();
    this.customUpdateCallback = undefined;
    if (texture !== undefined) {
      this.add(texture, size, distance, blending, color);
    }
  };
  THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
  THREE.LensFlare.prototype.constructor = THREE.LensFlare;
  THREE.LensFlare.prototype.add = function(texture, size, distance, blending, color, opacity) {
    if (size === undefined)
      size = -1;
    if (distance === undefined)
      distance = 0;
    if (opacity === undefined)
      opacity = 1;
    if (color === undefined)
      color = new THREE.Color(0xffffff);
    if (blending === undefined)
      blending = THREE.NormalBlending;
    distance = Math.min(distance, Math.max(0, distance));
    this.lensFlares.push({
      texture: texture,
      size: size,
      distance: distance,
      x: 0,
      y: 0,
      z: 0,
      scale: 1,
      rotation: 0,
      opacity: opacity,
      color: color,
      blending: blending
    });
  };
  THREE.LensFlare.prototype.updateLensFlares = function() {
    var f,
        fl = this.lensFlares.length;
    var flare;
    var vecX = -this.positionScreen.x * 2;
    var vecY = -this.positionScreen.y * 2;
    for (f = 0; f < fl; f++) {
      flare = this.lensFlares[f];
      flare.x = this.positionScreen.x + vecX * flare.distance;
      flare.y = this.positionScreen.y + vecY * flare.distance;
      flare.wantedRotation = flare.x * Math.PI * 0.25;
      flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
    }
  };
  THREE.LensFlare.prototype.copy = function(source) {
    THREE.Object3D.prototype.copy.call(this, source);
    this.positionScreen.copy(source.positionScreen);
    this.customUpdateCallback = source.customUpdateCallback;
    for (var i = 0,
        l = source.lensFlares.length; i < l; i++) {
      this.lensFlares.push(source.lensFlares[i]);
    }
    return this;
  };
  THREE.Scene = function() {
    THREE.Object3D.call(this);
    this.type = 'Scene';
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
  };
  THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
  THREE.Scene.prototype.constructor = THREE.Scene;
  THREE.Scene.prototype.copy = function(source) {
    THREE.Object3D.prototype.copy.call(this, source);
    if (source.fog !== null)
      this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  };
  THREE.Fog = function(color, near, far) {
    this.name = '';
    this.color = new THREE.Color(color);
    this.near = (near !== undefined) ? near : 1;
    this.far = (far !== undefined) ? far : 1000;
  };
  THREE.Fog.prototype.clone = function() {
    return new THREE.Fog(this.color.getHex(), this.near, this.far);
  };
  THREE.FogExp2 = function(color, density) {
    this.name = '';
    this.color = new THREE.Color(color);
    this.density = (density !== undefined) ? density : 0.00025;
  };
  THREE.FogExp2.prototype.clone = function() {
    return new THREE.FogExp2(this.color.getHex(), this.density);
  };
  THREE.ShaderChunk = {};
  THREE.ShaderChunk['alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
  THREE.ShaderChunk['alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";
  THREE.ShaderChunk['alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";
  THREE.ShaderChunk['aomap_fragment'] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";
  THREE.ShaderChunk['aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";
  THREE.ShaderChunk['begin_vertex'] = "\nvec3 transformed = vec3( position );\n";
  THREE.ShaderChunk['beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";
  THREE.ShaderChunk['bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";
  THREE.ShaderChunk['color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";
  THREE.ShaderChunk['color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";
  THREE.ShaderChunk['color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";
  THREE.ShaderChunk['color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";
  THREE.ShaderChunk['common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";
  THREE.ShaderChunk['defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
  THREE.ShaderChunk['displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";
  THREE.ShaderChunk['displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";
  THREE.ShaderChunk['emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";
  THREE.ShaderChunk['emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";
  THREE.ShaderChunk['envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";
  THREE.ShaderChunk['envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";
  THREE.ShaderChunk['envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";
  THREE.ShaderChunk['envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";
  THREE.ShaderChunk['fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";
  THREE.ShaderChunk['fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";
  THREE.ShaderChunk['hemilight_fragment'] = "#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalAmbientLight += lightColor;\n\n	}\n\n#endif\n\n";
  THREE.ShaderChunk['lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";
  THREE.ShaderChunk['lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";
  THREE.ShaderChunk['lights_lambert_pars_vertex'] = "#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";
  THREE.ShaderChunk['lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n";
  THREE.ShaderChunk['lights_phong_fragment'] = "vec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n";
  THREE.ShaderChunk['lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";
  THREE.ShaderChunk['lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\n#endif\n";
  THREE.ShaderChunk['lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";
  THREE.ShaderChunk['linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";
  THREE.ShaderChunk['logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";
  THREE.ShaderChunk['logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";
  THREE.ShaderChunk['logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";
  THREE.ShaderChunk['logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";
  THREE.ShaderChunk['map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";
  THREE.ShaderChunk['map_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";
  THREE.ShaderChunk['map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";
  THREE.ShaderChunk['map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";
  THREE.ShaderChunk['morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";
  THREE.ShaderChunk['morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";
  THREE.ShaderChunk['morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";
  THREE.ShaderChunk['normal_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n";
  THREE.ShaderChunk['normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";
  THREE.ShaderChunk['project_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";
  THREE.ShaderChunk['shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		float texelSizeY =  1.0 / shadowMapSize[ i ].y;\n\n		float shadow = 0.0;\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		bool isPointLight = shadowDarkness[ i ] < 0.0;\n\n		if ( isPointLight ) {\n\n			float realShadowDarkness = abs( shadowDarkness[ i ] );\n\n			vec3 lightToPosition = vShadowCoord[ i ].xyz;\n\n	#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n			const float Dr = 1.25;\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			const float Dr = 2.25;\n	#endif\n\n			float os = Dr *  2.0 * texelSizeY;\n\n			const vec3 Gsd = vec3( - 1, 0, 1 );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness * ( 1.0 / 21.0 );\n\n	#else \n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness;\n\n	#endif\n\n		} else {\n\n#endif \n			float texelSizeX =  1.0 / shadowMapSize[ i ].x;\n\n			vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\n			bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n			bool inFrustum = all( inFrustumVec );\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n			bool frustumTest = all( frustumTestVec );\n\n			if ( frustumTest ) {\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n\n\n				/*\n					for ( float y = -1.25; y <= 1.25; y += 1.25 )\n						for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n							vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n							float fDepth = unpackDepth( rgbaDepth );\n							if ( fDepth < shadowCoord.z )\n								shadow += 1.0;\n					}\n					shadow /= 9.0;\n				*/\n\n				shadowCoord.z += shadowBias[ i ];\n\n				const float ShadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.25 * xPixelOffset;\n				float dy0 = - 1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				float fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				shadow *= shadowDarkness[ i ];\n\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\n				shadowCoord.z += shadowBias[ i ];\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.0 * xPixelOffset;\n				float dy0 = - 1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[ 0 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[ 0 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[ 0 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[ 1 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[ 1 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[ 1 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[ 2 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[ 2 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[ 2 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[ 0 ] = vec3( lessThan( depthKernel[ 0 ], shadowZ ) );\n				shadowKernel[ 0 ] *= vec3( 0.25 );\n\n				shadowKernel[ 1 ] = vec3( lessThan( depthKernel[ 1 ], shadowZ ) );\n				shadowKernel[ 1 ] *= vec3( 0.25 );\n\n				shadowKernel[ 2 ] = vec3( lessThan( depthKernel[ 2 ], shadowZ ) );\n				shadowKernel[ 2 ] *= vec3( 0.25 );\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[ i ].xy );\n\n				shadowKernel[ 0 ] = mix( shadowKernel[ 1 ], shadowKernel[ 0 ], fractionalCoord.x );\n				shadowKernel[ 1 ] = mix( shadowKernel[ 2 ], shadowKernel[ 1 ], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[ 0 ][ 1 ], shadowKernel[ 0 ][ 0 ], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[ 0 ][ 2 ], shadowKernel[ 0 ][ 1 ], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[ 1 ][ 1 ], shadowKernel[ 1 ][ 0 ], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[ 1 ][ 2 ], shadowKernel[ 1 ][ 1 ], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) ) * shadowDarkness[ i ];\n\n	#else \n				shadowCoord.z += shadowBias[ i ];\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n					shadow = shadowDarkness[ i ];\n\n	#endif\n\n			}\n\n#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) {\n\n				if ( i == 0 ) {\n\n					outgoingLight *= vec3( 1.0, 0.5, 0.0 );\n\n				} else if ( i == 1 ) {\n\n					outgoingLight *= vec3( 0.0, 1.0, 0.8 );\n\n				} else {\n\n					outgoingLight *= vec3( 0.0, 0.5, 1.0 );\n\n				}\n\n			}\n\n#endif\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		}\n\n#endif\n\n		shadowMask = shadowMask * vec3( 1.0 - shadow );\n\n	}\n\n#endif\n";
  THREE.ShaderChunk['shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n	#if defined(POINT_LIGHT_SHADOWS)\n\n\n		void adjustShadowValue1K( const float testDepth, const vec4 textureData, const float bias, inout float shadowValue ) {\n\n			const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n			if ( testDepth >= dot( textureData, bitSh ) * 1000.0 + bias )\n				shadowValue += 1.0;\n\n		}\n\n\n		vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\n			vec3 absV = abs( v );\n\n\n			float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n			absV *= scaleToCube;\n\n\n			v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\n\n			vec2 planar = v.xy;\n\n			float almostATexel = 1.5 * texelSizeY;\n			float almostOne = 1.0 - almostATexel;\n\n			if ( absV.z >= almostOne ) {\n\n				if ( v.z > 0.0 )\n					planar.x = 4.0 - v.x;\n\n			} else if ( absV.x >= almostOne ) {\n\n				float signX = sign( v.x );\n				planar.x = v.z * signX + 2.0 * signX;\n\n			} else if ( absV.y >= almostOne ) {\n\n				float signY = sign( v.y );\n				planar.x = v.x + 2.0 * signY + 2.0;\n				planar.y = v.z * signY - 2.0;\n\n			}\n\n\n			return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n		}\n\n	#endif\n\n#endif\n";
  THREE.ShaderChunk['shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n#endif";
  THREE.ShaderChunk['shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";
  THREE.ShaderChunk['skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
  THREE.ShaderChunk['skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";
  THREE.ShaderChunk['skinning_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";
  THREE.ShaderChunk['skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";
  THREE.ShaderChunk['specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";
  THREE.ShaderChunk['specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";
  THREE.ShaderChunk['uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";
  THREE.ShaderChunk['uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";
  THREE.ShaderChunk['uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";
  THREE.ShaderChunk['uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";
  THREE.ShaderChunk['uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";
  THREE.ShaderChunk['uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";
  THREE.ShaderChunk['worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";
  THREE.UniformsUtils = {
    merge: function(uniforms) {
      var merged = {};
      for (var u = 0; u < uniforms.length; u++) {
        var tmp = this.clone(uniforms[u]);
        for (var p in tmp) {
          merged[p] = tmp[p];
        }
      }
      return merged;
    },
    clone: function(uniforms_src) {
      var uniforms_dst = {};
      for (var u in uniforms_src) {
        uniforms_dst[u] = {};
        for (var p in uniforms_src[u]) {
          var parameter_src = uniforms_src[u][p];
          if (parameter_src instanceof THREE.Color || parameter_src instanceof THREE.Vector2 || parameter_src instanceof THREE.Vector3 || parameter_src instanceof THREE.Vector4 || parameter_src instanceof THREE.Matrix3 || parameter_src instanceof THREE.Matrix4 || parameter_src instanceof THREE.Texture) {
            uniforms_dst[u][p] = parameter_src.clone();
          } else if (Array.isArray(parameter_src)) {
            uniforms_dst[u][p] = parameter_src.slice();
          } else {
            uniforms_dst[u][p] = parameter_src;
          }
        }
      }
      return uniforms_dst;
    }
  };
  THREE.UniformsLib = {
    common: {
      "diffuse": {
        type: "c",
        value: new THREE.Color(0xeeeeee)
      },
      "opacity": {
        type: "f",
        value: 1.0
      },
      "map": {
        type: "t",
        value: null
      },
      "offsetRepeat": {
        type: "v4",
        value: new THREE.Vector4(0, 0, 1, 1)
      },
      "specularMap": {
        type: "t",
        value: null
      },
      "alphaMap": {
        type: "t",
        value: null
      },
      "envMap": {
        type: "t",
        value: null
      },
      "flipEnvMap": {
        type: "f",
        value: -1
      },
      "reflectivity": {
        type: "f",
        value: 1.0
      },
      "refractionRatio": {
        type: "f",
        value: 0.98
      }
    },
    aomap: {
      "aoMap": {
        type: "t",
        value: null
      },
      "aoMapIntensity": {
        type: "f",
        value: 1
      }
    },
    lightmap: {
      "lightMap": {
        type: "t",
        value: null
      },
      "lightMapIntensity": {
        type: "f",
        value: 1
      }
    },
    emissivemap: {"emissiveMap": {
        type: "t",
        value: null
      }},
    bumpmap: {
      "bumpMap": {
        type: "t",
        value: null
      },
      "bumpScale": {
        type: "f",
        value: 1
      }
    },
    normalmap: {
      "normalMap": {
        type: "t",
        value: null
      },
      "normalScale": {
        type: "v2",
        value: new THREE.Vector2(1, 1)
      }
    },
    displacementmap: {
      "displacementMap": {
        type: "t",
        value: null
      },
      "displacementScale": {
        type: "f",
        value: 1
      },
      "displacementBias": {
        type: "f",
        value: 0
      }
    },
    fog: {
      "fogDensity": {
        type: "f",
        value: 0.00025
      },
      "fogNear": {
        type: "f",
        value: 1
      },
      "fogFar": {
        type: "f",
        value: 2000
      },
      "fogColor": {
        type: "c",
        value: new THREE.Color(0xffffff)
      }
    },
    lights: {
      "ambientLightColor": {
        type: "fv",
        value: []
      },
      "directionalLightDirection": {
        type: "fv",
        value: []
      },
      "directionalLightColor": {
        type: "fv",
        value: []
      },
      "hemisphereLightDirection": {
        type: "fv",
        value: []
      },
      "hemisphereLightSkyColor": {
        type: "fv",
        value: []
      },
      "hemisphereLightGroundColor": {
        type: "fv",
        value: []
      },
      "pointLightColor": {
        type: "fv",
        value: []
      },
      "pointLightPosition": {
        type: "fv",
        value: []
      },
      "pointLightDistance": {
        type: "fv1",
        value: []
      },
      "pointLightDecay": {
        type: "fv1",
        value: []
      },
      "spotLightColor": {
        type: "fv",
        value: []
      },
      "spotLightPosition": {
        type: "fv",
        value: []
      },
      "spotLightDirection": {
        type: "fv",
        value: []
      },
      "spotLightDistance": {
        type: "fv1",
        value: []
      },
      "spotLightAngleCos": {
        type: "fv1",
        value: []
      },
      "spotLightExponent": {
        type: "fv1",
        value: []
      },
      "spotLightDecay": {
        type: "fv1",
        value: []
      }
    },
    points: {
      "psColor": {
        type: "c",
        value: new THREE.Color(0xeeeeee)
      },
      "opacity": {
        type: "f",
        value: 1.0
      },
      "size": {
        type: "f",
        value: 1.0
      },
      "scale": {
        type: "f",
        value: 1.0
      },
      "map": {
        type: "t",
        value: null
      },
      "offsetRepeat": {
        type: "v4",
        value: new THREE.Vector4(0, 0, 1, 1)
      },
      "fogDensity": {
        type: "f",
        value: 0.00025
      },
      "fogNear": {
        type: "f",
        value: 1
      },
      "fogFar": {
        type: "f",
        value: 2000
      },
      "fogColor": {
        type: "c",
        value: new THREE.Color(0xffffff)
      }
    },
    shadowmap: {
      "shadowMap": {
        type: "tv",
        value: []
      },
      "shadowMapSize": {
        type: "v2v",
        value: []
      },
      "shadowBias": {
        type: "fv1",
        value: []
      },
      "shadowDarkness": {
        type: "fv1",
        value: []
      },
      "shadowMatrix": {
        type: "m4v",
        value: []
      }
    }
  };
  THREE.ShaderLib = {
    'basic': {
      uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["aomap"], THREE.UniformsLib["fog"], THREE.UniformsLib["shadowmap"]]),
      vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["uv_pars_vertex"], THREE.ShaderChunk["uv2_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["uv_vertex"], THREE.ShaderChunk["uv2_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["skinbase_vertex"], "	#ifdef USE_ENVMAP", THREE.ShaderChunk["beginnormal_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "	#endif", THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
      fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["uv_pars_fragment"], THREE.ShaderChunk["uv2_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["aomap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", "	vec3 totalAmbientLight = vec3( 1.0 );", "	vec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["aomap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], "	outgoingLight = diffuseColor.rgb * totalAmbientLight * shadowMask;", THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
    },
    'lambert': {
      uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], {"emissive": {
          type: "c",
          value: new THREE.Color(0x000000)
        }}]),
      vertexShader: ["#define LAMBERT", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["uv_pars_vertex"], THREE.ShaderChunk["uv2_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_lambert_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["uv_vertex"], THREE.ShaderChunk["uv2_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["beginnormal_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_lambert_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
      fragmentShader: ["uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform float opacity;", "uniform vec3 ambientLightColor;", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["uv_pars_fragment"], THREE.ShaderChunk["uv2_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", "	vec3 totalAmbientLight = ambientLightColor;", "	vec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], "	#ifdef DOUBLE_SIDED", "		if ( gl_FrontFacing )", "			outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;", "		else", "			outgoingLight += diffuseColor.rgb * ( vLightBack * shadowMask + totalAmbientLight ) + emissive;", "	#else", "		outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;", "	#endif", THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
    },
    'phong': {
      uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["aomap"], THREE.UniformsLib["lightmap"], THREE.UniformsLib["emissivemap"], THREE.UniformsLib["bumpmap"], THREE.UniformsLib["normalmap"], THREE.UniformsLib["displacementmap"], THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], {
        "emissive": {
          type: "c",
          value: new THREE.Color(0x000000)
        },
        "specular": {
          type: "c",
          value: new THREE.Color(0x111111)
        },
        "shininess": {
          type: "f",
          value: 30
        }
      }]),
      vertexShader: ["#define PHONG", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["uv_pars_vertex"], THREE.ShaderChunk["uv2_pars_vertex"], THREE.ShaderChunk["displacementmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_phong_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["uv_vertex"], THREE.ShaderChunk["uv2_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["beginnormal_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "#ifndef FLAT_SHADED", "	vNormal = normalize( transformedNormal );", "#endif", THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["displacementmap_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "	vViewPosition = - mvPosition.xyz;", THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_phong_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
      fragmentShader: ["#define PHONG", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["uv_pars_fragment"], THREE.ShaderChunk["uv2_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["aomap_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["emissivemap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["lights_phong_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["bumpmap_pars_fragment"], THREE.ShaderChunk["normalmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", "	vec3 totalAmbientLight = ambientLightColor;", "	vec3 totalEmissiveLight = emissive;", "	vec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["normal_phong_fragment"], THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["hemilight_fragment"], THREE.ShaderChunk["aomap_fragment"], THREE.ShaderChunk["emissivemap_fragment"], THREE.ShaderChunk["lights_phong_fragment"], THREE.ShaderChunk["shadowmap_fragment"], "totalDiffuseLight *= shadowMask;", "totalSpecularLight *= shadowMask;", "#ifdef METAL", "	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;", "#else", "	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;", "#endif", THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
    },
    'points': {
      uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["points"], THREE.UniformsLib["shadowmap"]]),
      vertexShader: ["uniform float size;", "uniform float scale;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["color_vertex"], "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	#ifdef USE_SIZEATTENUATION", "		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );", "	#else", "		gl_PointSize = size;", "	#endif", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
      fragmentShader: ["uniform vec3 psColor;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_particle_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( psColor, opacity );", "	vec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_particle_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["shadowmap_fragment"], "	outgoingLight = diffuseColor.rgb * shadowMask;", THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
    },
    'dashed': {
      uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["fog"], {
        "scale": {
          type: "f",
          value: 1
        },
        "dashSize": {
          type: "f",
          value: 1
        },
        "totalSize": {
          type: "f",
          value: 2
        }
      }]),
      vertexShader: ["uniform float scale;", "attribute float lineDistance;", "varying float vLineDistance;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["color_vertex"], "	vLineDistance = scale * lineDistance;", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
      fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "uniform float dashSize;", "uniform float totalSize;", "varying float vLineDistance;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	if ( mod( vLineDistance, totalSize ) > dashSize ) {", "		discard;", "	}", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["color_fragment"], "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
    },
    'depth': {
      uniforms: {
        "mNear": {
          type: "f",
          value: 1.0
        },
        "mFar": {
          type: "f",
          value: 2000.0
        },
        "opacity": {
          type: "f",
          value: 1.0
        }
      },
      vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
      fragmentShader: ["uniform float mNear;", "uniform float mFar;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", THREE.ShaderChunk["logdepthbuf_fragment"], "	#ifdef USE_LOGDEPTHBUF_EXT", "		float depth = gl_FragDepthEXT / gl_FragCoord.w;", "	#else", "		float depth = gl_FragCoord.z / gl_FragCoord.w;", "	#endif", "	float color = 1.0 - smoothstep( mNear, mFar, depth );", "	gl_FragColor = vec4( vec3( color ), opacity );", "}"].join("\n")
    },
    'normal': {
      uniforms: {"opacity": {
          type: "f",
          value: 1.0
        }},
      vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
      fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
    },
    'cube': {
      uniforms: {
        "tCube": {
          type: "t",
          value: null
        },
        "tFlip": {
          type: "f",
          value: -1
        }
      },
      vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
      fragmentShader: ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
    },
    'equirect': {
      uniforms: {
        "tEquirect": {
          type: "t",
          value: null
        },
        "tFlip": {
          type: "f",
          value: -1
        }
      },
      vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
      fragmentShader: ["uniform sampler2D tEquirect;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "vec3 direction = normalize( vWorldPosition );", "vec2 sampleUV;", "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );", "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "gl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
    },
    'depthRGBA': {
      uniforms: {},
      vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
      fragmentShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "vec4 pack_depth( const in float depth ) {", "	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", "	res -= res.xxyz * bit_mask;", "	return res;", "}", "void main() {", THREE.ShaderChunk["logdepthbuf_fragment"], "	#ifdef USE_LOGDEPTHBUF_EXT", "		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );", "	#else", "		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );", "	#endif", "}"].join("\n")
    },
    'distanceRGBA': {
      uniforms: {"lightPos": {
          type: "v3",
          value: new THREE.Vector3(0, 0, 0)
        }},
      vertexShader: ["varying vec4 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], "void main() {", THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["worldpos_vertex"], "vWorldPosition = worldPosition;", "}"].join("\n"),
      fragmentShader: ["uniform vec3 lightPos;", "varying vec4 vWorldPosition;", THREE.ShaderChunk["common"], "vec4 pack1K ( float depth ) {", "   depth /= 1000.0;", "   const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "	vec4 res = fract( depth * bitSh );", "	res -= res.xxyz * bitMsk;", "	return res; ", "}", "float unpack1K ( vec4 color ) {", "	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );", "	return dot( color, bitSh ) * 1000.0;", "}", "void main () {", "	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );", "}"].join("\n")
    }
  };
  THREE.WebGLRenderer = function(parameters) {
    console.log('THREE.WebGLRenderer', THREE.REVISION);
    parameters = parameters || {};
    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement('canvas'),
        _context = parameters.context !== undefined ? parameters.context : null,
        _width = _canvas.width,
        _height = _canvas.height,
        pixelRatio = 1,
        _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
        _depth = parameters.depth !== undefined ? parameters.depth : true,
        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
        _clearColor = new THREE.Color(0x000000),
        _clearAlpha = 0;
    var lights = [];
    var opaqueObjects = [];
    var opaqueObjectsLastIndex = -1;
    var transparentObjects = [];
    var transparentObjectsLastIndex = -1;
    var morphInfluences = new Float32Array(8);
    var sprites = [];
    var lensFlares = [];
    this.domElement = _canvas;
    this.context = null;
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.gammaFactor = 2.0;
    this.gammaInput = false;
    this.gammaOutput = false;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    this.autoScaleCubemaps = true;
    var _this = this,
        _currentProgram = null,
        _currentFramebuffer = null,
        _currentMaterialId = -1,
        _currentGeometryProgram = '',
        _currentCamera = null,
        _usedTextureUnits = 0,
        _viewportX = 0,
        _viewportY = 0,
        _viewportWidth = _canvas.width,
        _viewportHeight = _canvas.height,
        _currentWidth = 0,
        _currentHeight = 0,
        _frustum = new THREE.Frustum(),
        _projScreenMatrix = new THREE.Matrix4(),
        _vector3 = new THREE.Vector3(),
        _direction = new THREE.Vector3(),
        _lightsNeedUpdate = true,
        _lights = {
          ambient: [0, 0, 0],
          directional: {
            length: 0,
            colors: [],
            positions: []
          },
          point: {
            length: 0,
            colors: [],
            positions: [],
            distances: [],
            decays: []
          },
          spot: {
            length: 0,
            colors: [],
            positions: [],
            distances: [],
            directions: [],
            anglesCos: [],
            exponents: [],
            decays: []
          },
          hemi: {
            length: 0,
            skyColors: [],
            groundColors: [],
            positions: []
          }
        },
        _infoMemory = {
          geometries: 0,
          textures: 0
        },
        _infoRender = {
          calls: 0,
          vertices: 0,
          faces: 0,
          points: 0
        };
    this.info = {
      render: _infoRender,
      memory: _infoMemory,
      programs: null
    };
    var _gl;
    try {
      var attributes = {
        alpha: _alpha,
        depth: _depth,
        stencil: _stencil,
        antialias: _antialias,
        premultipliedAlpha: _premultipliedAlpha,
        preserveDrawingBuffer: _preserveDrawingBuffer
      };
      _gl = _context || _canvas.getContext('webgl', attributes) || _canvas.getContext('experimental-webgl', attributes);
      if (_gl === null) {
        if (_canvas.getContext('webgl') !== null) {
          throw 'Error creating WebGL context with your selected attributes.';
        } else {
          throw 'Error creating WebGL context.';
        }
      }
      _canvas.addEventListener('webglcontextlost', onContextLost, false);
    } catch (error) {
      console.error('THREE.WebGLRenderer: ' + error);
    }
    var extensions = new THREE.WebGLExtensions(_gl);
    extensions.get('OES_texture_float');
    extensions.get('OES_texture_float_linear');
    extensions.get('OES_texture_half_float');
    extensions.get('OES_texture_half_float_linear');
    extensions.get('OES_standard_derivatives');
    extensions.get('ANGLE_instanced_arrays');
    if (extensions.get('OES_element_index_uint')) {
      THREE.BufferGeometry.MaxIndex = 4294967296;
    }
    var capabilities = new THREE.WebGLCapabilities(_gl, extensions, parameters);
    var state = new THREE.WebGLState(_gl, extensions, paramThreeToGL);
    var properties = new THREE.WebGLProperties();
    var objects = new THREE.WebGLObjects(_gl, properties, this.info);
    var programCache = new THREE.WebGLPrograms(this, capabilities);
    this.info.programs = programCache.programs;
    var bufferRenderer = new THREE.WebGLBufferRenderer(_gl, extensions, _infoRender);
    var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);
    function glClearColor(r, g, b, a) {
      if (_premultipliedAlpha === true) {
        r *= a;
        g *= a;
        b *= a;
      }
      _gl.clearColor(r, g, b, a);
    }
    function setDefaultGLState() {
      state.init();
      _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
      glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
    }
    function resetGLState() {
      _currentProgram = null;
      _currentCamera = null;
      _currentGeometryProgram = '';
      _currentMaterialId = -1;
      _lightsNeedUpdate = true;
      state.reset();
    }
    setDefaultGLState();
    this.context = _gl;
    this.capabilities = capabilities;
    this.extensions = extensions;
    this.state = state;
    var shadowMap = new THREE.WebGLShadowMap(this, lights, objects);
    this.shadowMap = shadowMap;
    var spritePlugin = new THREE.SpritePlugin(this, sprites);
    var lensFlarePlugin = new THREE.LensFlarePlugin(this, lensFlares);
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      extensions.get('WEBGL_lose_context').loseContext();
    };
    this.getMaxAnisotropy = (function() {
      var value;
      return function getMaxAnisotropy() {
        if (value !== undefined)
          return value;
        var extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension !== null) {
          value = _gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else {
          value = 0;
        }
        return value;
      };
    })();
    this.getPrecision = function() {
      return capabilities.precision;
    };
    this.getPixelRatio = function() {
      return pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value !== undefined)
        pixelRatio = value;
    };
    this.getSize = function() {
      return {
        width: _width,
        height: _height
      };
    };
    this.setSize = function(width, height, updateStyle) {
      _width = width;
      _height = height;
      _canvas.width = width * pixelRatio;
      _canvas.height = height * pixelRatio;
      if (updateStyle !== false) {
        _canvas.style.width = width + 'px';
        _canvas.style.height = height + 'px';
      }
      this.setViewport(0, 0, width, height);
    };
    this.setViewport = function(x, y, width, height) {
      _viewportX = x * pixelRatio;
      _viewportY = y * pixelRatio;
      _viewportWidth = width * pixelRatio;
      _viewportHeight = height * pixelRatio;
      _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
    };
    this.getViewport = function(dimensions) {
      dimensions.x = _viewportX / pixelRatio;
      dimensions.y = _viewportY / pixelRatio;
      dimensions.z = _viewportWidth / pixelRatio;
      dimensions.w = _viewportHeight / pixelRatio;
    };
    this.setScissor = function(x, y, width, height) {
      _gl.scissor(x * pixelRatio, y * pixelRatio, width * pixelRatio, height * pixelRatio);
    };
    this.enableScissorTest = function(boolean) {
      state.setScissorTest(boolean);
    };
    this.getClearColor = function() {
      return _clearColor;
    };
    this.setClearColor = function(color, alpha) {
      _clearColor.set(color);
      _clearAlpha = alpha !== undefined ? alpha : 1;
      glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
    };
    this.getClearAlpha = function() {
      return _clearAlpha;
    };
    this.setClearAlpha = function(alpha) {
      _clearAlpha = alpha;
      glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
    };
    this.clear = function(color, depth, stencil) {
      var bits = 0;
      if (color === undefined || color)
        bits |= _gl.COLOR_BUFFER_BIT;
      if (depth === undefined || depth)
        bits |= _gl.DEPTH_BUFFER_BIT;
      if (stencil === undefined || stencil)
        bits |= _gl.STENCIL_BUFFER_BIT;
      _gl.clear(bits);
    };
    this.clearColor = function() {
      _gl.clear(_gl.COLOR_BUFFER_BIT);
    };
    this.clearDepth = function() {
      _gl.clear(_gl.DEPTH_BUFFER_BIT);
    };
    this.clearStencil = function() {
      _gl.clear(_gl.STENCIL_BUFFER_BIT);
    };
    this.clearTarget = function(renderTarget, color, depth, stencil) {
      this.setRenderTarget(renderTarget);
      this.clear(color, depth, stencil);
    };
    this.resetGLState = resetGLState;
    this.dispose = function() {
      _canvas.removeEventListener('webglcontextlost', onContextLost, false);
    };
    function onContextLost(event) {
      event.preventDefault();
      resetGLState();
      setDefaultGLState();
      properties.clear();
    }
    ;
    function onTextureDispose(event) {
      var texture = event.target;
      texture.removeEventListener('dispose', onTextureDispose);
      deallocateTexture(texture);
      _infoMemory.textures--;
    }
    function onRenderTargetDispose(event) {
      var renderTarget = event.target;
      renderTarget.removeEventListener('dispose', onRenderTargetDispose);
      deallocateRenderTarget(renderTarget);
      _infoMemory.textures--;
    }
    function onMaterialDispose(event) {
      var material = event.target;
      material.removeEventListener('dispose', onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateTexture(texture) {
      var textureProperties = properties.get(texture);
      if (texture.image && textureProperties.__image__webglTextureCube) {
        _gl.deleteTexture(textureProperties.__image__webglTextureCube);
      } else {
        if (textureProperties.__webglInit === undefined)
          return;
        _gl.deleteTexture(textureProperties.__webglTexture);
      }
      properties.delete(texture);
    }
    function deallocateRenderTarget(renderTarget) {
      var renderTargetProperties = properties.get(renderTarget);
      var textureProperties = properties.get(renderTarget.texture);
      if (!renderTarget || textureProperties.__webglTexture === undefined)
        return;
      _gl.deleteTexture(textureProperties.__webglTexture);
      if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
        for (var i = 0; i < 6; i++) {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
          _gl.deleteRenderbuffer(renderTargetProperties.__webglRenderbuffer[i]);
        }
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
        _gl.deleteRenderbuffer(renderTargetProperties.__webglRenderbuffer);
      }
      properties.delete(renderTarget.texture);
      properties.delete(renderTarget);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReference(material);
      properties.delete(material);
    }
    function releaseMaterialProgramReference(material) {
      var programInfo = properties.get(material).program;
      material.program = undefined;
      if (programInfo !== undefined) {
        programCache.releaseProgram(programInfo);
      }
    }
    this.renderBufferImmediate = function(object, program, material) {
      state.initAttributes();
      var buffers = properties.get(object);
      if (object.hasPositions && !buffers.position)
        buffers.position = _gl.createBuffer();
      if (object.hasNormals && !buffers.normal)
        buffers.normal = _gl.createBuffer();
      if (object.hasUvs && !buffers.uv)
        buffers.uv = _gl.createBuffer();
      if (object.hasColors && !buffers.color)
        buffers.color = _gl.createBuffer();
      var attributes = program.getAttributes();
      if (object.hasPositions) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
        _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
        state.enableAttribute(attributes.position);
        _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
      }
      if (object.hasNormals) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
        if (material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading) {
          for (var i = 0,
              l = object.count * 3; i < l; i += 9) {
            var array = object.normalArray;
            var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
            var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
            var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
            array[i + 0] = nx;
            array[i + 1] = ny;
            array[i + 2] = nz;
            array[i + 3] = nx;
            array[i + 4] = ny;
            array[i + 5] = nz;
            array[i + 6] = nx;
            array[i + 7] = ny;
            array[i + 8] = nz;
          }
        }
        _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
        state.enableAttribute(attributes.normal);
        _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
      }
      if (object.hasUvs && material.map) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
        _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
        state.enableAttribute(attributes.uv);
        _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
      }
      if (object.hasColors && material.vertexColors !== THREE.NoColors) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
        _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
        state.enableAttribute(attributes.color);
        _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
      }
      state.disableUnusedAttributes();
      _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
      object.count = 0;
    };
    this.renderBufferDirect = function(camera, lights, fog, geometry, material, object, group) {
      setMaterial(material);
      var program = setProgram(camera, lights, fog, material, object);
      var updateBuffers = false;
      var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
      if (geometryProgram !== _currentGeometryProgram) {
        _currentGeometryProgram = geometryProgram;
        updateBuffers = true;
      }
      var morphTargetInfluences = object.morphTargetInfluences;
      if (morphTargetInfluences !== undefined) {
        var activeInfluences = [];
        for (var i = 0,
            l = morphTargetInfluences.length; i < l; i++) {
          var influence = morphTargetInfluences[i];
          activeInfluences.push([influence, i]);
        }
        activeInfluences.sort(numericalSort);
        if (activeInfluences.length > 8) {
          activeInfluences.length = 8;
        }
        var morphAttributes = geometry.morphAttributes;
        for (var i = 0,
            l = activeInfluences.length; i < l; i++) {
          var influence = activeInfluences[i];
          morphInfluences[i] = influence[0];
          if (influence[0] !== 0) {
            var index = influence[1];
            if (material.morphTargets === true && morphAttributes.position)
              geometry.addAttribute('morphTarget' + i, morphAttributes.position[index]);
            if (material.morphNormals === true && morphAttributes.normal)
              geometry.addAttribute('morphNormal' + i, morphAttributes.normal[index]);
          } else {
            if (material.morphTargets === true)
              geometry.removeAttribute('morphTarget' + i);
            if (material.morphNormals === true)
              geometry.removeAttribute('morphNormal' + i);
          }
        }
        var uniforms = program.getUniforms();
        if (uniforms.morphTargetInfluences !== null) {
          _gl.uniform1fv(uniforms.morphTargetInfluences, morphInfluences);
        }
        updateBuffers = true;
      }
      var index = geometry.index;
      var position = geometry.attributes.position;
      if (material.wireframe === true) {
        index = objects.getWireframeAttribute(geometry);
      }
      var renderer;
      if (index !== null) {
        renderer = indexedBufferRenderer;
        renderer.setIndex(index);
      } else {
        renderer = bufferRenderer;
      }
      if (updateBuffers) {
        setupVertexAttributes(material, program, geometry);
        if (index !== null) {
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer(index));
        }
      }
      var dataStart = 0;
      var dataCount = Infinity;
      if (index !== null) {
        dataCount = index.count;
      } else if (position !== undefined) {
        dataCount = position.count;
      }
      var rangeStart = geometry.drawRange.start;
      var rangeCount = geometry.drawRange.count;
      var groupStart = group !== null ? group.start : 0;
      var groupCount = group !== null ? group.count : Infinity;
      var drawStart = Math.max(dataStart, rangeStart, groupStart);
      var drawEnd = Math.min(dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
      var drawCount = Math.max(0, drawEnd - drawStart + 1);
      if (object instanceof THREE.Mesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * pixelRatio);
          renderer.setMode(_gl.LINES);
        } else {
          renderer.setMode(_gl.TRIANGLES);
        }
        if (geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0) {
          renderer.renderInstances(geometry);
        } else {
          renderer.render(drawStart, drawCount);
        }
      } else if (object instanceof THREE.Line) {
        var lineWidth = material.linewidth;
        if (lineWidth === undefined)
          lineWidth = 1;
        state.setLineWidth(lineWidth * pixelRatio);
        if (object instanceof THREE.LineSegments) {
          renderer.setMode(_gl.LINES);
        } else {
          renderer.setMode(_gl.LINE_STRIP);
        }
        renderer.render(drawStart, drawCount);
      } else if (object instanceof THREE.Points) {
        renderer.setMode(_gl.POINTS);
        renderer.render(drawStart, drawCount);
      }
    };
    function setupVertexAttributes(material, program, geometry, startIndex) {
      var extension;
      if (geometry instanceof THREE.InstancedBufferGeometry) {
        extension = extensions.get('ANGLE_instanced_arrays');
        if (extension === null) {
          console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
          return;
        }
      }
      if (startIndex === undefined)
        startIndex = 0;
      state.initAttributes();
      var geometryAttributes = geometry.attributes;
      var programAttributes = program.getAttributes();
      var materialDefaultAttributeValues = material.defaultAttributeValues;
      for (var name in programAttributes) {
        var programAttribute = programAttributes[name];
        if (programAttribute >= 0) {
          var geometryAttribute = geometryAttributes[name];
          if (geometryAttribute !== undefined) {
            var size = geometryAttribute.itemSize;
            var buffer = objects.getAttributeBuffer(geometryAttribute);
            if (geometryAttribute instanceof THREE.InterleavedBufferAttribute) {
              var data = geometryAttribute.data;
              var stride = data.stride;
              var offset = geometryAttribute.offset;
              if (data instanceof THREE.InstancedInterleavedBuffer) {
                state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension);
                if (geometry.maxInstancedCount === undefined) {
                  geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                }
              } else {
                state.enableAttribute(programAttribute);
              }
              _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
              _gl.vertexAttribPointer(programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT);
            } else {
              if (geometryAttribute instanceof THREE.InstancedBufferAttribute) {
                state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension);
                if (geometry.maxInstancedCount === undefined) {
                  geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                }
              } else {
                state.enableAttribute(programAttribute);
              }
              _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
              _gl.vertexAttribPointer(programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4);
            }
          } else if (materialDefaultAttributeValues !== undefined) {
            var value = materialDefaultAttributeValues[name];
            if (value !== undefined) {
              switch (value.length) {
                case 2:
                  _gl.vertexAttrib2fv(programAttribute, value);
                  break;
                case 3:
                  _gl.vertexAttrib3fv(programAttribute, value);
                  break;
                case 4:
                  _gl.vertexAttrib4fv(programAttribute, value);
                  break;
                default:
                  _gl.vertexAttrib1fv(programAttribute, value);
              }
            }
          }
        }
      }
      state.disableUnusedAttributes();
    }
    function numericalSort(a, b) {
      return b[0] - a[0];
    }
    function painterSortStable(a, b) {
      if (a.object.renderOrder !== b.object.renderOrder) {
        return a.object.renderOrder - b.object.renderOrder;
      } else if (a.material.id !== b.material.id) {
        return a.material.id - b.material.id;
      } else if (a.z !== b.z) {
        return a.z - b.z;
      } else {
        return a.id - b.id;
      }
    }
    function reversePainterSortStable(a, b) {
      if (a.object.renderOrder !== b.object.renderOrder) {
        return a.object.renderOrder - b.object.renderOrder;
      }
      if (a.z !== b.z) {
        return b.z - a.z;
      } else {
        return a.id - b.id;
      }
    }
    this.render = function(scene, camera, renderTarget, forceClear) {
      if (camera instanceof THREE.Camera === false) {
        console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
        return;
      }
      var fog = scene.fog;
      _currentGeometryProgram = '';
      _currentMaterialId = -1;
      _currentCamera = null;
      _lightsNeedUpdate = true;
      if (scene.autoUpdate === true)
        scene.updateMatrixWorld();
      if (camera.parent === null)
        camera.updateMatrixWorld();
      camera.matrixWorldInverse.getInverse(camera.matrixWorld);
      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromMatrix(_projScreenMatrix);
      lights.length = 0;
      opaqueObjectsLastIndex = -1;
      transparentObjectsLastIndex = -1;
      sprites.length = 0;
      lensFlares.length = 0;
      projectObject(scene, camera);
      opaqueObjects.length = opaqueObjectsLastIndex + 1;
      transparentObjects.length = transparentObjectsLastIndex + 1;
      if (_this.sortObjects === true) {
        opaqueObjects.sort(painterSortStable);
        transparentObjects.sort(reversePainterSortStable);
      }
      shadowMap.render(scene);
      _infoRender.calls = 0;
      _infoRender.vertices = 0;
      _infoRender.faces = 0;
      _infoRender.points = 0;
      this.setRenderTarget(renderTarget);
      if (this.autoClear || forceClear) {
        this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
      }
      if (scene.overrideMaterial) {
        var overrideMaterial = scene.overrideMaterial;
        renderObjects(opaqueObjects, camera, lights, fog, overrideMaterial);
        renderObjects(transparentObjects, camera, lights, fog, overrideMaterial);
      } else {
        state.setBlending(THREE.NoBlending);
        renderObjects(opaqueObjects, camera, lights, fog);
        renderObjects(transparentObjects, camera, lights, fog);
      }
      spritePlugin.render(scene, camera);
      lensFlarePlugin.render(scene, camera, _currentWidth, _currentHeight);
      if (renderTarget) {
        var texture = renderTarget.texture;
        var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
        if (texture.generateMipmaps && isTargetPowerOfTwo && texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
          updateRenderTargetMipmap(renderTarget);
        }
      }
      state.setDepthTest(true);
      state.setDepthWrite(true);
      state.setColorWrite(true);
    };
    function pushRenderItem(object, geometry, material, z, group) {
      var array,
          index;
      if (material.transparent) {
        array = transparentObjects;
        index = ++transparentObjectsLastIndex;
      } else {
        array = opaqueObjects;
        index = ++opaqueObjectsLastIndex;
      }
      var renderItem = array[index];
      if (renderItem !== undefined) {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.z = _vector3.z;
        renderItem.group = group;
      } else {
        renderItem = {
          id: object.id,
          object: object,
          geometry: geometry,
          material: material,
          z: _vector3.z,
          group: group
        };
        array.push(renderItem);
      }
    }
    function projectObject(object, camera) {
      if (object.visible === false)
        return;
      if ((object.channels.mask & camera.channels.mask) !== 0) {
        if (object instanceof THREE.Light) {
          lights.push(object);
        } else if (object instanceof THREE.Sprite) {
          sprites.push(object);
        } else if (object instanceof THREE.LensFlare) {
          lensFlares.push(object);
        } else if (object instanceof THREE.ImmediateRenderObject) {
          if (_this.sortObjects === true) {
            _vector3.setFromMatrixPosition(object.matrixWorld);
            _vector3.applyProjection(_projScreenMatrix);
          }
          pushRenderItem(object, null, object.material, _vector3.z, null);
        } else if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) {
          if (object instanceof THREE.SkinnedMesh) {
            object.skeleton.update();
          }
          if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {
            var material = object.material;
            if (material.visible === true) {
              if (_this.sortObjects === true) {
                _vector3.setFromMatrixPosition(object.matrixWorld);
                _vector3.applyProjection(_projScreenMatrix);
              }
              var geometry = objects.update(object);
              if (material instanceof THREE.MeshFaceMaterial) {
                var groups = geometry.groups;
                var materials = material.materials;
                for (var i = 0,
                    l = groups.length; i < l; i++) {
                  var group = groups[i];
                  var groupMaterial = materials[group.materialIndex];
                  if (groupMaterial.visible === true) {
                    pushRenderItem(object, geometry, groupMaterial, _vector3.z, group);
                  }
                }
              } else {
                pushRenderItem(object, geometry, material, _vector3.z, null);
              }
            }
          }
        }
      }
      var children = object.children;
      for (var i = 0,
          l = children.length; i < l; i++) {
        projectObject(children[i], camera);
      }
    }
    function renderObjects(renderList, camera, lights, fog, overrideMaterial) {
      for (var i = 0,
          l = renderList.length; i < l; i++) {
        var renderItem = renderList[i];
        var object = renderItem.object;
        var geometry = renderItem.geometry;
        var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
        var group = renderItem.group;
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        if (object instanceof THREE.ImmediateRenderObject) {
          setMaterial(material);
          var program = setProgram(camera, lights, fog, material, object);
          _currentGeometryProgram = '';
          object.render(function(object) {
            _this.renderBufferImmediate(object, program, material);
          });
        } else {
          _this.renderBufferDirect(camera, lights, fog, geometry, material, object, group);
        }
      }
    }
    function initMaterial(material, lights, fog, object) {
      var materialProperties = properties.get(material);
      var parameters = programCache.getParameters(material, lights, fog, object);
      var code = programCache.getProgramCode(material, parameters);
      var program = materialProperties.program;
      var programChange = true;
      if (program === undefined) {
        material.addEventListener('dispose', onMaterialDispose);
      } else if (program.code !== code) {
        releaseMaterialProgramReference(material);
      } else if (parameters.shaderID !== undefined) {
        return;
      } else {
        programChange = false;
      }
      if (programChange) {
        if (parameters.shaderID) {
          var shader = THREE.ShaderLib[parameters.shaderID];
          materialProperties.__webglShader = {
            name: material.type,
            uniforms: THREE.UniformsUtils.clone(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader
          };
        } else {
          materialProperties.__webglShader = {
            name: material.type,
            uniforms: material.uniforms,
            vertexShader: material.vertexShader,
            fragmentShader: material.fragmentShader
          };
        }
        material.__webglShader = materialProperties.__webglShader;
        program = programCache.acquireProgram(material, parameters, code);
        materialProperties.program = program;
        material.program = program;
      }
      var attributes = program.getAttributes();
      if (material.morphTargets) {
        material.numSupportedMorphTargets = 0;
        for (var i = 0; i < _this.maxMorphTargets; i++) {
          if (attributes['morphTarget' + i] >= 0) {
            material.numSupportedMorphTargets++;
          }
        }
      }
      if (material.morphNormals) {
        material.numSupportedMorphNormals = 0;
        for (i = 0; i < _this.maxMorphNormals; i++) {
          if (attributes['morphNormal' + i] >= 0) {
            material.numSupportedMorphNormals++;
          }
        }
      }
      materialProperties.uniformsList = [];
      var uniformLocations = materialProperties.program.getUniforms();
      for (var u in materialProperties.__webglShader.uniforms) {
        var location = uniformLocations[u];
        if (location) {
          materialProperties.uniformsList.push([materialProperties.__webglShader.uniforms[u], location]);
        }
      }
    }
    function setMaterial(material) {
      setMaterialFaces(material);
      if (material.transparent === true) {
        state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha);
      } else {
        state.setBlending(THREE.NoBlending);
      }
      state.setDepthFunc(material.depthFunc);
      state.setDepthTest(material.depthTest);
      state.setDepthWrite(material.depthWrite);
      state.setColorWrite(material.colorWrite);
      state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    }
    function setMaterialFaces(material) {
      material.side !== THREE.DoubleSide ? state.enable(_gl.CULL_FACE) : state.disable(_gl.CULL_FACE);
      state.setFlipSided(material.side === THREE.BackSide);
    }
    function setProgram(camera, lights, fog, material, object) {
      _usedTextureUnits = 0;
      var materialProperties = properties.get(material);
      if (material.needsUpdate || !materialProperties.program) {
        initMaterial(material, lights, fog, object);
        material.needsUpdate = false;
      }
      var refreshProgram = false;
      var refreshMaterial = false;
      var refreshLights = false;
      var program = materialProperties.program,
          p_uniforms = program.getUniforms(),
          m_uniforms = materialProperties.__webglShader.uniforms;
      if (program.id !== _currentProgram) {
        _gl.useProgram(program.program);
        _currentProgram = program.id;
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        if (_currentMaterialId === -1)
          refreshLights = true;
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || camera !== _currentCamera) {
        _gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
        if (capabilities.logarithmicDepthBuffer) {
          _gl.uniform1f(p_uniforms.logDepthBufFC, 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
        }
        if (camera !== _currentCamera)
          _currentCamera = camera;
        if (material instanceof THREE.ShaderMaterial || material instanceof THREE.MeshPhongMaterial || material.envMap) {
          if (p_uniforms.cameraPosition !== undefined) {
            _vector3.setFromMatrixPosition(camera.matrixWorld);
            _gl.uniform3f(p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z);
          }
        }
        if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshBasicMaterial || material instanceof THREE.ShaderMaterial || material.skinning) {
          if (p_uniforms.viewMatrix !== undefined) {
            _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);
          }
        }
      }
      if (material.skinning) {
        if (object.bindMatrix && p_uniforms.bindMatrix !== undefined) {
          _gl.uniformMatrix4fv(p_uniforms.bindMatrix, false, object.bindMatrix.elements);
        }
        if (object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined) {
          _gl.uniformMatrix4fv(p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements);
        }
        if (capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture) {
          if (p_uniforms.boneTexture !== undefined) {
            var textureUnit = getTextureUnit();
            _gl.uniform1i(p_uniforms.boneTexture, textureUnit);
            _this.setTexture(object.skeleton.boneTexture, textureUnit);
          }
          if (p_uniforms.boneTextureWidth !== undefined) {
            _gl.uniform1i(p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth);
          }
          if (p_uniforms.boneTextureHeight !== undefined) {
            _gl.uniform1i(p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight);
          }
        } else if (object.skeleton && object.skeleton.boneMatrices) {
          if (p_uniforms.boneGlobalMatrices !== undefined) {
            _gl.uniformMatrix4fv(p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices);
          }
        }
      }
      if (refreshMaterial) {
        if (fog && material.fog) {
          refreshUniformsFog(m_uniforms, fog);
        }
        if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material.lights) {
          if (_lightsNeedUpdate) {
            refreshLights = true;
            setupLights(lights, camera);
            _lightsNeedUpdate = false;
          }
          if (refreshLights) {
            refreshUniformsLights(m_uniforms, _lights);
            markUniformsLightsNeedsUpdate(m_uniforms, true);
          } else {
            markUniformsLightsNeedsUpdate(m_uniforms, false);
          }
        }
        if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {
          refreshUniformsCommon(m_uniforms, material);
        }
        if (material instanceof THREE.LineBasicMaterial) {
          refreshUniformsLine(m_uniforms, material);
        } else if (material instanceof THREE.LineDashedMaterial) {
          refreshUniformsLine(m_uniforms, material);
          refreshUniformsDash(m_uniforms, material);
        } else if (material instanceof THREE.PointsMaterial) {
          refreshUniformsParticle(m_uniforms, material);
        } else if (material instanceof THREE.MeshPhongMaterial) {
          refreshUniformsPhong(m_uniforms, material);
        } else if (material instanceof THREE.MeshDepthMaterial) {
          m_uniforms.mNear.value = camera.near;
          m_uniforms.mFar.value = camera.far;
          m_uniforms.opacity.value = material.opacity;
        } else if (material instanceof THREE.MeshNormalMaterial) {
          m_uniforms.opacity.value = material.opacity;
        }
        if (object.receiveShadow && !material._shadowPass) {
          refreshUniformsShadow(m_uniforms, lights, camera);
        }
        loadUniformsGeneric(materialProperties.uniformsList);
      }
      loadUniformsMatrices(p_uniforms, object);
      if (p_uniforms.modelMatrix !== undefined) {
        _gl.uniformMatrix4fv(p_uniforms.modelMatrix, false, object.matrixWorld.elements);
      }
      return program;
    }
    function refreshUniformsCommon(uniforms, material) {
      uniforms.opacity.value = material.opacity;
      uniforms.diffuse.value = material.color;
      if (material.emissive) {
        uniforms.emissive.value = material.emissive;
      }
      uniforms.map.value = material.map;
      uniforms.specularMap.value = material.specularMap;
      uniforms.alphaMap.value = material.alphaMap;
      if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
      }
      var uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.specularMap) {
        uvScaleMap = material.specularMap;
      } else if (material.displacementMap) {
        uvScaleMap = material.displacementMap;
      } else if (material.normalMap) {
        uvScaleMap = material.normalMap;
      } else if (material.bumpMap) {
        uvScaleMap = material.bumpMap;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      } else if (material.emissiveMap) {
        uvScaleMap = material.emissiveMap;
      }
      if (uvScaleMap !== undefined) {
        if (uvScaleMap instanceof THREE.WebGLRenderTarget)
          uvScaleMap = uvScaleMap.texture;
        var offset = uvScaleMap.offset;
        var repeat = uvScaleMap.repeat;
        uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
      }
      uniforms.envMap.value = material.envMap;
      uniforms.flipEnvMap.value = (material.envMap instanceof THREE.WebGLRenderTargetCube) ? 1 : -1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    function refreshUniformsLine(uniforms, material) {
      uniforms.diffuse.value = material.color;
      uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;
    }
    function refreshUniformsParticle(uniforms, material) {
      uniforms.psColor.value = material.color;
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size;
      uniforms.scale.value = _canvas.height / 2.0;
      uniforms.map.value = material.map;
      if (material.map !== null) {
        var offset = material.map.offset;
        var repeat = material.map.repeat;
        uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
      }
    }
    function refreshUniformsFog(uniforms, fog) {
      uniforms.fogColor.value = fog.color;
      if (fog instanceof THREE.Fog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
      } else if (fog instanceof THREE.FogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }
    function refreshUniformsPhong(uniforms, material) {
      uniforms.specular.value = material.specular;
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);
      if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsLights(uniforms, lights) {
      uniforms.ambientLightColor.value = lights.ambient;
      uniforms.directionalLightColor.value = lights.directional.colors;
      uniforms.directionalLightDirection.value = lights.directional.positions;
      uniforms.pointLightColor.value = lights.point.colors;
      uniforms.pointLightPosition.value = lights.point.positions;
      uniforms.pointLightDistance.value = lights.point.distances;
      uniforms.pointLightDecay.value = lights.point.decays;
      uniforms.spotLightColor.value = lights.spot.colors;
      uniforms.spotLightPosition.value = lights.spot.positions;
      uniforms.spotLightDistance.value = lights.spot.distances;
      uniforms.spotLightDirection.value = lights.spot.directions;
      uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
      uniforms.spotLightExponent.value = lights.spot.exponents;
      uniforms.spotLightDecay.value = lights.spot.decays;
      uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
      uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
      uniforms.hemisphereLightDirection.value = lights.hemi.positions;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.directionalLightColor.needsUpdate = value;
      uniforms.directionalLightDirection.needsUpdate = value;
      uniforms.pointLightColor.needsUpdate = value;
      uniforms.pointLightPosition.needsUpdate = value;
      uniforms.pointLightDistance.needsUpdate = value;
      uniforms.pointLightDecay.needsUpdate = value;
      uniforms.spotLightColor.needsUpdate = value;
      uniforms.spotLightPosition.needsUpdate = value;
      uniforms.spotLightDistance.needsUpdate = value;
      uniforms.spotLightDirection.needsUpdate = value;
      uniforms.spotLightAngleCos.needsUpdate = value;
      uniforms.spotLightExponent.needsUpdate = value;
      uniforms.spotLightDecay.needsUpdate = value;
      uniforms.hemisphereLightSkyColor.needsUpdate = value;
      uniforms.hemisphereLightGroundColor.needsUpdate = value;
      uniforms.hemisphereLightDirection.needsUpdate = value;
    }
    function refreshUniformsShadow(uniforms, lights, camera) {
      if (uniforms.shadowMatrix) {
        var j = 0;
        for (var i = 0,
            il = lights.length; i < il; i++) {
          var light = lights[i];
          if (light.castShadow === true) {
            if (light instanceof THREE.PointLight || light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight) {
              var shadow = light.shadow;
              if (light instanceof THREE.PointLight) {
                _vector3.setFromMatrixPosition(light.matrixWorld).negate();
                shadow.matrix.identity().setPosition(_vector3);
                uniforms.shadowDarkness.value[j] = -shadow.darkness;
              } else {
                uniforms.shadowDarkness.value[j] = shadow.darkness;
              }
              uniforms.shadowMatrix.value[j] = shadow.matrix;
              uniforms.shadowMap.value[j] = shadow.map;
              uniforms.shadowMapSize.value[j] = shadow.mapSize;
              uniforms.shadowBias.value[j] = shadow.bias;
              j++;
            }
          }
        }
      }
    }
    function loadUniformsMatrices(uniforms, object) {
      _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, object.modelViewMatrix.elements);
      if (uniforms.normalMatrix) {
        _gl.uniformMatrix3fv(uniforms.normalMatrix, false, object.normalMatrix.elements);
      }
    }
    function getTextureUnit() {
      var textureUnit = _usedTextureUnits;
      if (textureUnit >= capabilities.maxTextures) {
        console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
      }
      _usedTextureUnits += 1;
      return textureUnit;
    }
    function loadUniformsGeneric(uniforms) {
      var texture,
          textureUnit;
      for (var j = 0,
          jl = uniforms.length; j < jl; j++) {
        var uniform = uniforms[j][0];
        if (uniform.needsUpdate === false)
          continue;
        var type = uniform.type;
        var value = uniform.value;
        var location = uniforms[j][1];
        switch (type) {
          case '1i':
            _gl.uniform1i(location, value);
            break;
          case '1f':
            _gl.uniform1f(location, value);
            break;
          case '2f':
            _gl.uniform2f(location, value[0], value[1]);
            break;
          case '3f':
            _gl.uniform3f(location, value[0], value[1], value[2]);
            break;
          case '4f':
            _gl.uniform4f(location, value[0], value[1], value[2], value[3]);
            break;
          case '1iv':
            _gl.uniform1iv(location, value);
            break;
          case '3iv':
            _gl.uniform3iv(location, value);
            break;
          case '1fv':
            _gl.uniform1fv(location, value);
            break;
          case '2fv':
            _gl.uniform2fv(location, value);
            break;
          case '3fv':
            _gl.uniform3fv(location, value);
            break;
          case '4fv':
            _gl.uniform4fv(location, value);
            break;
          case 'Matrix3fv':
            _gl.uniformMatrix3fv(location, false, value);
            break;
          case 'Matrix4fv':
            _gl.uniformMatrix4fv(location, false, value);
            break;
          case 'i':
            _gl.uniform1i(location, value);
            break;
          case 'f':
            _gl.uniform1f(location, value);
            break;
          case 'v2':
            _gl.uniform2f(location, value.x, value.y);
            break;
          case 'v3':
            _gl.uniform3f(location, value.x, value.y, value.z);
            break;
          case 'v4':
            _gl.uniform4f(location, value.x, value.y, value.z, value.w);
            break;
          case 'c':
            _gl.uniform3f(location, value.r, value.g, value.b);
            break;
          case 'iv1':
            _gl.uniform1iv(location, value);
            break;
          case 'iv':
            _gl.uniform3iv(location, value);
            break;
          case 'fv1':
            _gl.uniform1fv(location, value);
            break;
          case 'fv':
            _gl.uniform3fv(location, value);
            break;
          case 'v2v':
            if (uniform._array === undefined) {
              uniform._array = new Float32Array(2 * value.length);
            }
            for (var i = 0,
                i2 = 0,
                il = value.length; i < il; i++, i2 += 2) {
              uniform._array[i2 + 0] = value[i].x;
              uniform._array[i2 + 1] = value[i].y;
            }
            _gl.uniform2fv(location, uniform._array);
            break;
          case 'v3v':
            if (uniform._array === undefined) {
              uniform._array = new Float32Array(3 * value.length);
            }
            for (var i = 0,
                i3 = 0,
                il = value.length; i < il; i++, i3 += 3) {
              uniform._array[i3 + 0] = value[i].x;
              uniform._array[i3 + 1] = value[i].y;
              uniform._array[i3 + 2] = value[i].z;
            }
            _gl.uniform3fv(location, uniform._array);
            break;
          case 'v4v':
            if (uniform._array === undefined) {
              uniform._array = new Float32Array(4 * value.length);
            }
            for (var i = 0,
                i4 = 0,
                il = value.length; i < il; i++, i4 += 4) {
              uniform._array[i4 + 0] = value[i].x;
              uniform._array[i4 + 1] = value[i].y;
              uniform._array[i4 + 2] = value[i].z;
              uniform._array[i4 + 3] = value[i].w;
            }
            _gl.uniform4fv(location, uniform._array);
            break;
          case 'm3':
            _gl.uniformMatrix3fv(location, false, value.elements);
            break;
          case 'm3v':
            if (uniform._array === undefined) {
              uniform._array = new Float32Array(9 * value.length);
            }
            for (var i = 0,
                il = value.length; i < il; i++) {
              value[i].flattenToArrayOffset(uniform._array, i * 9);
            }
            _gl.uniformMatrix3fv(location, false, uniform._array);
            break;
          case 'm4':
            _gl.uniformMatrix4fv(location, false, value.elements);
            break;
          case 'm4v':
            if (uniform._array === undefined) {
              uniform._array = new Float32Array(16 * value.length);
            }
            for (var i = 0,
                il = value.length; i < il; i++) {
              value[i].flattenToArrayOffset(uniform._array, i * 16);
            }
            _gl.uniformMatrix4fv(location, false, uniform._array);
            break;
          case 't':
            texture = value;
            textureUnit = getTextureUnit();
            _gl.uniform1i(location, textureUnit);
            if (!texture)
              continue;
            if (texture instanceof THREE.CubeTexture || (Array.isArray(texture.image) && texture.image.length === 6)) {
              setCubeTexture(texture, textureUnit);
            } else if (texture instanceof THREE.WebGLRenderTargetCube) {
              setCubeTextureDynamic(texture.texture, textureUnit);
            } else if (texture instanceof THREE.WebGLRenderTarget) {
              _this.setTexture(texture.texture, textureUnit);
            } else {
              _this.setTexture(texture, textureUnit);
            }
            break;
          case 'tv':
            if (uniform._array === undefined) {
              uniform._array = [];
            }
            for (var i = 0,
                il = uniform.value.length; i < il; i++) {
              uniform._array[i] = getTextureUnit();
            }
            _gl.uniform1iv(location, uniform._array);
            for (var i = 0,
                il = uniform.value.length; i < il; i++) {
              texture = uniform.value[i];
              textureUnit = uniform._array[i];
              if (!texture)
                continue;
              if (texture instanceof THREE.CubeTexture || (texture.image instanceof Array && texture.image.length === 6)) {
                setCubeTexture(texture, textureUnit);
              } else if (texture instanceof THREE.WebGLRenderTarget) {
                _this.setTexture(texture.texture, textureUnit);
              } else if (texture instanceof THREE.WebGLRenderTargetCube) {
                setCubeTextureDynamic(texture.texture, textureUnit);
              } else {
                _this.setTexture(texture, textureUnit);
              }
            }
            break;
          default:
            console.warn('THREE.WebGLRenderer: Unknown uniform type: ' + type);
        }
      }
    }
    function setColorLinear(array, offset, color, intensity) {
      array[offset + 0] = color.r * intensity;
      array[offset + 1] = color.g * intensity;
      array[offset + 2] = color.b * intensity;
    }
    function setupLights(lights, camera) {
      var l,
          ll,
          light,
          r = 0,
          g = 0,
          b = 0,
          color,
          skyColor,
          groundColor,
          intensity,
          distance,
          zlights = _lights,
          viewMatrix = camera.matrixWorldInverse,
          dirColors = zlights.directional.colors,
          dirPositions = zlights.directional.positions,
          pointColors = zlights.point.colors,
          pointPositions = zlights.point.positions,
          pointDistances = zlights.point.distances,
          pointDecays = zlights.point.decays,
          spotColors = zlights.spot.colors,
          spotPositions = zlights.spot.positions,
          spotDistances = zlights.spot.distances,
          spotDirections = zlights.spot.directions,
          spotAnglesCos = zlights.spot.anglesCos,
          spotExponents = zlights.spot.exponents,
          spotDecays = zlights.spot.decays,
          hemiSkyColors = zlights.hemi.skyColors,
          hemiGroundColors = zlights.hemi.groundColors,
          hemiPositions = zlights.hemi.positions,
          dirLength = 0,
          pointLength = 0,
          spotLength = 0,
          hemiLength = 0,
          dirCount = 0,
          pointCount = 0,
          spotCount = 0,
          hemiCount = 0,
          dirOffset = 0,
          pointOffset = 0,
          spotOffset = 0,
          hemiOffset = 0;
      for (l = 0, ll = lights.length; l < ll; l++) {
        light = lights[l];
        color = light.color;
        intensity = light.intensity;
        distance = light.distance;
        if (light instanceof THREE.AmbientLight) {
          if (!light.visible)
            continue;
          r += color.r;
          g += color.g;
          b += color.b;
        } else if (light instanceof THREE.DirectionalLight) {
          dirCount += 1;
          if (!light.visible)
            continue;
          _direction.setFromMatrixPosition(light.matrixWorld);
          _vector3.setFromMatrixPosition(light.target.matrixWorld);
          _direction.sub(_vector3);
          _direction.transformDirection(viewMatrix);
          dirOffset = dirLength * 3;
          dirPositions[dirOffset + 0] = _direction.x;
          dirPositions[dirOffset + 1] = _direction.y;
          dirPositions[dirOffset + 2] = _direction.z;
          setColorLinear(dirColors, dirOffset, color, intensity);
          dirLength += 1;
        } else if (light instanceof THREE.PointLight) {
          pointCount += 1;
          if (!light.visible)
            continue;
          pointOffset = pointLength * 3;
          setColorLinear(pointColors, pointOffset, color, intensity);
          _vector3.setFromMatrixPosition(light.matrixWorld);
          _vector3.applyMatrix4(viewMatrix);
          pointPositions[pointOffset + 0] = _vector3.x;
          pointPositions[pointOffset + 1] = _vector3.y;
          pointPositions[pointOffset + 2] = _vector3.z;
          pointDistances[pointLength] = distance;
          pointDecays[pointLength] = (light.distance === 0) ? 0.0 : light.decay;
          pointLength += 1;
        } else if (light instanceof THREE.SpotLight) {
          spotCount += 1;
          if (!light.visible)
            continue;
          spotOffset = spotLength * 3;
          setColorLinear(spotColors, spotOffset, color, intensity);
          _direction.setFromMatrixPosition(light.matrixWorld);
          _vector3.copy(_direction).applyMatrix4(viewMatrix);
          spotPositions[spotOffset + 0] = _vector3.x;
          spotPositions[spotOffset + 1] = _vector3.y;
          spotPositions[spotOffset + 2] = _vector3.z;
          spotDistances[spotLength] = distance;
          _vector3.setFromMatrixPosition(light.target.matrixWorld);
          _direction.sub(_vector3);
          _direction.transformDirection(viewMatrix);
          spotDirections[spotOffset + 0] = _direction.x;
          spotDirections[spotOffset + 1] = _direction.y;
          spotDirections[spotOffset + 2] = _direction.z;
          spotAnglesCos[spotLength] = Math.cos(light.angle);
          spotExponents[spotLength] = light.exponent;
          spotDecays[spotLength] = (light.distance === 0) ? 0.0 : light.decay;
          spotLength += 1;
        } else if (light instanceof THREE.HemisphereLight) {
          hemiCount += 1;
          if (!light.visible)
            continue;
          _direction.setFromMatrixPosition(light.matrixWorld);
          _direction.transformDirection(viewMatrix);
          hemiOffset = hemiLength * 3;
          hemiPositions[hemiOffset + 0] = _direction.x;
          hemiPositions[hemiOffset + 1] = _direction.y;
          hemiPositions[hemiOffset + 2] = _direction.z;
          skyColor = light.color;
          groundColor = light.groundColor;
          setColorLinear(hemiSkyColors, hemiOffset, skyColor, intensity);
          setColorLinear(hemiGroundColors, hemiOffset, groundColor, intensity);
          hemiLength += 1;
        }
      }
      for (l = dirLength * 3, ll = Math.max(dirColors.length, dirCount * 3); l < ll; l++)
        dirColors[l] = 0.0;
      for (l = pointLength * 3, ll = Math.max(pointColors.length, pointCount * 3); l < ll; l++)
        pointColors[l] = 0.0;
      for (l = spotLength * 3, ll = Math.max(spotColors.length, spotCount * 3); l < ll; l++)
        spotColors[l] = 0.0;
      for (l = hemiLength * 3, ll = Math.max(hemiSkyColors.length, hemiCount * 3); l < ll; l++)
        hemiSkyColors[l] = 0.0;
      for (l = hemiLength * 3, ll = Math.max(hemiGroundColors.length, hemiCount * 3); l < ll; l++)
        hemiGroundColors[l] = 0.0;
      zlights.directional.length = dirLength;
      zlights.point.length = pointLength;
      zlights.spot.length = spotLength;
      zlights.hemi.length = hemiLength;
      zlights.ambient[0] = r;
      zlights.ambient[1] = g;
      zlights.ambient[2] = b;
    }
    this.setFaceCulling = function(cullFace, frontFaceDirection) {
      if (cullFace === THREE.CullFaceNone) {
        state.disable(_gl.CULL_FACE);
      } else {
        if (frontFaceDirection === THREE.FrontFaceDirectionCW) {
          _gl.frontFace(_gl.CW);
        } else {
          _gl.frontFace(_gl.CCW);
        }
        if (cullFace === THREE.CullFaceBack) {
          _gl.cullFace(_gl.BACK);
        } else if (cullFace === THREE.CullFaceFront) {
          _gl.cullFace(_gl.FRONT);
        } else {
          _gl.cullFace(_gl.FRONT_AND_BACK);
        }
        state.enable(_gl.CULL_FACE);
      }
    };
    function setTextureParameters(textureType, texture, isImagePowerOfTwo) {
      var extension;
      if (isImagePowerOfTwo) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
        _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
        _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
      } else {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
        if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping) {
          console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture);
        }
        _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
        _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
        if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
          console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture);
        }
      }
      extension = extensions.get('EXT_texture_filter_anisotropic');
      if (extension) {
        if (texture.type === THREE.FloatType && extensions.get('OES_texture_float_linear') === null)
          return;
        if (texture.type === THREE.HalfFloatType && extensions.get('OES_texture_half_float_linear') === null)
          return;
        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
          _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, _this.getMaxAnisotropy()));
          properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
      }
    }
    function uploadTexture(textureProperties, texture, slot) {
      if (textureProperties.__webglInit === undefined) {
        textureProperties.__webglInit = true;
        texture.addEventListener('dispose', onTextureDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        _infoMemory.textures++;
      }
      state.activeTexture(_gl.TEXTURE0 + slot);
      state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      texture.image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
      if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false) {
        texture.image = makePowerOfTwo(texture.image);
      }
      var image = texture.image,
          isImagePowerOfTwo = isPowerOfTwo(image),
          glFormat = paramThreeToGL(texture.format),
          glType = paramThreeToGL(texture.type);
      setTextureParameters(_gl.TEXTURE_2D, texture, isImagePowerOfTwo);
      var mipmap,
          mipmaps = texture.mipmaps;
      if (texture instanceof THREE.DataTexture) {
        if (mipmaps.length > 0 && isImagePowerOfTwo) {
          for (var i = 0,
              il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
          texture.generateMipmaps = false;
        } else {
          state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
        }
      } else if (texture instanceof THREE.CompressedTexture) {
        for (var i = 0,
            il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
            if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
              state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      } else {
        if (mipmaps.length > 0 && isImagePowerOfTwo) {
          for (var i = 0,
              il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
          }
          texture.generateMipmaps = false;
        } else {
          state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image);
        }
      }
      if (texture.generateMipmaps && isImagePowerOfTwo)
        _gl.generateMipmap(_gl.TEXTURE_2D);
      textureProperties.__version = texture.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    this.setTexture = function(texture, slot) {
      var textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        var image = texture.image;
        if (image === undefined) {
          console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);
          return;
        }
        if (image.complete === false) {
          console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);
          return;
        }
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(_gl.TEXTURE0 + slot);
      state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
    };
    function clampToMaxSize(image, maxSize) {
      if (image.width > maxSize || image.height > maxSize) {
        var scale = maxSize / Math.max(image.width, image.height);
        var canvas = document.createElement('canvas');
        canvas.width = Math.floor(image.width * scale);
        canvas.height = Math.floor(image.height * scale);
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
        console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
        return canvas;
      }
      return image;
    }
    function isPowerOfTwo(image) {
      return THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
      if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping)
        return true;
      if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter)
        return true;
      return false;
    }
    function makePowerOfTwo(image) {
      if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
        var canvas = document.createElement('canvas');
        canvas.width = THREE.Math.nearestPowerOfTwo(image.width);
        canvas.height = THREE.Math.nearestPowerOfTwo(image.height);
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, canvas.width, canvas.height);
        console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
        return canvas;
      }
      return image;
    }
    function setCubeTexture(texture, slot) {
      var textureProperties = properties.get(texture);
      if (texture.image.length === 6) {
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          if (!textureProperties.__image__webglTextureCube) {
            texture.addEventListener('dispose', onTextureDispose);
            textureProperties.__image__webglTextureCube = _gl.createTexture();
            _infoMemory.textures++;
          }
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
          var isCompressed = texture instanceof THREE.CompressedTexture;
          var isDataTexture = texture.image[0] instanceof THREE.DataTexture;
          var cubeImage = [];
          for (var i = 0; i < 6; i++) {
            if (_this.autoScaleCubemaps && !isCompressed && !isDataTexture) {
              cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
            } else {
              cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
            }
          }
          var image = cubeImage[0],
              isImagePowerOfTwo = isPowerOfTwo(image),
              glFormat = paramThreeToGL(texture.format),
              glType = paramThreeToGL(texture.type);
          setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo);
          for (var i = 0; i < 6; i++) {
            if (!isCompressed) {
              if (isDataTexture) {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
              }
            } else {
              var mipmap,
                  mipmaps = cubeImage[i].mipmaps;
              for (var j = 0,
                  jl = mipmaps.length; j < jl; j++) {
                mipmap = mipmaps[j];
                if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
                  if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                    state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  } else {
                    console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()");
                  }
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          }
          if (texture.generateMipmaps && isImagePowerOfTwo) {
            _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
          }
          textureProperties.__version = texture.version;
          if (texture.onUpdate)
            texture.onUpdate(texture);
        } else {
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
        }
      }
    }
    function setCubeTextureDynamic(texture, slot) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
    }
    function setupFrameBuffer(framebuffer, renderTarget, textureTarget) {
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
    }
    function setupRenderBuffer(renderbuffer, renderTarget) {
      _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
      if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
      } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
      }
    }
    this.setRenderTarget = function(renderTarget) {
      var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);
      if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
        var renderTargetProperties = properties.get(renderTarget);
        var textureProperties = properties.get(renderTarget.texture);
        if (renderTarget.depthBuffer === undefined)
          renderTarget.depthBuffer = true;
        if (renderTarget.stencilBuffer === undefined)
          renderTarget.stencilBuffer = true;
        renderTarget.addEventListener('dispose', onRenderTargetDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        _infoMemory.textures++;
        var isTargetPowerOfTwo = isPowerOfTwo(renderTarget),
            glFormat = paramThreeToGL(renderTarget.texture.format),
            glType = paramThreeToGL(renderTarget.texture.type);
        if (isCube) {
          renderTargetProperties.__webglFramebuffer = [];
          renderTargetProperties.__webglRenderbuffer = [];
          state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
          setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
          for (var i = 0; i < 6; i++) {
            renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
            renderTargetProperties.__webglRenderbuffer[i] = _gl.createRenderbuffer();
            state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            setupFrameBuffer(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
            setupRenderBuffer(renderTargetProperties.__webglRenderbuffer[i], renderTarget);
          }
          if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
            _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
        } else {
          renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
          if (renderTarget.shareDepthFrom) {
            renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;
          } else {
            renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();
          }
          state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
          setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
          state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
          setupFrameBuffer(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D);
          if (renderTarget.shareDepthFrom) {
            if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
              _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer);
            } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
              _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer);
            }
          } else {
            setupRenderBuffer(renderTargetProperties.__webglRenderbuffer, renderTarget);
          }
          if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
            _gl.generateMipmap(_gl.TEXTURE_2D);
        }
        if (isCube) {
          state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
        } else {
          state.bindTexture(_gl.TEXTURE_2D, null);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
      var framebuffer,
          width,
          height,
          vx,
          vy;
      if (renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        if (isCube) {
          framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];
        } else {
          framebuffer = renderTargetProperties.__webglFramebuffer;
        }
        width = renderTarget.width;
        height = renderTarget.height;
        vx = 0;
        vy = 0;
      } else {
        framebuffer = null;
        width = _viewportWidth;
        height = _viewportHeight;
        vx = _viewportX;
        vy = _viewportY;
      }
      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        _gl.viewport(vx, vy, width, height);
        _currentFramebuffer = framebuffer;
      }
      if (isCube) {
        var textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0);
      }
      _currentWidth = width;
      _currentHeight = height;
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
      if (renderTarget instanceof THREE.WebGLRenderTarget === false) {
        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
        return;
      }
      var framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (framebuffer) {
        var restore = false;
        if (framebuffer !== _currentFramebuffer) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          restore = true;
        }
        try {
          var texture = renderTarget.texture;
          if (texture.format !== THREE.RGBAFormat && paramThreeToGL(texture.format) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
            return;
          }
          if (texture.type !== THREE.UnsignedByteType && paramThreeToGL(texture.type) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(texture.type === THREE.FloatType && extensions.get('WEBGL_color_buffer_float')) && !(texture.type === THREE.HalfFloatType && extensions.get('EXT_color_buffer_half_float'))) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
            return;
          }
          if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
            _gl.readPixels(x, y, width, height, paramThreeToGL(texture.format), paramThreeToGL(texture.type), buffer);
          } else {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
          }
        } finally {
          if (restore) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
          }
        }
      }
    };
    function updateRenderTargetMipmap(renderTarget) {
      var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
      var texture = properties.get(renderTarget.texture).__webglTexture;
      state.bindTexture(target, texture);
      _gl.generateMipmap(target);
      state.bindTexture(target, null);
    }
    function filterFallback(f) {
      if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) {
        return _gl.NEAREST;
      }
      return _gl.LINEAR;
    }
    function paramThreeToGL(p) {
      var extension;
      if (p === THREE.RepeatWrapping)
        return _gl.REPEAT;
      if (p === THREE.ClampToEdgeWrapping)
        return _gl.CLAMP_TO_EDGE;
      if (p === THREE.MirroredRepeatWrapping)
        return _gl.MIRRORED_REPEAT;
      if (p === THREE.NearestFilter)
        return _gl.NEAREST;
      if (p === THREE.NearestMipMapNearestFilter)
        return _gl.NEAREST_MIPMAP_NEAREST;
      if (p === THREE.NearestMipMapLinearFilter)
        return _gl.NEAREST_MIPMAP_LINEAR;
      if (p === THREE.LinearFilter)
        return _gl.LINEAR;
      if (p === THREE.LinearMipMapNearestFilter)
        return _gl.LINEAR_MIPMAP_NEAREST;
      if (p === THREE.LinearMipMapLinearFilter)
        return _gl.LINEAR_MIPMAP_LINEAR;
      if (p === THREE.UnsignedByteType)
        return _gl.UNSIGNED_BYTE;
      if (p === THREE.UnsignedShort4444Type)
        return _gl.UNSIGNED_SHORT_4_4_4_4;
      if (p === THREE.UnsignedShort5551Type)
        return _gl.UNSIGNED_SHORT_5_5_5_1;
      if (p === THREE.UnsignedShort565Type)
        return _gl.UNSIGNED_SHORT_5_6_5;
      if (p === THREE.ByteType)
        return _gl.BYTE;
      if (p === THREE.ShortType)
        return _gl.SHORT;
      if (p === THREE.UnsignedShortType)
        return _gl.UNSIGNED_SHORT;
      if (p === THREE.IntType)
        return _gl.INT;
      if (p === THREE.UnsignedIntType)
        return _gl.UNSIGNED_INT;
      if (p === THREE.FloatType)
        return _gl.FLOAT;
      extension = extensions.get('OES_texture_half_float');
      if (extension !== null) {
        if (p === THREE.HalfFloatType)
          return extension.HALF_FLOAT_OES;
      }
      if (p === THREE.AlphaFormat)
        return _gl.ALPHA;
      if (p === THREE.RGBFormat)
        return _gl.RGB;
      if (p === THREE.RGBAFormat)
        return _gl.RGBA;
      if (p === THREE.LuminanceFormat)
        return _gl.LUMINANCE;
      if (p === THREE.LuminanceAlphaFormat)
        return _gl.LUMINANCE_ALPHA;
      if (p === THREE.AddEquation)
        return _gl.FUNC_ADD;
      if (p === THREE.SubtractEquation)
        return _gl.FUNC_SUBTRACT;
      if (p === THREE.ReverseSubtractEquation)
        return _gl.FUNC_REVERSE_SUBTRACT;
      if (p === THREE.ZeroFactor)
        return _gl.ZERO;
      if (p === THREE.OneFactor)
        return _gl.ONE;
      if (p === THREE.SrcColorFactor)
        return _gl.SRC_COLOR;
      if (p === THREE.OneMinusSrcColorFactor)
        return _gl.ONE_MINUS_SRC_COLOR;
      if (p === THREE.SrcAlphaFactor)
        return _gl.SRC_ALPHA;
      if (p === THREE.OneMinusSrcAlphaFactor)
        return _gl.ONE_MINUS_SRC_ALPHA;
      if (p === THREE.DstAlphaFactor)
        return _gl.DST_ALPHA;
      if (p === THREE.OneMinusDstAlphaFactor)
        return _gl.ONE_MINUS_DST_ALPHA;
      if (p === THREE.DstColorFactor)
        return _gl.DST_COLOR;
      if (p === THREE.OneMinusDstColorFactor)
        return _gl.ONE_MINUS_DST_COLOR;
      if (p === THREE.SrcAlphaSaturateFactor)
        return _gl.SRC_ALPHA_SATURATE;
      extension = extensions.get('WEBGL_compressed_texture_s3tc');
      if (extension !== null) {
        if (p === THREE.RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === THREE.RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === THREE.RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === THREE.RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
      extension = extensions.get('WEBGL_compressed_texture_pvrtc');
      if (extension !== null) {
        if (p === THREE.RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === THREE.RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === THREE.RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === THREE.RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
      extension = extensions.get('EXT_blend_minmax');
      if (extension !== null) {
        if (p === THREE.MinEquation)
          return extension.MIN_EXT;
        if (p === THREE.MaxEquation)
          return extension.MAX_EXT;
      }
      return 0;
    }
    this.supportsFloatTextures = function() {
      console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
      return extensions.get('OES_texture_float');
    };
    this.supportsHalfFloatTextures = function() {
      console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
      return extensions.get('OES_texture_half_float');
    };
    this.supportsStandardDerivatives = function() {
      console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
      return extensions.get('OES_standard_derivatives');
    };
    this.supportsCompressedTextureS3TC = function() {
      console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
      return extensions.get('WEBGL_compressed_texture_s3tc');
    };
    this.supportsCompressedTexturePVRTC = function() {
      console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
      return extensions.get('WEBGL_compressed_texture_pvrtc');
    };
    this.supportsBlendMinMax = function() {
      console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
      return extensions.get('EXT_blend_minmax');
    };
    this.supportsVertexTextures = function() {
      return capabilities.vertexTextures;
    };
    this.supportsInstancedArrays = function() {
      console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
      return extensions.get('ANGLE_instanced_arrays');
    };
    this.initMaterial = function() {
      console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
    };
    this.addPrePlugin = function() {
      console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
    };
    this.addPostPlugin = function() {
      console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
    };
    this.updateShadowMap = function() {
      console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
    };
    Object.defineProperties(this, {
      shadowMapEnabled: {
        get: function() {
          return shadowMap.enabled;
        },
        set: function(value) {
          console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
          shadowMap.enabled = value;
        }
      },
      shadowMapType: {
        get: function() {
          return shadowMap.type;
        },
        set: function(value) {
          console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
          shadowMap.type = value;
        }
      },
      shadowMapCullFace: {
        get: function() {
          return shadowMap.cullFace;
        },
        set: function(value) {
          console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');
          shadowMap.cullFace = value;
        }
      },
      shadowMapDebug: {
        get: function() {
          return shadowMap.debug;
        },
        set: function(value) {
          console.warn('THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.');
          shadowMap.debug = value;
        }
      }
    });
  };
  THREE.WebGLRenderTarget = function(width, height, options) {
    this.uuid = THREE.Math.generateUUID();
    this.width = width;
    this.height = height;
    options = options || {};
    if (options.minFilter === undefined)
      options.minFilter = THREE.LinearFilter;
    this.texture = new THREE.Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy);
    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
    this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;
  };
  THREE.WebGLRenderTarget.prototype = {
    constructor: THREE.WebGLRenderTarget,
    get wrapS() {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      return this.texture.wrapS;
    },
    set wrapS(value) {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      this.texture.wrapS = value;
    },
    get wrapT() {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      return this.texture.wrapT;
    },
    set wrapT(value) {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      this.texture.wrapT = value;
    },
    get magFilter() {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      return this.texture.magFilter;
    },
    set magFilter(value) {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      this.texture.magFilter = value;
    },
    get minFilter() {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      return this.texture.minFilter;
    },
    set minFilter(value) {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      this.texture.minFilter = value;
    },
    get anisotropy() {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      return this.texture.anisotropy;
    },
    set anisotropy(value) {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      this.texture.anisotropy = value;
    },
    get offset() {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      return this.texture.offset;
    },
    set offset(value) {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      this.texture.offset = value;
    },
    get repeat() {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      return this.texture.repeat;
    },
    set repeat(value) {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      this.texture.repeat = value;
    },
    get format() {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      return this.texture.format;
    },
    set format(value) {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      this.texture.format = value;
    },
    get type() {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      return this.texture.type;
    },
    set type(value) {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      this.texture.type = value;
    },
    get generateMipmaps() {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      return this.texture.generateMipmaps;
    },
    set generateMipmaps(value) {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      this.texture.generateMipmaps = value;
    },
    setSize: function(width, height) {
      if (this.width !== width || this.height !== height) {
        this.width = width;
        this.height = height;
        this.dispose();
      }
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.width = source.width;
      this.height = source.height;
      this.texture = source.texture.clone();
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.shareDepthFrom = source.shareDepthFrom;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({type: 'dispose'});
    }
  };
  THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
  THREE.WebGLRenderTargetCube = function(width, height, options) {
    THREE.WebGLRenderTarget.call(this, width, height, options);
    this.activeCubeFace = 0;
  };
  THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
  THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
  THREE.WebGLBufferRenderer = function(_gl, extensions, _infoRender) {
    var mode;
    function setMode(value) {
      mode = value;
    }
    function render(start, count) {
      _gl.drawArrays(mode, start, count);
      _infoRender.calls++;
      _infoRender.vertices += count;
      if (mode === _gl.TRIANGLES)
        _infoRender.faces += count / 3;
    }
    function renderInstances(geometry) {
      var extension = extensions.get('ANGLE_instanced_arrays');
      if (extension === null) {
        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
      var position = geometry.attributes.position;
      if (position instanceof THREE.InterleavedBufferAttribute) {
        extension.drawArraysInstancedANGLE(mode, 0, position.data.count, geometry.maxInstancedCount);
      } else {
        extension.drawArraysInstancedANGLE(mode, 0, position.count, geometry.maxInstancedCount);
      }
    }
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
  };
  THREE.WebGLIndexedBufferRenderer = function(_gl, extensions, _infoRender) {
    var mode;
    function setMode(value) {
      mode = value;
    }
    var type,
        size;
    function setIndex(index) {
      if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {
        type = _gl.UNSIGNED_INT;
        size = 4;
      } else {
        type = _gl.UNSIGNED_SHORT;
        size = 2;
      }
    }
    function render(start, count) {
      _gl.drawElements(mode, count, type, start * size);
      _infoRender.calls++;
      _infoRender.vertices += count;
      if (mode === _gl.TRIANGLES)
        _infoRender.faces += count / 3;
    }
    function renderInstances(geometry) {
      var extension = extensions.get('ANGLE_instanced_arrays');
      if (extension === null) {
        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
      var index = geometry.index;
      extension.drawElementsInstancedANGLE(mode, index.array.length, type, 0, geometry.maxInstancedCount);
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
  };
  THREE.WebGLExtensions = function(gl) {
    var extensions = {};
    this.get = function(name) {
      if (extensions[name] !== undefined) {
        return extensions[name];
      }
      var extension;
      switch (name) {
        case 'EXT_texture_filter_anisotropic':
          extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
          break;
        case 'WEBGL_compressed_texture_s3tc':
          extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
          break;
        case 'WEBGL_compressed_texture_pvrtc':
          extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
          break;
        default:
          extension = gl.getExtension(name);
      }
      if (extension === null) {
        console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
      }
      extensions[name] = extension;
      return extension;
    };
  };
  THREE.WebGLCapabilities = function(gl, extensions, parameters) {
    function getMaxPrecision(precision) {
      if (precision === 'highp') {
        if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
          return 'highp';
        }
        precision = 'mediump';
      }
      if (precision === 'mediump') {
        if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
          return 'mediump';
        }
      }
      return 'lowp';
    }
    this.getMaxPrecision = getMaxPrecision;
    this.precision = parameters.precision !== undefined ? parameters.precision : 'highp', this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;
    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    this.maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    this.maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    this.maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
    this.maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    this.vertexTextures = this.maxVertexTextures > 0;
    this.floatFragmentTextures = !!extensions.get('OES_texture_float');
    this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
    var _maxPrecision = getMaxPrecision(this.precision);
    if (_maxPrecision !== this.precision) {
      console.warn('THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.');
      this.precision = _maxPrecision;
    }
    if (this.logarithmicDepthBuffer) {
      this.logarithmicDepthBuffer = !!extensions.get('EXT_frag_depth');
    }
  };
  THREE.WebGLGeometries = function(gl, properties, info) {
    var geometries = {};
    function get(object) {
      var geometry = object.geometry;
      if (geometries[geometry.id] !== undefined) {
        return geometries[geometry.id];
      }
      geometry.addEventListener('dispose', onGeometryDispose);
      var buffergeometry;
      if (geometry instanceof THREE.BufferGeometry) {
        buffergeometry = geometry;
      } else if (geometry instanceof THREE.Geometry) {
        if (geometry._bufferGeometry === undefined) {
          geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject(object);
        }
        buffergeometry = geometry._bufferGeometry;
      }
      geometries[geometry.id] = buffergeometry;
      info.memory.geometries++;
      return buffergeometry;
    }
    function onGeometryDispose(event) {
      var geometry = event.target;
      var buffergeometry = geometries[geometry.id];
      deleteAttributes(buffergeometry.attributes);
      geometry.removeEventListener('dispose', onGeometryDispose);
      delete geometries[geometry.id];
      var property = properties.get(geometry);
      if (property.wireframe)
        deleteAttribute(property.wireframe);
      info.memory.geometries--;
    }
    function getAttributeBuffer(attribute) {
      if (attribute instanceof THREE.InterleavedBufferAttribute) {
        return properties.get(attribute.data).__webglBuffer;
      }
      return properties.get(attribute).__webglBuffer;
    }
    function deleteAttribute(attribute) {
      var buffer = getAttributeBuffer(attribute);
      if (buffer !== undefined) {
        gl.deleteBuffer(buffer);
        removeAttributeBuffer(attribute);
      }
    }
    function deleteAttributes(attributes) {
      for (var name in attributes) {
        deleteAttribute(attributes[name]);
      }
    }
    function removeAttributeBuffer(attribute) {
      if (attribute instanceof THREE.InterleavedBufferAttribute) {
        properties.delete(attribute.data);
      } else {
        properties.delete(attribute);
      }
    }
    this.get = get;
  };
  THREE.WebGLObjects = function(gl, properties, info) {
    var geometries = new THREE.WebGLGeometries(gl, properties, info);
    function update(object) {
      var geometry = geometries.get(object);
      if (object.geometry instanceof THREE.Geometry) {
        geometry.updateFromObject(object);
      }
      var index = geometry.index;
      var attributes = geometry.attributes;
      if (index !== null) {
        updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);
      }
      for (var name in attributes) {
        updateAttribute(attributes[name], gl.ARRAY_BUFFER);
      }
      var morphAttributes = geometry.morphAttributes;
      for (var name in morphAttributes) {
        var array = morphAttributes[name];
        for (var i = 0,
            l = array.length; i < l; i++) {
          updateAttribute(array[i], gl.ARRAY_BUFFER);
        }
      }
      return geometry;
    }
    function updateAttribute(attribute, bufferType) {
      var data = (attribute instanceof THREE.InterleavedBufferAttribute) ? attribute.data : attribute;
      var attributeProperties = properties.get(data);
      if (attributeProperties.__webglBuffer === undefined) {
        createBuffer(attributeProperties, data, bufferType);
      } else if (attributeProperties.version !== data.version) {
        updateBuffer(attributeProperties, data, bufferType);
      }
    }
    function createBuffer(attributeProperties, data, bufferType) {
      attributeProperties.__webglBuffer = gl.createBuffer();
      gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
      var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
      gl.bufferData(bufferType, data.array, usage);
      attributeProperties.version = data.version;
    }
    function updateBuffer(attributeProperties, data, bufferType) {
      gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
      if (data.dynamic === false || data.updateRange.count === -1) {
        gl.bufferSubData(bufferType, 0, data.array);
      } else if (data.updateRange.count === 0) {
        console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
      } else {
        gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT, data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count));
        data.updateRange.count = 0;
      }
      attributeProperties.version = data.version;
    }
    function getAttributeBuffer(attribute) {
      if (attribute instanceof THREE.InterleavedBufferAttribute) {
        return properties.get(attribute.data).__webglBuffer;
      }
      return properties.get(attribute).__webglBuffer;
    }
    function getWireframeAttribute(geometry) {
      var property = properties.get(geometry);
      if (property.wireframe !== undefined) {
        return property.wireframe;
      }
      var indices = [];
      var index = geometry.index;
      var attributes = geometry.attributes;
      var position = attributes.position;
      if (index !== null) {
        var edges = {};
        var array = index.array;
        for (var i = 0,
            l = array.length; i < l; i += 3) {
          var a = array[i + 0];
          var b = array[i + 1];
          var c = array[i + 2];
          if (checkEdge(edges, a, b))
            indices.push(a, b);
          if (checkEdge(edges, b, c))
            indices.push(b, c);
          if (checkEdge(edges, c, a))
            indices.push(c, a);
        }
      } else {
        var array = attributes.position.array;
        for (var i = 0,
            l = (array.length / 3) - 1; i < l; i += 3) {
          var a = i + 0;
          var b = i + 1;
          var c = i + 2;
          indices.push(a, b, b, c, c, a);
        }
      }
      var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
      var attribute = new THREE.BufferAttribute(new TypeArray(indices), 1);
      updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
      property.wireframe = attribute;
      return attribute;
    }
    function checkEdge(edges, a, b) {
      if (a > b) {
        var tmp = a;
        a = b;
        b = tmp;
      }
      var list = edges[a];
      if (list === undefined) {
        edges[a] = [b];
        return true;
      } else if (list.indexOf(b) === -1) {
        list.push(b);
        return true;
      }
      return false;
    }
    this.getAttributeBuffer = getAttributeBuffer;
    this.getWireframeAttribute = getWireframeAttribute;
    this.update = update;
  };
  THREE.WebGLProgram = (function() {
    var programIdCount = 0;
    function generateDefines(defines) {
      var chunks = [];
      for (var name in defines) {
        var value = defines[name];
        if (value === false)
          continue;
        chunks.push('#define ' + name + ' ' + value);
      }
      return chunks.join('\n');
    }
    function fetchUniformLocations(gl, program, identifiers) {
      var uniforms = {};
      var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
      for (var i = 0; i < n; i++) {
        var info = gl.getActiveUniform(program, i);
        var name = info.name;
        var location = gl.getUniformLocation(program, name);
        var suffixPos = name.lastIndexOf('[0]');
        if (suffixPos !== -1 && suffixPos === name.length - 3) {
          uniforms[name.substr(0, suffixPos)] = location;
        }
        uniforms[name] = location;
      }
      return uniforms;
    }
    function fetchAttributeLocations(gl, program, identifiers) {
      var attributes = {};
      var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
      for (var i = 0; i < n; i++) {
        var info = gl.getActiveAttrib(program, i);
        var name = info.name;
        attributes[name] = gl.getAttribLocation(program, name);
      }
      return attributes;
    }
    function filterEmptyLine(string) {
      return string !== '';
    }
    return function WebGLProgram(renderer, code, material, parameters) {
      var gl = renderer.context;
      var defines = material.defines;
      var vertexShader = material.__webglShader.vertexShader;
      var fragmentShader = material.__webglShader.fragmentShader;
      var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
      if (parameters.shadowMapType === THREE.PCFShadowMap) {
        shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
      } else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {
        shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
      }
      var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
      var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
      var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
      if (parameters.envMap) {
        switch (material.envMap.mapping) {
          case THREE.CubeReflectionMapping:
          case THREE.CubeRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
            break;
          case THREE.EquirectangularReflectionMapping:
          case THREE.EquirectangularRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
            break;
          case THREE.SphericalReflectionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
            break;
        }
        switch (material.envMap.mapping) {
          case THREE.CubeRefractionMapping:
          case THREE.EquirectangularRefractionMapping:
            envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
            break;
        }
        switch (material.combine) {
          case THREE.MultiplyOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
            break;
          case THREE.MixOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
            break;
          case THREE.AddOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
            break;
        }
      }
      var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;
      var customDefines = generateDefines(defines);
      var program = gl.createProgram();
      var prefixVertex,
          prefixFragment;
      if (material instanceof THREE.RawShaderMaterial) {
        prefixVertex = '';
        prefixFragment = '';
      } else {
        prefixVertex = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + material.__webglShader.name, customDefines, parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', renderer.gammaInput ? '#define GAMMA_INPUT' : '', renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights, '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights, '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights, '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights, '#define MAX_SHADOWS ' + parameters.maxShadows, '#define MAX_BONES ' + parameters.maxBones, parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '', parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
        prefixFragment = [parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '', 'precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + material.__webglShader.name, customDefines, '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights, '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights, '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights, '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights, '#define MAX_SHADOWS ' + parameters.maxShadows, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '', renderer.gammaInput ? '#define GAMMA_INPUT' : '', renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '', (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.metal ? '#define METAL' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '', parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', '\n'].filter(filterEmptyLine).join('\n');
      }
      var vertexGlsl = prefixVertex + vertexShader;
      var fragmentGlsl = prefixFragment + fragmentShader;
      var glVertexShader = THREE.WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
      var glFragmentShader = THREE.WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
      gl.attachShader(program, glVertexShader);
      gl.attachShader(program, glFragmentShader);
      if (material.index0AttributeName !== undefined) {
        gl.bindAttribLocation(program, 0, material.index0AttributeName);
      } else if (parameters.morphTargets === true) {
        gl.bindAttribLocation(program, 0, 'position');
      }
      gl.linkProgram(program);
      var programLog = gl.getProgramInfoLog(program);
      var vertexLog = gl.getShaderInfoLog(glVertexShader);
      var fragmentLog = gl.getShaderInfoLog(glFragmentShader);
      var runnable = true;
      var haveDiagnostics = true;
      if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        runnable = false;
        console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
      } else if (programLog !== '') {
        console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
      } else if (vertexLog === '' || fragmentLog === '') {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        this.diagnostics = {
          runnable: runnable,
          material: material,
          programLog: programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
      gl.deleteShader(glVertexShader);
      gl.deleteShader(glFragmentShader);
      var cachedUniforms;
      this.getUniforms = function() {
        if (cachedUniforms === undefined) {
          cachedUniforms = fetchUniformLocations(gl, program);
        }
        return cachedUniforms;
      };
      var cachedAttributes;
      this.getAttributes = function() {
        if (cachedAttributes === undefined) {
          cachedAttributes = fetchAttributeLocations(gl, program);
        }
        return cachedAttributes;
      };
      this.destroy = function() {
        gl.deleteProgram(program);
        this.program = undefined;
      };
      Object.defineProperties(this, {
        uniforms: {get: function() {
            console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
            return this.getUniforms();
          }},
        attributes: {get: function() {
            console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
            return this.getAttributes();
          }}
      });
      this.id = programIdCount++;
      this.code = code;
      this.usedTimes = 1;
      this.program = program;
      this.vertexShader = glVertexShader;
      this.fragmentShader = glFragmentShader;
      return this;
    };
  })();
  THREE.WebGLPrograms = function(renderer, capabilities) {
    var programs = [];
    var shaderIDs = {
      MeshDepthMaterial: 'depth',
      MeshNormalMaterial: 'normal',
      MeshBasicMaterial: 'basic',
      MeshLambertMaterial: 'lambert',
      MeshPhongMaterial: 'phong',
      LineBasicMaterial: 'basic',
      LineDashedMaterial: 'dashed',
      PointsMaterial: 'points'
    };
    var parameterNames = ["precision", "supportsVertexTextures", "map", "envMap", "envMapMode", "lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights", "maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled", "pointLightShadows", "shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided", "flipSided"];
    function allocateBones(object) {
      if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture) {
        return 1024;
      } else {
        var nVertexUniforms = capabilities.maxVertexUniforms;
        var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
        var maxBones = nVertexMatrices;
        if (object !== undefined && object instanceof THREE.SkinnedMesh) {
          maxBones = Math.min(object.skeleton.bones.length, maxBones);
          if (maxBones < object.skeleton.bones.length) {
            console.warn('WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)');
          }
        }
        return maxBones;
      }
    }
    function allocateLights(lights) {
      var dirLights = 0;
      var pointLights = 0;
      var spotLights = 0;
      var hemiLights = 0;
      for (var l = 0,
          ll = lights.length; l < ll; l++) {
        var light = lights[l];
        if (light.visible === false)
          continue;
        if (light instanceof THREE.DirectionalLight)
          dirLights++;
        if (light instanceof THREE.PointLight)
          pointLights++;
        if (light instanceof THREE.SpotLight)
          spotLights++;
        if (light instanceof THREE.HemisphereLight)
          hemiLights++;
      }
      return {
        'directional': dirLights,
        'point': pointLights,
        'spot': spotLights,
        'hemi': hemiLights
      };
    }
    function allocateShadows(lights) {
      var maxShadows = 0;
      var pointLightShadows = 0;
      for (var l = 0,
          ll = lights.length; l < ll; l++) {
        var light = lights[l];
        if (!light.castShadow)
          continue;
        if (light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight)
          maxShadows++;
        if (light instanceof THREE.PointLight) {
          maxShadows++;
          pointLightShadows++;
        }
      }
      return {
        'maxShadows': maxShadows,
        'pointLightShadows': pointLightShadows
      };
    }
    this.getParameters = function(material, lights, fog, object) {
      var shaderID = shaderIDs[material.type];
      var maxLightCount = allocateLights(lights);
      var allocatedShadows = allocateShadows(lights);
      var maxBones = allocateBones(object);
      var precision = renderer.getPrecision();
      if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);
        if (precision !== material.precision) {
          console.warn('THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.');
        }
      }
      var parameters = {
        shaderID: shaderID,
        precision: precision,
        supportsVertexTextures: capabilities.vertexTextures,
        map: !!material.map,
        envMap: !!material.envMap,
        envMapMode: material.envMap && material.envMap.mapping,
        lightMap: !!material.lightMap,
        aoMap: !!material.aoMap,
        emissiveMap: !!material.emissiveMap,
        bumpMap: !!material.bumpMap,
        normalMap: !!material.normalMap,
        displacementMap: !!material.displacementMap,
        specularMap: !!material.specularMap,
        alphaMap: !!material.alphaMap,
        combine: material.combine,
        vertexColors: material.vertexColors,
        fog: fog,
        useFog: material.fog,
        fogExp: fog instanceof THREE.FogExp2,
        flatShading: material.shading === THREE.FlatShading,
        sizeAttenuation: material.sizeAttenuation,
        logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
        skinning: material.skinning,
        maxBones: maxBones,
        useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
        morphTargets: material.morphTargets,
        morphNormals: material.morphNormals,
        maxMorphTargets: renderer.maxMorphTargets,
        maxMorphNormals: renderer.maxMorphNormals,
        maxDirLights: maxLightCount.directional,
        maxPointLights: maxLightCount.point,
        maxSpotLights: maxLightCount.spot,
        maxHemiLights: maxLightCount.hemi,
        maxShadows: allocatedShadows.maxShadows,
        pointLightShadows: allocatedShadows.pointLightShadows,
        shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && allocatedShadows.maxShadows > 0,
        shadowMapType: renderer.shadowMap.type,
        shadowMapDebug: renderer.shadowMap.debug,
        alphaTest: material.alphaTest,
        metal: material.metal,
        doubleSided: material.side === THREE.DoubleSide,
        flipSided: material.side === THREE.BackSide
      };
      return parameters;
    };
    this.getProgramCode = function(material, parameters) {
      var chunks = [];
      if (parameters.shaderID) {
        chunks.push(parameters.shaderID);
      } else {
        chunks.push(material.fragmentShader);
        chunks.push(material.vertexShader);
      }
      if (material.defines !== undefined) {
        for (var name in material.defines) {
          chunks.push(name);
          chunks.push(material.defines[name]);
        }
      }
      for (var i = 0; i < parameterNames.length; i++) {
        var parameterName = parameterNames[i];
        chunks.push(parameterName);
        chunks.push(parameters[parameterName]);
      }
      return chunks.join();
    };
    this.acquireProgram = function(material, parameters, code) {
      var program;
      for (var p = 0,
          pl = programs.length; p < pl; p++) {
        var programInfo = programs[p];
        if (programInfo.code === code) {
          program = programInfo;
          ++program.usedTimes;
          break;
        }
      }
      if (program === undefined) {
        program = new THREE.WebGLProgram(renderer, code, material, parameters);
        programs.push(program);
      }
      return program;
    };
    this.releaseProgram = function(program) {
      if (--program.usedTimes === 0) {
        var i = programs.indexOf(program);
        programs[i] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
      }
    };
    this.programs = programs;
  };
  THREE.WebGLProperties = function() {
    var properties = {};
    this.get = function(object) {
      var uuid = object.uuid;
      var map = properties[uuid];
      if (map === undefined) {
        map = {};
        properties[uuid] = map;
      }
      return map;
    };
    this.delete = function(object) {
      delete properties[object.uuid];
    };
    this.clear = function() {
      properties = {};
    };
  };
  THREE.WebGLShader = (function() {
    function addLineNumbers(string) {
      var lines = string.split('\n');
      for (var i = 0; i < lines.length; i++) {
        lines[i] = (i + 1) + ': ' + lines[i];
      }
      return lines.join('\n');
    }
    return function WebGLShader(gl, type, string) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, string);
      gl.compileShader(shader);
      if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
        console.error('THREE.WebGLShader: Shader couldn\'t compile.');
      }
      if (gl.getShaderInfoLog(shader) !== '') {
        console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
      }
      return shader;
    };
  })();
  THREE.WebGLShadowMap = function(_renderer, _lights, _objects) {
    var _gl = _renderer.context,
        _state = _renderer.state,
        _frustum = new THREE.Frustum(),
        _projScreenMatrix = new THREE.Matrix4(),
        _min = new THREE.Vector3(),
        _max = new THREE.Vector3(),
        _lookTarget = new THREE.Vector3(),
        _lightPositionWorld = new THREE.Vector3(),
        _renderList = [],
        _MorphingFlag = 1,
        _SkinningFlag = 2,
        _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1,
        _depthMaterials = new Array(_NumberOfMaterialVariants),
        _distanceMaterials = new Array(_NumberOfMaterialVariants);
    var cubeDirections = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0)];
    var cubeUps = [new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)];
    var cube2DViewPorts = [new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()];
    var _vector4 = new THREE.Vector4();
    var depthShader = THREE.ShaderLib["depthRGBA"];
    var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);
    var distanceShader = THREE.ShaderLib["distanceRGBA"];
    var distanceUniforms = THREE.UniformsUtils.clone(distanceShader.uniforms);
    for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
      var useMorphing = (i & _MorphingFlag) !== 0;
      var useSkinning = (i & _SkinningFlag) !== 0;
      var depthMaterial = new THREE.ShaderMaterial({
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      depthMaterial._shadowPass = true;
      _depthMaterials[i] = depthMaterial;
      var distanceMaterial = new THREE.ShaderMaterial({
        uniforms: distanceUniforms,
        vertexShader: distanceShader.vertexShader,
        fragmentShader: distanceShader.fragmentShader,
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      distanceMaterial._shadowPass = true;
      _distanceMaterials[i] = distanceMaterial;
    }
    var scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = THREE.PCFShadowMap;
    this.cullFace = THREE.CullFaceFront;
    this.render = function(scene) {
      var faceCount,
          isPointLight;
      if (scope.enabled === false)
        return;
      if (scope.autoUpdate === false && scope.needsUpdate === false)
        return;
      _gl.clearColor(1, 1, 1, 1);
      _state.disable(_gl.BLEND);
      _state.enable(_gl.CULL_FACE);
      _gl.frontFace(_gl.CCW);
      _gl.cullFace(scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK);
      _state.setDepthTest(true);
      _renderer.getViewport(_vector4);
      for (var i = 0,
          il = _lights.length; i < il; i++) {
        var light = _lights[i];
        if (light.castShadow === true) {
          var shadow = light.shadow;
          var shadowCamera = shadow.camera;
          var shadowMapSize = shadow.mapSize;
          if (light instanceof THREE.PointLight) {
            faceCount = 6;
            isPointLight = true;
            var vpWidth = shadowMapSize.x / 4.0;
            var vpHeight = shadowMapSize.y / 2.0;
            cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
            cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
            cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
            cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
            cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
            cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
          } else {
            faceCount = 1;
            isPointLight = false;
          }
          if (shadow.map === null) {
            var shadowFilter = THREE.LinearFilter;
            if (scope.type === THREE.PCFSoftShadowMap) {
              shadowFilter = THREE.NearestFilter;
            }
            var pars = {
              minFilter: shadowFilter,
              magFilter: shadowFilter,
              format: THREE.RGBAFormat
            };
            shadow.map = new THREE.WebGLRenderTarget(shadowMapSize.x, shadowMapSize.y, pars);
            shadow.matrix = new THREE.Matrix4();
            if (light instanceof THREE.SpotLight) {
              shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;
            }
            shadowCamera.updateProjectionMatrix();
          }
          var shadowMap = shadow.map;
          var shadowMatrix = shadow.matrix;
          _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
          shadowCamera.position.copy(_lightPositionWorld);
          _renderer.setRenderTarget(shadowMap);
          _renderer.clear();
          for (var face = 0; face < faceCount; face++) {
            if (isPointLight) {
              _lookTarget.copy(shadowCamera.position);
              _lookTarget.add(cubeDirections[face]);
              shadowCamera.up.copy(cubeUps[face]);
              shadowCamera.lookAt(_lookTarget);
              var vpDimensions = cube2DViewPorts[face];
              _renderer.setViewport(vpDimensions.x, vpDimensions.y, vpDimensions.z, vpDimensions.w);
            } else {
              _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
              shadowCamera.lookAt(_lookTarget);
            }
            shadowCamera.updateMatrixWorld();
            shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
            shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
            shadowMatrix.multiply(shadowCamera.projectionMatrix);
            shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
            _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
            _frustum.setFromMatrix(_projScreenMatrix);
            _renderList.length = 0;
            projectObject(scene, shadowCamera);
            for (var j = 0,
                jl = _renderList.length; j < jl; j++) {
              var object = _renderList[j];
              var geometry = _objects.update(object);
              var material = object.material;
              if (material instanceof THREE.MeshFaceMaterial) {
                var groups = geometry.groups;
                var materials = material.materials;
                for (var k = 0,
                    kl = groups.length; k < kl; k++) {
                  var group = groups[k];
                  var groupMaterial = materials[group.materialIndex];
                  if (groupMaterial.visible === true) {
                    var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
                    _renderer.renderBufferDirect(shadowCamera, _lights, null, geometry, depthMaterial, object, group);
                  }
                }
              } else {
                var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
                _renderer.renderBufferDirect(shadowCamera, _lights, null, geometry, depthMaterial, object, null);
              }
            }
          }
          _renderer.resetGLState();
        }
      }
      _renderer.setViewport(_vector4.x, _vector4.y, _vector4.z, _vector4.w);
      var clearColor = _renderer.getClearColor(),
          clearAlpha = _renderer.getClearAlpha();
      _renderer.setClearColor(clearColor, clearAlpha);
      _state.enable(_gl.BLEND);
      if (scope.cullFace === THREE.CullFaceFront) {
        _gl.cullFace(_gl.BACK);
      }
      _renderer.resetGLState();
      scope.needsUpdate = false;
    };
    function getDepthMaterial(object, material, isPointLight, lightPositionWorld) {
      var geometry = object.geometry;
      var newMaterial = null;
      var materialVariants = _depthMaterials;
      var customMaterial = object.customDepthMaterial;
      if (isPointLight) {
        materialVariants = _distanceMaterials;
        customMaterial = object.customDistanceMaterial;
      }
      if (!customMaterial) {
        var useMorphing = geometry.morphTargets !== undefined && geometry.morphTargets.length > 0 && material.morphTargets;
        var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;
        var variantIndex = 0;
        if (useMorphing)
          variantIndex |= _MorphingFlag;
        if (useSkinning)
          variantIndex |= _SkinningFlag;
        newMaterial = materialVariants[variantIndex];
      } else {
        newMaterial = customMaterial;
      }
      newMaterial.visible = material.visible;
      newMaterial.wireframe = material.wireframe;
      newMaterial.wireframeLinewidth = material.wireframeLinewidth;
      if (isPointLight && newMaterial.uniforms.lightPos !== undefined) {
        newMaterial.uniforms.lightPos.value.copy(lightPositionWorld);
      }
      return newMaterial;
    }
    function projectObject(object, camera) {
      if (object.visible === false)
        return;
      if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) {
        if (object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
          var material = object.material;
          if (material.visible === true) {
            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            _renderList.push(object);
          }
        }
      }
      var children = object.children;
      for (var i = 0,
          l = children.length; i < l; i++) {
        projectObject(children[i], camera);
      }
    }
  };
  THREE.WebGLState = function(gl, extensions, paramThreeToGL) {
    var _this = this;
    var newAttributes = new Uint8Array(16);
    var enabledAttributes = new Uint8Array(16);
    var attributeDivisors = new Uint8Array(16);
    var capabilities = {};
    var compressedTextureFormats = null;
    var currentBlending = null;
    var currentBlendEquation = null;
    var currentBlendSrc = null;
    var currentBlendDst = null;
    var currentBlendEquationAlpha = null;
    var currentBlendSrcAlpha = null;
    var currentBlendDstAlpha = null;
    var currentDepthFunc = null;
    var currentDepthWrite = null;
    var currentColorWrite = null;
    var currentFlipSided = null;
    var currentLineWidth = null;
    var currentPolygonOffsetFactor = null;
    var currentPolygonOffsetUnits = null;
    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    var currentTextureSlot = undefined;
    var currentBoundTextures = {};
    this.init = function() {
      gl.clearColor(0, 0, 0, 1);
      gl.clearDepth(1);
      gl.clearStencil(0);
      this.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.frontFace(gl.CCW);
      gl.cullFace(gl.BACK);
      this.enable(gl.CULL_FACE);
      this.enable(gl.BLEND);
      gl.blendEquation(gl.FUNC_ADD);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    };
    this.initAttributes = function() {
      for (var i = 0,
          l = newAttributes.length; i < l; i++) {
        newAttributes[i] = 0;
      }
    };
    this.enableAttribute = function(attribute) {
      newAttributes[attribute] = 1;
      if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }
      if (attributeDivisors[attribute] !== 0) {
        var extension = extensions.get('ANGLE_instanced_arrays');
        extension.vertexAttribDivisorANGLE(attribute, 0);
        attributeDivisors[attribute] = 0;
      }
    };
    this.enableAttributeAndDivisor = function(attribute, meshPerAttribute, extension) {
      newAttributes[attribute] = 1;
      if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }
      if (attributeDivisors[attribute] !== meshPerAttribute) {
        extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
      }
    };
    this.disableUnusedAttributes = function() {
      for (var i = 0,
          l = enabledAttributes.length; i < l; i++) {
        if (enabledAttributes[i] !== newAttributes[i]) {
          gl.disableVertexAttribArray(i);
          enabledAttributes[i] = 0;
        }
      }
    };
    this.enable = function(id) {
      if (capabilities[id] !== true) {
        gl.enable(id);
        capabilities[id] = true;
      }
    };
    this.disable = function(id) {
      if (capabilities[id] !== false) {
        gl.disable(id);
        capabilities[id] = false;
      }
    };
    this.getCompressedTextureFormats = function() {
      if (compressedTextureFormats === null) {
        compressedTextureFormats = [];
        if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc')) {
          var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
          for (var i = 0; i < formats.length; i++) {
            compressedTextureFormats.push(formats[i]);
          }
        }
      }
      return compressedTextureFormats;
    };
    this.setBlending = function(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha) {
      if (blending !== currentBlending) {
        if (blending === THREE.NoBlending) {
          this.disable(gl.BLEND);
        } else if (blending === THREE.AdditiveBlending) {
          this.enable(gl.BLEND);
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        } else if (blending === THREE.SubtractiveBlending) {
          this.enable(gl.BLEND);
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
        } else if (blending === THREE.MultiplyBlending) {
          this.enable(gl.BLEND);
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
        } else if (blending === THREE.CustomBlending) {
          this.enable(gl.BLEND);
        } else {
          this.enable(gl.BLEND);
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        }
        currentBlending = blending;
      }
      if (blending === THREE.CustomBlending) {
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
          gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));
          currentBlendEquation = blendEquation;
          currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
          gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));
          currentBlendSrc = blendSrc;
          currentBlendDst = blendDst;
          currentBlendSrcAlpha = blendSrcAlpha;
          currentBlendDstAlpha = blendDstAlpha;
        }
      } else {
        currentBlendEquation = null;
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendEquationAlpha = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
      }
    };
    this.setDepthFunc = function(depthFunc) {
      if (currentDepthFunc !== depthFunc) {
        if (depthFunc) {
          switch (depthFunc) {
            case THREE.NeverDepth:
              gl.depthFunc(gl.NEVER);
              break;
            case THREE.AlwaysDepth:
              gl.depthFunc(gl.ALWAYS);
              break;
            case THREE.LessDepth:
              gl.depthFunc(gl.LESS);
              break;
            case THREE.LessEqualDepth:
              gl.depthFunc(gl.LEQUAL);
              break;
            case THREE.EqualDepth:
              gl.depthFunc(gl.EQUAL);
              break;
            case THREE.GreaterEqualDepth:
              gl.depthFunc(gl.GEQUAL);
              break;
            case THREE.GreaterDepth:
              gl.depthFunc(gl.GREATER);
              break;
            case THREE.NotEqualDepth:
              gl.depthFunc(gl.NOTEQUAL);
              break;
            default:
              gl.depthFunc(gl.LEQUAL);
          }
        } else {
          gl.depthFunc(gl.LEQUAL);
        }
        currentDepthFunc = depthFunc;
      }
    };
    this.setDepthTest = function(depthTest) {
      if (depthTest) {
        this.enable(gl.DEPTH_TEST);
      } else {
        this.disable(gl.DEPTH_TEST);
      }
    };
    this.setDepthWrite = function(depthWrite) {
      if (currentDepthWrite !== depthWrite) {
        gl.depthMask(depthWrite);
        currentDepthWrite = depthWrite;
      }
    };
    this.setColorWrite = function(colorWrite) {
      if (currentColorWrite !== colorWrite) {
        gl.colorMask(colorWrite, colorWrite, colorWrite, colorWrite);
        currentColorWrite = colorWrite;
      }
    };
    this.setFlipSided = function(flipSided) {
      if (currentFlipSided !== flipSided) {
        if (flipSided) {
          gl.frontFace(gl.CW);
        } else {
          gl.frontFace(gl.CCW);
        }
        currentFlipSided = flipSided;
      }
    };
    this.setLineWidth = function(width) {
      if (width !== currentLineWidth) {
        gl.lineWidth(width);
        currentLineWidth = width;
      }
    };
    this.setPolygonOffset = function(polygonOffset, factor, units) {
      if (polygonOffset) {
        this.enable(gl.POLYGON_OFFSET_FILL);
      } else {
        this.disable(gl.POLYGON_OFFSET_FILL);
      }
      if (polygonOffset && (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units)) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    };
    this.setScissorTest = function(scissorTest) {
      if (scissorTest) {
        this.enable(gl.SCISSOR_TEST);
      } else {
        this.disable(gl.SCISSOR_TEST);
      }
    };
    this.activeTexture = function(webglSlot) {
      if (webglSlot === undefined)
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
    };
    this.bindTexture = function(webglType, webglTexture) {
      if (currentTextureSlot === undefined) {
        _this.activeTexture();
      }
      var boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture === undefined) {
        boundTexture = {
          type: undefined,
          texture: undefined
        };
        currentBoundTextures[currentTextureSlot] = boundTexture;
      }
      if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        gl.bindTexture(webglType, webglTexture);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
      }
    };
    this.compressedTexImage2D = function() {
      try {
        gl.compressedTexImage2D.apply(gl, arguments);
      } catch (error) {
        console.error(error);
      }
    };
    this.texImage2D = function() {
      try {
        gl.texImage2D.apply(gl, arguments);
      } catch (error) {
        console.error(error);
      }
    };
    this.reset = function() {
      for (var i = 0; i < enabledAttributes.length; i++) {
        if (enabledAttributes[i] === 1) {
          gl.disableVertexAttribArray(i);
          enabledAttributes[i] = 0;
        }
      }
      capabilities = {};
      compressedTextureFormats = null;
      currentBlending = null;
      currentDepthWrite = null;
      currentColorWrite = null;
      currentFlipSided = null;
    };
  };
  THREE.LensFlarePlugin = function(renderer, flares) {
    var gl = renderer.context;
    var state = renderer.state;
    var vertexBuffer,
        elementBuffer;
    var program,
        attributes,
        uniforms;
    var hasVertexTexture;
    var tempTexture,
        occlusionTexture;
    function init() {
      var vertices = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]);
      var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
      vertexBuffer = gl.createBuffer();
      elementBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
      tempTexture = gl.createTexture();
      occlusionTexture = gl.createTexture();
      state.bindTexture(gl.TEXTURE_2D, tempTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      hasVertexTexture = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
      var shader;
      if (hasVertexTexture) {
        shader = {
          vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
          fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
        };
      } else {
        shader = {
          vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
          fragmentShader: ["precision mediump float;", "uniform lowp int renderType;", "uniform sampler2D map;", "uniform sampler2D occlusionMap;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;", "visibility = ( 1.0 - visibility / 4.0 );", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * visibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
        };
      }
      program = createProgram(shader);
      attributes = {
        vertex: gl.getAttribLocation(program, "position"),
        uv: gl.getAttribLocation(program, "uv")
      };
      uniforms = {
        renderType: gl.getUniformLocation(program, "renderType"),
        map: gl.getUniformLocation(program, "map"),
        occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
        opacity: gl.getUniformLocation(program, "opacity"),
        color: gl.getUniformLocation(program, "color"),
        scale: gl.getUniformLocation(program, "scale"),
        rotation: gl.getUniformLocation(program, "rotation"),
        screenPosition: gl.getUniformLocation(program, "screenPosition")
      };
    }
    this.render = function(scene, camera, viewportWidth, viewportHeight) {
      if (flares.length === 0)
        return;
      var tempPosition = new THREE.Vector3();
      var invAspect = viewportHeight / viewportWidth,
          halfViewportWidth = viewportWidth * 0.5,
          halfViewportHeight = viewportHeight * 0.5;
      var size = 16 / viewportHeight,
          scale = new THREE.Vector2(size * invAspect, size);
      var screenPosition = new THREE.Vector3(1, 1, 0),
          screenPositionPixels = new THREE.Vector2(1, 1);
      if (program === undefined) {
        init();
      }
      gl.useProgram(program);
      state.initAttributes();
      state.enableAttribute(attributes.vertex);
      state.enableAttribute(attributes.uv);
      state.disableUnusedAttributes();
      gl.uniform1i(uniforms.occlusionMap, 0);
      gl.uniform1i(uniforms.map, 1);
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
      gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
      state.disable(gl.CULL_FACE);
      gl.depthMask(false);
      for (var i = 0,
          l = flares.length; i < l; i++) {
        size = 16 / viewportHeight;
        scale.set(size * invAspect, size);
        var flare = flares[i];
        tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
        tempPosition.applyMatrix4(camera.matrixWorldInverse);
        tempPosition.applyProjection(camera.projectionMatrix);
        screenPosition.copy(tempPosition);
        screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
        screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
        if (hasVertexTexture || (screenPositionPixels.x > 0 && screenPositionPixels.x < viewportWidth && screenPositionPixels.y > 0 && screenPositionPixels.y < viewportHeight)) {
          state.activeTexture(gl.TEXTURE0);
          state.bindTexture(gl.TEXTURE_2D, null);
          state.activeTexture(gl.TEXTURE1);
          state.bindTexture(gl.TEXTURE_2D, tempTexture);
          gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
          gl.uniform1i(uniforms.renderType, 0);
          gl.uniform2f(uniforms.scale, scale.x, scale.y);
          gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
          state.disable(gl.BLEND);
          state.enable(gl.DEPTH_TEST);
          gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
          state.activeTexture(gl.TEXTURE0);
          state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
          gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
          gl.uniform1i(uniforms.renderType, 1);
          state.disable(gl.DEPTH_TEST);
          state.activeTexture(gl.TEXTURE1);
          state.bindTexture(gl.TEXTURE_2D, tempTexture);
          gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
          flare.positionScreen.copy(screenPosition);
          if (flare.customUpdateCallback) {
            flare.customUpdateCallback(flare);
          } else {
            flare.updateLensFlares();
          }
          gl.uniform1i(uniforms.renderType, 2);
          state.enable(gl.BLEND);
          for (var j = 0,
              jl = flare.lensFlares.length; j < jl; j++) {
            var sprite = flare.lensFlares[j];
            if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
              screenPosition.x = sprite.x;
              screenPosition.y = sprite.y;
              screenPosition.z = sprite.z;
              size = sprite.size * sprite.scale / viewportHeight;
              scale.x = size * invAspect;
              scale.y = size;
              gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
              gl.uniform2f(uniforms.scale, scale.x, scale.y);
              gl.uniform1f(uniforms.rotation, sprite.rotation);
              gl.uniform1f(uniforms.opacity, sprite.opacity);
              gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
              state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
              renderer.setTexture(sprite.texture, 1);
              gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            }
          }
        }
      }
      state.enable(gl.CULL_FACE);
      state.enable(gl.DEPTH_TEST);
      gl.depthMask(true);
      renderer.resetGLState();
    };
    function createProgram(shader) {
      var program = gl.createProgram();
      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      var prefix = "precision " + renderer.getPrecision() + " float;\n";
      gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
      gl.shaderSource(vertexShader, prefix + shader.vertexShader);
      gl.compileShader(fragmentShader);
      gl.compileShader(vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.attachShader(program, vertexShader);
      gl.linkProgram(program);
      return program;
    }
  };
  THREE.SpritePlugin = function(renderer, sprites) {
    var gl = renderer.context;
    var state = renderer.state;
    var vertexBuffer,
        elementBuffer;
    var program,
        attributes,
        uniforms;
    var texture;
    var spritePosition = new THREE.Vector3();
    var spriteRotation = new THREE.Quaternion();
    var spriteScale = new THREE.Vector3();
    function init() {
      var vertices = new Float32Array([-0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1]);
      var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
      vertexBuffer = gl.createBuffer();
      elementBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
      program = createProgram();
      attributes = {
        position: gl.getAttribLocation(program, 'position'),
        uv: gl.getAttribLocation(program, 'uv')
      };
      uniforms = {
        uvOffset: gl.getUniformLocation(program, 'uvOffset'),
        uvScale: gl.getUniformLocation(program, 'uvScale'),
        rotation: gl.getUniformLocation(program, 'rotation'),
        scale: gl.getUniformLocation(program, 'scale'),
        color: gl.getUniformLocation(program, 'color'),
        map: gl.getUniformLocation(program, 'map'),
        opacity: gl.getUniformLocation(program, 'opacity'),
        modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
        projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
        fogType: gl.getUniformLocation(program, 'fogType'),
        fogDensity: gl.getUniformLocation(program, 'fogDensity'),
        fogNear: gl.getUniformLocation(program, 'fogNear'),
        fogFar: gl.getUniformLocation(program, 'fogFar'),
        fogColor: gl.getUniformLocation(program, 'fogColor'),
        alphaTest: gl.getUniformLocation(program, 'alphaTest')
      };
      var canvas = document.createElement('canvas');
      canvas.width = 8;
      canvas.height = 8;
      var context = canvas.getContext('2d');
      context.fillStyle = 'white';
      context.fillRect(0, 0, 8, 8);
      texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
    }
    this.render = function(scene, camera) {
      if (sprites.length === 0)
        return;
      if (program === undefined) {
        init();
      }
      gl.useProgram(program);
      state.initAttributes();
      state.enableAttribute(attributes.position);
      state.enableAttribute(attributes.uv);
      state.disableUnusedAttributes();
      state.disable(gl.CULL_FACE);
      state.enable(gl.BLEND);
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
      gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
      gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
      state.activeTexture(gl.TEXTURE0);
      gl.uniform1i(uniforms.map, 0);
      var oldFogType = 0;
      var sceneFogType = 0;
      var fog = scene.fog;
      if (fog) {
        gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
        if (fog instanceof THREE.Fog) {
          gl.uniform1f(uniforms.fogNear, fog.near);
          gl.uniform1f(uniforms.fogFar, fog.far);
          gl.uniform1i(uniforms.fogType, 1);
          oldFogType = 1;
          sceneFogType = 1;
        } else if (fog instanceof THREE.FogExp2) {
          gl.uniform1f(uniforms.fogDensity, fog.density);
          gl.uniform1i(uniforms.fogType, 2);
          oldFogType = 2;
          sceneFogType = 2;
        }
      } else {
        gl.uniform1i(uniforms.fogType, 0);
        oldFogType = 0;
        sceneFogType = 0;
      }
      for (var i = 0,
          l = sprites.length; i < l; i++) {
        var sprite = sprites[i];
        sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
        sprite.z = -sprite.modelViewMatrix.elements[14];
      }
      sprites.sort(painterSortStable);
      var scale = [];
      for (var i = 0,
          l = sprites.length; i < l; i++) {
        var sprite = sprites[i];
        var material = sprite.material;
        gl.uniform1f(uniforms.alphaTest, material.alphaTest);
        gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
        sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
        scale[0] = spriteScale.x;
        scale[1] = spriteScale.y;
        var fogType = 0;
        if (scene.fog && material.fog) {
          fogType = sceneFogType;
        }
        if (oldFogType !== fogType) {
          gl.uniform1i(uniforms.fogType, fogType);
          oldFogType = fogType;
        }
        if (material.map !== null) {
          gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
          gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
        } else {
          gl.uniform2f(uniforms.uvOffset, 0, 0);
          gl.uniform2f(uniforms.uvScale, 1, 1);
        }
        gl.uniform1f(uniforms.opacity, material.opacity);
        gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
        gl.uniform1f(uniforms.rotation, material.rotation);
        gl.uniform2fv(uniforms.scale, scale);
        state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
        state.setDepthTest(material.depthTest);
        state.setDepthWrite(material.depthWrite);
        if (material.map && material.map.image && material.map.image.width) {
          renderer.setTexture(material.map, 0);
        } else {
          renderer.setTexture(texture, 0);
        }
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
      }
      state.enable(gl.CULL_FACE);
      renderer.resetGLState();
    };
    function createProgram() {
      var program = gl.createProgram();
      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vertexShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform float rotation;', 'uniform vec2 scale;', 'uniform vec2 uvOffset;', 'uniform vec2 uvScale;', 'attribute vec2 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'void main() {', 'vUV = uvOffset + uv * uvScale;', 'vec2 alignedPosition = position * scale;', 'vec2 rotatedPosition;', 'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;', 'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;', 'vec4 finalPosition;', 'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );', 'finalPosition.xy += rotatedPosition;', 'finalPosition = projectionMatrix * finalPosition;', 'gl_Position = finalPosition;', '}'].join('\n'));
      gl.shaderSource(fragmentShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform vec3 color;', 'uniform sampler2D map;', 'uniform float opacity;', 'uniform int fogType;', 'uniform vec3 fogColor;', 'uniform float fogDensity;', 'uniform float fogNear;', 'uniform float fogFar;', 'uniform float alphaTest;', 'varying vec2 vUV;', 'void main() {', 'vec4 texture = texture2D( map, vUV );', 'if ( texture.a < alphaTest ) discard;', 'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );', 'if ( fogType > 0 ) {', 'float depth = gl_FragCoord.z / gl_FragCoord.w;', 'float fogFactor = 0.0;', 'if ( fogType == 1 ) {', 'fogFactor = smoothstep( fogNear, fogFar, depth );', '} else {', 'const float LOG2 = 1.442695;', 'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );', 'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );', '}', 'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );', '}', '}'].join('\n'));
      gl.compileShader(vertexShader);
      gl.compileShader(fragmentShader);
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      return program;
    }
    function painterSortStable(a, b) {
      if (a.z !== b.z) {
        return b.z - a.z;
      } else {
        return b.id - a.id;
      }
    }
  };
  THREE.CurveUtils = {
    tangentQuadraticBezier: function(t, p0, p1, p2) {
      return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
    },
    tangentCubicBezier: function(t, p0, p1, p2, p3) {
      return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;
    },
    tangentSpline: function(t, p0, p1, p2, p3) {
      var h00 = 6 * t * t - 6 * t;
      var h10 = 3 * t * t - 4 * t + 1;
      var h01 = -6 * t * t + 6 * t;
      var h11 = 3 * t * t - 2 * t;
      return h00 + h10 + h01 + h11;
    },
    interpolate: function(p0, p1, p2, p3, t) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      var t2 = t * t;
      var t3 = t * t2;
      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
  };
  THREE.GeometryUtils = {
    merge: function(geometry1, geometry2, materialIndexOffset) {
      console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
      var matrix;
      if (geometry2 instanceof THREE.Mesh) {
        geometry2.matrixAutoUpdate && geometry2.updateMatrix();
        matrix = geometry2.matrix;
        geometry2 = geometry2.geometry;
      }
      geometry1.merge(geometry2, matrix, materialIndexOffset);
    },
    center: function(geometry) {
      console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
      return geometry.center();
    }
  };
  THREE.ImageUtils = {
    crossOrigin: undefined,
    loadTexture: function(url, mapping, onLoad, onError) {
      console.warn('THREE.ImageUtils.loadTexture is being deprecated. Use THREE.TextureLoader() instead.');
      var loader = new THREE.TextureLoader();
      loader.setCrossOrigin(this.crossOrigin);
      var texture = loader.load(url, onLoad, undefined, onError);
      if (mapping)
        texture.mapping = mapping;
      return texture;
    },
    loadTextureCube: function(urls, mapping, onLoad, onError) {
      console.warn('THREE.ImageUtils.loadTextureCube is being deprecated. Use THREE.CubeTextureLoader() instead.');
      var loader = new THREE.CubeTextureLoader();
      loader.setCrossOrigin(this.crossOrigin);
      var texture = loader.load(urls, onLoad, undefined, onError);
      if (mapping)
        texture.mapping = mapping;
      return texture;
    },
    loadCompressedTexture: function() {
      console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
    },
    loadCompressedTextureCube: function() {
      console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
    }
  };
  THREE.SceneUtils = {
    createMultiMaterialObject: function(geometry, materials) {
      var group = new THREE.Group();
      for (var i = 0,
          l = materials.length; i < l; i++) {
        group.add(new THREE.Mesh(geometry, materials[i]));
      }
      return group;
    },
    detach: function(child, parent, scene) {
      child.applyMatrix(parent.matrixWorld);
      parent.remove(child);
      scene.add(child);
    },
    attach: function(child, scene, parent) {
      var matrixWorldInverse = new THREE.Matrix4();
      matrixWorldInverse.getInverse(parent.matrixWorld);
      child.applyMatrix(matrixWorldInverse);
      scene.remove(child);
      parent.add(child);
    }
  };
  THREE.ShapeUtils = {
    area: function(contour) {
      var n = contour.length;
      var a = 0.0;
      for (var p = n - 1,
          q = 0; q < n; p = q++) {
        a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
      }
      return a * 0.5;
    },
    triangulate: (function() {
      function snip(contour, u, v, w, n, verts) {
        var p;
        var ax,
            ay,
            bx,
            by;
        var cx,
            cy,
            px,
            py;
        ax = contour[verts[u]].x;
        ay = contour[verts[u]].y;
        bx = contour[verts[v]].x;
        by = contour[verts[v]].y;
        cx = contour[verts[w]].x;
        cy = contour[verts[w]].y;
        if (Number.EPSILON > (((bx - ax) * (cy - ay)) - ((by - ay) * (cx - ax))))
          return false;
        var aX,
            aY,
            bX,
            bY,
            cX,
            cY;
        var apx,
            apy,
            bpx,
            bpy,
            cpx,
            cpy;
        var cCROSSap,
            bCROSScp,
            aCROSSbp;
        aX = cx - bx;
        aY = cy - by;
        bX = ax - cx;
        bY = ay - cy;
        cX = bx - ax;
        cY = by - ay;
        for (p = 0; p < n; p++) {
          px = contour[verts[p]].x;
          py = contour[verts[p]].y;
          if (((px === ax) && (py === ay)) || ((px === bx) && (py === by)) || ((px === cx) && (py === cy)))
            continue;
          apx = px - ax;
          apy = py - ay;
          bpx = px - bx;
          bpy = py - by;
          cpx = px - cx;
          cpy = py - cy;
          aCROSSbp = aX * bpy - aY * bpx;
          cCROSSap = cX * apy - cY * apx;
          bCROSScp = bX * cpy - bY * cpx;
          if ((aCROSSbp >= -Number.EPSILON) && (bCROSScp >= -Number.EPSILON) && (cCROSSap >= -Number.EPSILON))
            return false;
        }
        return true;
      }
      return function(contour, indices) {
        var n = contour.length;
        if (n < 3)
          return null;
        var result = [],
            verts = [],
            vertIndices = [];
        var u,
            v,
            w;
        if (THREE.ShapeUtils.area(contour) > 0.0) {
          for (v = 0; v < n; v++)
            verts[v] = v;
        } else {
          for (v = 0; v < n; v++)
            verts[v] = (n - 1) - v;
        }
        var nv = n;
        var count = 2 * nv;
        for (v = nv - 1; nv > 2; ) {
          if ((count--) <= 0) {
            console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');
            if (indices)
              return vertIndices;
            return result;
          }
          u = v;
          if (nv <= u)
            u = 0;
          v = u + 1;
          if (nv <= v)
            v = 0;
          w = v + 1;
          if (nv <= w)
            w = 0;
          if (snip(contour, u, v, w, nv, verts)) {
            var a,
                b,
                c,
                s,
                t;
            a = verts[u];
            b = verts[v];
            c = verts[w];
            result.push([contour[a], contour[b], contour[c]]);
            vertIndices.push([verts[u], verts[v], verts[w]]);
            for (s = v, t = v + 1; t < nv; s++, t++) {
              verts[s] = verts[t];
            }
            nv--;
            count = 2 * nv;
          }
        }
        if (indices)
          return vertIndices;
        return result;
      };
    })(),
    triangulateShape: function(contour, holes) {
      function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
        if (inSegPt1.x !== inSegPt2.x) {
          if (inSegPt1.x < inSegPt2.x) {
            return ((inSegPt1.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt2.x));
          } else {
            return ((inSegPt2.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt1.x));
          }
        } else {
          if (inSegPt1.y < inSegPt2.y) {
            return ((inSegPt1.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt2.y));
          } else {
            return ((inSegPt2.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt1.y));
          }
        }
      }
      function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
        var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,
            seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
        var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,
            seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
        var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
        var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
        var limit = seg1dy * seg2dx - seg1dx * seg2dy;
        var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
        if (Math.abs(limit) > Number.EPSILON) {
          var perpSeg2;
          if (limit > 0) {
            if ((perpSeg1 < 0) || (perpSeg1 > limit))
              return [];
            perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
            if ((perpSeg2 < 0) || (perpSeg2 > limit))
              return [];
          } else {
            if ((perpSeg1 > 0) || (perpSeg1 < limit))
              return [];
            perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
            if ((perpSeg2 > 0) || (perpSeg2 < limit))
              return [];
          }
          if (perpSeg2 === 0) {
            if ((inExcludeAdjacentSegs) && ((perpSeg1 === 0) || (perpSeg1 === limit)))
              return [];
            return [inSeg1Pt1];
          }
          if (perpSeg2 === limit) {
            if ((inExcludeAdjacentSegs) && ((perpSeg1 === 0) || (perpSeg1 === limit)))
              return [];
            return [inSeg1Pt2];
          }
          if (perpSeg1 === 0)
            return [inSeg2Pt1];
          if (perpSeg1 === limit)
            return [inSeg2Pt2];
          var factorSeg1 = perpSeg2 / limit;
          return [{
            x: inSeg1Pt1.x + factorSeg1 * seg1dx,
            y: inSeg1Pt1.y + factorSeg1 * seg1dy
          }];
        } else {
          if ((perpSeg1 !== 0) || (seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy))
            return [];
          var seg1Pt = ((seg1dx === 0) && (seg1dy === 0));
          var seg2Pt = ((seg2dx === 0) && (seg2dy === 0));
          if (seg1Pt && seg2Pt) {
            if ((inSeg1Pt1.x !== inSeg2Pt1.x) || (inSeg1Pt1.y !== inSeg2Pt1.y))
              return [];
            return [inSeg1Pt1];
          }
          if (seg1Pt) {
            if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1))
              return [];
            return [inSeg1Pt1];
          }
          if (seg2Pt) {
            if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1))
              return [];
            return [inSeg2Pt1];
          }
          var seg1min,
              seg1max,
              seg1minVal,
              seg1maxVal;
          var seg2min,
              seg2max,
              seg2minVal,
              seg2maxVal;
          if (seg1dx !== 0) {
            if (inSeg1Pt1.x < inSeg1Pt2.x) {
              seg1min = inSeg1Pt1;
              seg1minVal = inSeg1Pt1.x;
              seg1max = inSeg1Pt2;
              seg1maxVal = inSeg1Pt2.x;
            } else {
              seg1min = inSeg1Pt2;
              seg1minVal = inSeg1Pt2.x;
              seg1max = inSeg1Pt1;
              seg1maxVal = inSeg1Pt1.x;
            }
            if (inSeg2Pt1.x < inSeg2Pt2.x) {
              seg2min = inSeg2Pt1;
              seg2minVal = inSeg2Pt1.x;
              seg2max = inSeg2Pt2;
              seg2maxVal = inSeg2Pt2.x;
            } else {
              seg2min = inSeg2Pt2;
              seg2minVal = inSeg2Pt2.x;
              seg2max = inSeg2Pt1;
              seg2maxVal = inSeg2Pt1.x;
            }
          } else {
            if (inSeg1Pt1.y < inSeg1Pt2.y) {
              seg1min = inSeg1Pt1;
              seg1minVal = inSeg1Pt1.y;
              seg1max = inSeg1Pt2;
              seg1maxVal = inSeg1Pt2.y;
            } else {
              seg1min = inSeg1Pt2;
              seg1minVal = inSeg1Pt2.y;
              seg1max = inSeg1Pt1;
              seg1maxVal = inSeg1Pt1.y;
            }
            if (inSeg2Pt1.y < inSeg2Pt2.y) {
              seg2min = inSeg2Pt1;
              seg2minVal = inSeg2Pt1.y;
              seg2max = inSeg2Pt2;
              seg2maxVal = inSeg2Pt2.y;
            } else {
              seg2min = inSeg2Pt2;
              seg2minVal = inSeg2Pt2.y;
              seg2max = inSeg2Pt1;
              seg2maxVal = inSeg2Pt1.y;
            }
          }
          if (seg1minVal <= seg2minVal) {
            if (seg1maxVal < seg2minVal)
              return [];
            if (seg1maxVal === seg2minVal) {
              if (inExcludeAdjacentSegs)
                return [];
              return [seg2min];
            }
            if (seg1maxVal <= seg2maxVal)
              return [seg2min, seg1max];
            return [seg2min, seg2max];
          } else {
            if (seg1minVal > seg2maxVal)
              return [];
            if (seg1minVal === seg2maxVal) {
              if (inExcludeAdjacentSegs)
                return [];
              return [seg1min];
            }
            if (seg1maxVal <= seg2maxVal)
              return [seg1min, seg1max];
            return [seg1min, seg2max];
          }
        }
      }
      function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
        var legFromPtX = inLegFromPt.x - inVertex.x,
            legFromPtY = inLegFromPt.y - inVertex.y;
        var legToPtX = inLegToPt.x - inVertex.x,
            legToPtY = inLegToPt.y - inVertex.y;
        var otherPtX = inOtherPt.x - inVertex.x,
            otherPtY = inOtherPt.y - inVertex.y;
        var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
        var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
        if (Math.abs(from2toAngle) > Number.EPSILON) {
          var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
          if (from2toAngle > 0) {
            return ((from2otherAngle >= 0) && (other2toAngle >= 0));
          } else {
            return ((from2otherAngle >= 0) || (other2toAngle >= 0));
          }
        } else {
          return (from2otherAngle > 0);
        }
      }
      function removeHoles(contour, holes) {
        var shape = contour.concat();
        var hole;
        function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
          var lastShapeIdx = shape.length - 1;
          var prevShapeIdx = inShapeIdx - 1;
          if (prevShapeIdx < 0)
            prevShapeIdx = lastShapeIdx;
          var nextShapeIdx = inShapeIdx + 1;
          if (nextShapeIdx > lastShapeIdx)
            nextShapeIdx = 0;
          var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
          if (!insideAngle) {
            return false;
          }
          var lastHoleIdx = hole.length - 1;
          var prevHoleIdx = inHoleIdx - 1;
          if (prevHoleIdx < 0)
            prevHoleIdx = lastHoleIdx;
          var nextHoleIdx = inHoleIdx + 1;
          if (nextHoleIdx > lastHoleIdx)
            nextHoleIdx = 0;
          insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
          if (!insideAngle) {
            return false;
          }
          return true;
        }
        function intersectsShapeEdge(inShapePt, inHolePt) {
          var sIdx,
              nextIdx,
              intersection;
          for (sIdx = 0; sIdx < shape.length; sIdx++) {
            nextIdx = sIdx + 1;
            nextIdx %= shape.length;
            intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
            if (intersection.length > 0)
              return true;
          }
          return false;
        }
        var indepHoles = [];
        function intersectsHoleEdge(inShapePt, inHolePt) {
          var ihIdx,
              chkHole,
              hIdx,
              nextIdx,
              intersection;
          for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
            chkHole = holes[indepHoles[ihIdx]];
            for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
              nextIdx = hIdx + 1;
              nextIdx %= chkHole.length;
              intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
              if (intersection.length > 0)
                return true;
            }
          }
          return false;
        }
        var holeIndex,
            shapeIndex,
            shapePt,
            holePt,
            holeIdx,
            cutKey,
            failedCuts = [],
            tmpShape1,
            tmpShape2,
            tmpHole1,
            tmpHole2;
        for (var h = 0,
            hl = holes.length; h < hl; h++) {
          indepHoles.push(h);
        }
        var minShapeIndex = 0;
        var counter = indepHoles.length * 2;
        while (indepHoles.length > 0) {
          counter--;
          if (counter < 0) {
            console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
            break;
          }
          for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
            shapePt = shape[shapeIndex];
            holeIndex = -1;
            for (var h = 0; h < indepHoles.length; h++) {
              holeIdx = indepHoles[h];
              cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
              if (failedCuts[cutKey] !== undefined)
                continue;
              hole = holes[holeIdx];
              for (var h2 = 0; h2 < hole.length; h2++) {
                holePt = hole[h2];
                if (!isCutLineInsideAngles(shapeIndex, h2))
                  continue;
                if (intersectsShapeEdge(shapePt, holePt))
                  continue;
                if (intersectsHoleEdge(shapePt, holePt))
                  continue;
                holeIndex = h2;
                indepHoles.splice(h, 1);
                tmpShape1 = shape.slice(0, shapeIndex + 1);
                tmpShape2 = shape.slice(shapeIndex);
                tmpHole1 = hole.slice(holeIndex);
                tmpHole2 = hole.slice(0, holeIndex + 1);
                shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
                minShapeIndex = shapeIndex;
                break;
              }
              if (holeIndex >= 0)
                break;
              failedCuts[cutKey] = true;
            }
            if (holeIndex >= 0)
              break;
          }
        }
        return shape;
      }
      var i,
          il,
          f,
          face,
          key,
          index,
          allPointsMap = {};
      var allpoints = contour.concat();
      for (var h = 0,
          hl = holes.length; h < hl; h++) {
        Array.prototype.push.apply(allpoints, holes[h]);
      }
      for (i = 0, il = allpoints.length; i < il; i++) {
        key = allpoints[i].x + ":" + allpoints[i].y;
        if (allPointsMap[key] !== undefined) {
          console.warn("THREE.Shape: Duplicate point", key);
        }
        allPointsMap[key] = i;
      }
      var shapeWithoutHoles = removeHoles(contour, holes);
      var triangles = THREE.ShapeUtils.triangulate(shapeWithoutHoles, false);
      for (i = 0, il = triangles.length; i < il; i++) {
        face = triangles[i];
        for (f = 0; f < 3; f++) {
          key = face[f].x + ":" + face[f].y;
          index = allPointsMap[key];
          if (index !== undefined) {
            face[f] = index;
          }
        }
      }
      return triangles.concat();
    },
    isClockWise: function(pts) {
      return THREE.ShapeUtils.area(pts) < 0;
    },
    b2: (function() {
      function b2p0(t, p) {
        var k = 1 - t;
        return k * k * p;
      }
      function b2p1(t, p) {
        return 2 * (1 - t) * t * p;
      }
      function b2p2(t, p) {
        return t * t * p;
      }
      return function(t, p0, p1, p2) {
        return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2);
      };
    })(),
    b3: (function() {
      function b3p0(t, p) {
        var k = 1 - t;
        return k * k * k * p;
      }
      function b3p1(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
      }
      function b3p2(t, p) {
        var k = 1 - t;
        return 3 * k * t * t * p;
      }
      function b3p3(t, p) {
        return t * t * t * p;
      }
      return function(t, p0, p1, p2, p3) {
        return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3);
      };
    })()
  };
  THREE.Audio = function(listener) {
    THREE.Object3D.call(this);
    this.type = 'Audio';
    this.context = listener.context;
    this.source = this.context.createBufferSource();
    this.source.onended = this.onEnded.bind(this);
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.panner = this.context.createPanner();
    this.panner.connect(this.gain);
    this.autoplay = false;
    this.startTime = 0;
    this.playbackRate = 1;
    this.isPlaying = false;
  };
  THREE.Audio.prototype = Object.create(THREE.Object3D.prototype);
  THREE.Audio.prototype.constructor = THREE.Audio;
  THREE.Audio.prototype.load = function(file) {
    var scope = this;
    var request = new XMLHttpRequest();
    request.open('GET', file, true);
    request.responseType = 'arraybuffer';
    request.onload = function(e) {
      scope.context.decodeAudioData(this.response, function(buffer) {
        scope.source.buffer = buffer;
        if (scope.autoplay)
          scope.play();
      });
    };
    request.send();
    return this;
  };
  THREE.Audio.prototype.play = function() {
    if (this.isPlaying === true) {
      console.warn('THREE.Audio: Audio is already playing.');
      return;
    }
    var source = this.context.createBufferSource();
    source.buffer = this.source.buffer;
    source.loop = this.source.loop;
    source.onended = this.source.onended;
    source.start(0, this.startTime);
    source.playbackRate.value = this.playbackRate;
    this.isPlaying = true;
    this.source = source;
    this.connect();
  };
  THREE.Audio.prototype.pause = function() {
    this.source.stop();
    this.startTime = this.context.currentTime;
  };
  THREE.Audio.prototype.stop = function() {
    this.source.stop();
    this.startTime = 0;
  };
  THREE.Audio.prototype.connect = function() {
    if (this.filter !== undefined) {
      this.source.connect(this.filter);
      this.filter.connect(this.panner);
    } else {
      this.source.connect(this.panner);
    }
  };
  THREE.Audio.prototype.disconnect = function() {
    if (this.filter !== undefined) {
      this.source.disconnect(this.filter);
      this.filter.disconnect(this.panner);
    } else {
      this.source.disconnect(this.panner);
    }
  };
  THREE.Audio.prototype.setFilter = function(value) {
    if (this.isPlaying === true) {
      this.disconnect();
      this.filter = value;
      this.connect();
    } else {
      this.filter = value;
    }
  };
  THREE.Audio.prototype.getFilter = function() {
    return this.filter;
  };
  THREE.Audio.prototype.setPlaybackRate = function(value) {
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.value = this.playbackRate;
    }
  };
  THREE.Audio.prototype.getPlaybackRate = function() {
    return this.playbackRate;
  };
  THREE.Audio.prototype.onEnded = function() {
    this.isPlaying = false;
  };
  THREE.Audio.prototype.setLoop = function(value) {
    this.source.loop = value;
  };
  THREE.Audio.prototype.getLoop = function() {
    return this.source.loop;
  };
  THREE.Audio.prototype.setRefDistance = function(value) {
    this.panner.refDistance = value;
  };
  THREE.Audio.prototype.getRefDistance = function() {
    return this.panner.refDistance;
  };
  THREE.Audio.prototype.setRolloffFactor = function(value) {
    this.panner.rolloffFactor = value;
  };
  THREE.Audio.prototype.getRolloffFactor = function() {
    return this.panner.rolloffFactor;
  };
  THREE.Audio.prototype.setVolume = function(value) {
    this.gain.gain.value = value;
  };
  THREE.Audio.prototype.getVolume = function() {
    return this.gain.gain.value;
  };
  THREE.Audio.prototype.updateMatrixWorld = (function() {
    var position = new THREE.Vector3();
    return function updateMatrixWorld(force) {
      THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
      position.setFromMatrixPosition(this.matrixWorld);
      this.panner.setPosition(position.x, position.y, position.z);
    };
  })();
  THREE.AudioListener = function() {
    THREE.Object3D.call(this);
    this.type = 'AudioListener';
    this.context = new (window.AudioContext || window.webkitAudioContext)();
  };
  THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype);
  THREE.AudioListener.prototype.constructor = THREE.AudioListener;
  THREE.AudioListener.prototype.updateMatrixWorld = (function() {
    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3();
    var orientation = new THREE.Vector3();
    return function updateMatrixWorld(force) {
      THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
      var listener = this.context.listener;
      var up = this.up;
      this.matrixWorld.decompose(position, quaternion, scale);
      orientation.set(0, 0, -1).applyQuaternion(quaternion);
      listener.setPosition(position.x, position.y, position.z);
      listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
    };
  })();
  THREE.Curve = function() {};
  THREE.Curve.prototype = {
    constructor: THREE.Curve,
    getPoint: function(t) {
      console.warn("THREE.Curve: Warning, getPoint() not implemented!");
      return null;
    },
    getPointAt: function(u) {
      var t = this.getUtoTmapping(u);
      return this.getPoint(t);
    },
    getPoints: function(divisions) {
      if (!divisions)
        divisions = 5;
      var d,
          pts = [];
      for (d = 0; d <= divisions; d++) {
        pts.push(this.getPoint(d / divisions));
      }
      return pts;
    },
    getSpacedPoints: function(divisions) {
      if (!divisions)
        divisions = 5;
      var d,
          pts = [];
      for (d = 0; d <= divisions; d++) {
        pts.push(this.getPointAt(d / divisions));
      }
      return pts;
    },
    getLength: function() {
      var lengths = this.getLengths();
      return lengths[lengths.length - 1];
    },
    getLengths: function(divisions) {
      if (!divisions)
        divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;
      if (this.cacheArcLengths && (this.cacheArcLengths.length === divisions + 1) && !this.needsUpdate) {
        return this.cacheArcLengths;
      }
      this.needsUpdate = false;
      var cache = [];
      var current,
          last = this.getPoint(0);
      var p,
          sum = 0;
      cache.push(0);
      for (p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions);
        sum += current.distanceTo(last);
        cache.push(sum);
        last = current;
      }
      this.cacheArcLengths = cache;
      return cache;
    },
    updateArcLengths: function() {
      this.needsUpdate = true;
      this.getLengths();
    },
    getUtoTmapping: function(u, distance) {
      var arcLengths = this.getLengths();
      var i = 0,
          il = arcLengths.length;
      var targetArcLength;
      if (distance) {
        targetArcLength = distance;
      } else {
        targetArcLength = u * arcLengths[il - 1];
      }
      var low = 0,
          high = il - 1,
          comparison;
      while (low <= high) {
        i = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i] - targetArcLength;
        if (comparison < 0) {
          low = i + 1;
        } else if (comparison > 0) {
          high = i - 1;
        } else {
          high = i;
          break;
        }
      }
      i = high;
      if (arcLengths[i] === targetArcLength) {
        var t = i / (il - 1);
        return t;
      }
      var lengthBefore = arcLengths[i];
      var lengthAfter = arcLengths[i + 1];
      var segmentLength = lengthAfter - lengthBefore;
      var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
      var t = (i + segmentFraction) / (il - 1);
      return t;
    },
    getTangent: function(t) {
      var delta = 0.0001;
      var t1 = t - delta;
      var t2 = t + delta;
      if (t1 < 0)
        t1 = 0;
      if (t2 > 1)
        t2 = 1;
      var pt1 = this.getPoint(t1);
      var pt2 = this.getPoint(t2);
      var vec = pt2.clone().sub(pt1);
      return vec.normalize();
    },
    getTangentAt: function(u) {
      var t = this.getUtoTmapping(u);
      return this.getTangent(t);
    }
  };
  THREE.Curve.Utils = THREE.CurveUtils;
  THREE.Curve.create = function(constructor, getPointFunc) {
    constructor.prototype = Object.create(THREE.Curve.prototype);
    constructor.prototype.constructor = constructor;
    constructor.prototype.getPoint = getPointFunc;
    return constructor;
  };
  THREE.CurvePath = function() {
    this.curves = [];
    this.autoClose = false;
  };
  THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
  THREE.CurvePath.prototype.constructor = THREE.CurvePath;
  THREE.CurvePath.prototype.add = function(curve) {
    this.curves.push(curve);
  };
  THREE.CurvePath.prototype.closePath = function() {
    var startPoint = this.curves[0].getPoint(0);
    var endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new THREE.LineCurve(endPoint, startPoint));
    }
  };
  THREE.CurvePath.prototype.getPoint = function(t) {
    var d = t * this.getLength();
    var curveLengths = this.getCurveLengths();
    var i = 0;
    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        var diff = curveLengths[i] - d;
        var curve = this.curves[i];
        var u = 1 - diff / curve.getLength();
        return curve.getPointAt(u);
      }
      i++;
    }
    return null;
  };
  THREE.CurvePath.prototype.getLength = function() {
    var lens = this.getCurveLengths();
    return lens[lens.length - 1];
  };
  THREE.CurvePath.prototype.getCurveLengths = function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    var lengths = [],
        sums = 0;
    for (var i = 0,
        l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  };
  THREE.CurvePath.prototype.createPointsGeometry = function(divisions) {
    var pts = this.getPoints(divisions, true);
    return this.createGeometry(pts);
  };
  THREE.CurvePath.prototype.createSpacedPointsGeometry = function(divisions) {
    var pts = this.getSpacedPoints(divisions, true);
    return this.createGeometry(pts);
  };
  THREE.CurvePath.prototype.createGeometry = function(points) {
    var geometry = new THREE.Geometry();
    for (var i = 0,
        l = points.length; i < l; i++) {
      var point = points[i];
      geometry.vertices.push(new THREE.Vector3(point.x, point.y, point.z || 0));
    }
    return geometry;
  };
  THREE.Path = function(points) {
    THREE.CurvePath.call(this);
    this.actions = [];
    if (points) {
      this.fromPoints(points);
    }
  };
  THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
  THREE.Path.prototype.constructor = THREE.Path;
  THREE.Path.prototype.fromPoints = function(vectors) {
    this.moveTo(vectors[0].x, vectors[0].y);
    for (var i = 1,
        l = vectors.length; i < l; i++) {
      this.lineTo(vectors[i].x, vectors[i].y);
    }
  };
  THREE.Path.prototype.moveTo = function(x, y) {
    this.actions.push({
      action: 'moveTo',
      args: [x, y]
    });
  };
  THREE.Path.prototype.lineTo = function(x, y) {
    var lastargs = this.actions[this.actions.length - 1].args;
    var x0 = lastargs[lastargs.length - 2];
    var y0 = lastargs[lastargs.length - 1];
    var curve = new THREE.LineCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(x, y));
    this.curves.push(curve);
    this.actions.push({
      action: 'lineTo',
      args: [x, y]
    });
  };
  THREE.Path.prototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
    var lastargs = this.actions[this.actions.length - 1].args;
    var x0 = lastargs[lastargs.length - 2];
    var y0 = lastargs[lastargs.length - 1];
    var curve = new THREE.QuadraticBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCPx, aCPy), new THREE.Vector2(aX, aY));
    this.curves.push(curve);
    this.actions.push({
      action: 'quadraticCurveTo',
      args: [aCPx, aCPy, aX, aY]
    });
  };
  THREE.Path.prototype.bezierCurveTo = function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    var lastargs = this.actions[this.actions.length - 1].args;
    var x0 = lastargs[lastargs.length - 2];
    var y0 = lastargs[lastargs.length - 1];
    var curve = new THREE.CubicBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCP1x, aCP1y), new THREE.Vector2(aCP2x, aCP2y), new THREE.Vector2(aX, aY));
    this.curves.push(curve);
    this.actions.push({
      action: 'bezierCurveTo',
      args: [aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]
    });
  };
  THREE.Path.prototype.splineThru = function(pts) {
    var args = Array.prototype.slice.call(arguments);
    var lastargs = this.actions[this.actions.length - 1].args;
    var x0 = lastargs[lastargs.length - 2];
    var y0 = lastargs[lastargs.length - 1];
    var npts = [new THREE.Vector2(x0, y0)];
    Array.prototype.push.apply(npts, pts);
    var curve = new THREE.SplineCurve(npts);
    this.curves.push(curve);
    this.actions.push({
      action: 'splineThru',
      args: args
    });
  };
  THREE.Path.prototype.arc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    var lastargs = this.actions[this.actions.length - 1].args;
    var x0 = lastargs[lastargs.length - 2];
    var y0 = lastargs[lastargs.length - 1];
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
  };
  THREE.Path.prototype.absarc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  };
  THREE.Path.prototype.ellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    var lastargs = this.actions[this.actions.length - 1].args;
    var x0 = lastargs[lastargs.length - 2];
    var y0 = lastargs[lastargs.length - 1];
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
  };
  THREE.Path.prototype.absellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    var args = [aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation || 0];
    var curve = new THREE.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    this.curves.push(curve);
    var lastPoint = curve.getPoint(1);
    args.push(lastPoint.x);
    args.push(lastPoint.y);
    this.actions.push({
      action: 'ellipse',
      args: args
    });
  };
  THREE.Path.prototype.getSpacedPoints = function(divisions, closedPath) {
    if (!divisions)
      divisions = 40;
    var points = [];
    for (var i = 0; i < divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }
    return points;
  };
  THREE.Path.prototype.getPoints = function(divisions, closedPath) {
    divisions = divisions || 12;
    var b2 = THREE.ShapeUtils.b2;
    var b3 = THREE.ShapeUtils.b3;
    var points = [];
    var cpx,
        cpy,
        cpx2,
        cpy2,
        cpx1,
        cpy1,
        cpx0,
        cpy0,
        laste,
        tx,
        ty;
    for (var i = 0,
        l = this.actions.length; i < l; i++) {
      var item = this.actions[i];
      var action = item.action;
      var args = item.args;
      switch (action) {
        case 'moveTo':
          points.push(new THREE.Vector2(args[0], args[1]));
          break;
        case 'lineTo':
          points.push(new THREE.Vector2(args[0], args[1]));
          break;
        case 'quadraticCurveTo':
          cpx = args[2];
          cpy = args[3];
          cpx1 = args[0];
          cpy1 = args[1];
          if (points.length > 0) {
            laste = points[points.length - 1];
            cpx0 = laste.x;
            cpy0 = laste.y;
          } else {
            laste = this.actions[i - 1].args;
            cpx0 = laste[laste.length - 2];
            cpy0 = laste[laste.length - 1];
          }
          for (var j = 1; j <= divisions; j++) {
            var t = j / divisions;
            tx = b2(t, cpx0, cpx1, cpx);
            ty = b2(t, cpy0, cpy1, cpy);
            points.push(new THREE.Vector2(tx, ty));
          }
          break;
        case 'bezierCurveTo':
          cpx = args[4];
          cpy = args[5];
          cpx1 = args[0];
          cpy1 = args[1];
          cpx2 = args[2];
          cpy2 = args[3];
          if (points.length > 0) {
            laste = points[points.length - 1];
            cpx0 = laste.x;
            cpy0 = laste.y;
          } else {
            laste = this.actions[i - 1].args;
            cpx0 = laste[laste.length - 2];
            cpy0 = laste[laste.length - 1];
          }
          for (var j = 1; j <= divisions; j++) {
            var t = j / divisions;
            tx = b3(t, cpx0, cpx1, cpx2, cpx);
            ty = b3(t, cpy0, cpy1, cpy2, cpy);
            points.push(new THREE.Vector2(tx, ty));
          }
          break;
        case 'splineThru':
          laste = this.actions[i - 1].args;
          var last = new THREE.Vector2(laste[laste.length - 2], laste[laste.length - 1]);
          var spts = [last];
          var n = divisions * args[0].length;
          spts = spts.concat(args[0]);
          var spline = new THREE.SplineCurve(spts);
          for (var j = 1; j <= n; j++) {
            points.push(spline.getPointAt(j / n));
          }
          break;
        case 'arc':
          var aX = args[0],
              aY = args[1],
              aRadius = args[2],
              aStartAngle = args[3],
              aEndAngle = args[4],
              aClockwise = !!args[5];
          var deltaAngle = aEndAngle - aStartAngle;
          var angle;
          var tdivisions = divisions * 2;
          for (var j = 1; j <= tdivisions; j++) {
            var t = j / tdivisions;
            if (!aClockwise) {
              t = 1 - t;
            }
            angle = aStartAngle + t * deltaAngle;
            tx = aX + aRadius * Math.cos(angle);
            ty = aY + aRadius * Math.sin(angle);
            points.push(new THREE.Vector2(tx, ty));
          }
          break;
        case 'ellipse':
          var aX = args[0],
              aY = args[1],
              xRadius = args[2],
              yRadius = args[3],
              aStartAngle = args[4],
              aEndAngle = args[5],
              aClockwise = !!args[6],
              aRotation = args[7];
          var deltaAngle = aEndAngle - aStartAngle;
          var angle;
          var tdivisions = divisions * 2;
          var cos,
              sin;
          if (aRotation !== 0) {
            cos = Math.cos(aRotation);
            sin = Math.sin(aRotation);
          }
          for (var j = 1; j <= tdivisions; j++) {
            var t = j / tdivisions;
            if (!aClockwise) {
              t = 1 - t;
            }
            angle = aStartAngle + t * deltaAngle;
            tx = aX + xRadius * Math.cos(angle);
            ty = aY + yRadius * Math.sin(angle);
            if (aRotation !== 0) {
              var x = tx,
                  y = ty;
              tx = (x - aX) * cos - (y - aY) * sin + aX;
              ty = (x - aX) * sin + (y - aY) * cos + aY;
            }
            points.push(new THREE.Vector2(tx, ty));
          }
          break;
      }
    }
    var lastPoint = points[points.length - 1];
    if (Math.abs(lastPoint.x - points[0].x) < Number.EPSILON && Math.abs(lastPoint.y - points[0].y) < Number.EPSILON)
      points.splice(points.length - 1, 1);
    if (closedPath) {
      points.push(points[0]);
    }
    return points;
  };
  THREE.Path.prototype.toShapes = function(isCCW, noHoles) {
    function extractSubpaths(inActions) {
      var subPaths = [],
          lastPath = new THREE.Path();
      for (var i = 0,
          l = inActions.length; i < l; i++) {
        var item = inActions[i];
        var args = item.args;
        var action = item.action;
        if (action === 'moveTo') {
          if (lastPath.actions.length !== 0) {
            subPaths.push(lastPath);
            lastPath = new THREE.Path();
          }
        }
        lastPath[action].apply(lastPath, args);
      }
      if (lastPath.actions.length !== 0) {
        subPaths.push(lastPath);
      }
      return subPaths;
    }
    function toShapesNoHoles(inSubpaths) {
      var shapes = [];
      for (var i = 0,
          l = inSubpaths.length; i < l; i++) {
        var tmpPath = inSubpaths[i];
        var tmpShape = new THREE.Shape();
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
      }
      return shapes;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      var polyLen = inPolygon.length;
      var inside = false;
      for (var p = polyLen - 1,
          q = 0; q < polyLen; p = q++) {
        var edgeLowPt = inPolygon[p];
        var edgeHighPt = inPolygon[q];
        var edgeDx = edgeHighPt.x - edgeLowPt.x;
        var edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }
          if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))
            continue;
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x)
              return true;
          } else {
            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0)
              return true;
            if (perpEdge < 0)
              continue;
            inside = !inside;
          }
        } else {
          if (inPt.y !== edgeLowPt.y)
            continue;
          if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) || ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))
            return true;
        }
      }
      return inside;
    }
    var isClockWise = THREE.ShapeUtils.isClockWise;
    var subPaths = extractSubpaths(this.actions);
    if (subPaths.length === 0)
      return [];
    if (noHoles === true)
      return toShapesNoHoles(subPaths);
    var solid,
        tmpPath,
        tmpShape,
        shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new THREE.Shape();
      tmpShape.actions = tmpPath.actions;
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    var holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    var betterShapeHoles = [];
    var newShapes = [];
    var newShapeHoles = [];
    var mainIdx = 0;
    var tmpPoints;
    newShapes[mainIdx] = undefined;
    newShapeHoles[mainIdx] = [];
    for (var i = 0,
        l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if ((!holesFirst) && (newShapes[mainIdx]))
          mainIdx++;
        newShapes[mainIdx] = {
          s: new THREE.Shape(),
          p: tmpPoints
        };
        newShapes[mainIdx].s.actions = tmpPath.actions;
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst)
          mainIdx++;
        newShapeHoles[mainIdx] = [];
      } else {
        newShapeHoles[mainIdx].push({
          h: tmpPath,
          p: tmpPoints[0]
        });
      }
    }
    if (!newShapes[0])
      return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
      var ambiguous = false;
      var toChange = [];
      for (var sIdx = 0,
          sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (var sIdx = 0,
          sLen = newShapes.length; sIdx < sLen; sIdx++) {
        var sho = newShapeHoles[sIdx];
        for (var hIdx = 0; hIdx < sho.length; hIdx++) {
          var ho = sho[hIdx];
          var hole_unassigned = true;
          for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx)
                toChange.push({
                  froms: sIdx,
                  tos: s2Idx,
                  hole: hIdx
                });
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      if (toChange.length > 0) {
        if (!ambiguous)
          newShapeHoles = betterShapeHoles;
      }
    }
    var tmpHoles;
    for (var i = 0,
        il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];
      for (var j = 0,
          jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    }
    return shapes;
  };
  THREE.Shape = function() {
    THREE.Path.apply(this, arguments);
    this.holes = [];
  };
  THREE.Shape.prototype = Object.create(THREE.Path.prototype);
  THREE.Shape.prototype.constructor = THREE.Shape;
  THREE.Shape.prototype.extrude = function(options) {
    return new THREE.ExtrudeGeometry(this, options);
  };
  THREE.Shape.prototype.makeGeometry = function(options) {
    return new THREE.ShapeGeometry(this, options);
  };
  THREE.Shape.prototype.getPointsHoles = function(divisions) {
    var holesPts = [];
    for (var i = 0,
        l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }
    return holesPts;
  };
  THREE.Shape.prototype.extractAllPoints = function(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  };
  THREE.Shape.prototype.extractPoints = function(divisions) {
    return this.extractAllPoints(divisions);
  };
  THREE.Shape.Utils = THREE.ShapeUtils;
  THREE.LineCurve = function(v1, v2) {
    this.v1 = v1;
    this.v2 = v2;
  };
  THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
  THREE.LineCurve.prototype.constructor = THREE.LineCurve;
  THREE.LineCurve.prototype.getPoint = function(t) {
    var point = this.v2.clone().sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
    return point;
  };
  THREE.LineCurve.prototype.getPointAt = function(u) {
    return this.getPoint(u);
  };
  THREE.LineCurve.prototype.getTangent = function(t) {
    var tangent = this.v2.clone().sub(this.v1);
    return tangent.normalize();
  };
  THREE.QuadraticBezierCurve = function(v0, v1, v2) {
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  };
  THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
  THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
  THREE.QuadraticBezierCurve.prototype.getPoint = function(t) {
    var b2 = THREE.ShapeUtils.b2;
    return new THREE.Vector2(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y));
  };
  THREE.QuadraticBezierCurve.prototype.getTangent = function(t) {
    var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;
    return new THREE.Vector2(tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x), tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y)).normalize();
  };
  THREE.CubicBezierCurve = function(v0, v1, v2, v3) {
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  };
  THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
  THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
  THREE.CubicBezierCurve.prototype.getPoint = function(t) {
    var b3 = THREE.ShapeUtils.b3;
    return new THREE.Vector2(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y));
  };
  THREE.CubicBezierCurve.prototype.getTangent = function(t) {
    var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;
    return new THREE.Vector2(tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize();
  };
  THREE.SplineCurve = function(points) {
    this.points = (points == undefined) ? [] : points;
  };
  THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
  THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
  THREE.SplineCurve.prototype.getPoint = function(t) {
    var points = this.points;
    var point = (points.length - 1) * t;
    var intPoint = Math.floor(point);
    var weight = point - intPoint;
    var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    var point1 = points[intPoint];
    var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    var interpolate = THREE.CurveUtils.interpolate;
    return new THREE.Vector2(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight));
  };
  THREE.EllipseCurve = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation || 0;
  };
  THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
  THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
  THREE.EllipseCurve.prototype.getPoint = function(t) {
    var deltaAngle = this.aEndAngle - this.aStartAngle;
    if (deltaAngle < 0)
      deltaAngle += Math.PI * 2;
    if (deltaAngle > Math.PI * 2)
      deltaAngle -= Math.PI * 2;
    var angle;
    if (this.aClockwise === true) {
      angle = this.aEndAngle + (1 - t) * (Math.PI * 2 - deltaAngle);
    } else {
      angle = this.aStartAngle + t * deltaAngle;
    }
    var x = this.aX + this.xRadius * Math.cos(angle);
    var y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      var cos = Math.cos(this.aRotation);
      var sin = Math.sin(this.aRotation);
      var tx = x,
          ty = y;
      x = (tx - this.aX) * cos - (ty - this.aY) * sin + this.aX;
      y = (tx - this.aX) * sin + (ty - this.aY) * cos + this.aY;
    }
    return new THREE.Vector2(x, y);
  };
  THREE.ArcCurve = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    THREE.EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  };
  THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
  THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
  THREE.LineCurve3 = THREE.Curve.create(function(v1, v2) {
    this.v1 = v1;
    this.v2 = v2;
  }, function(t) {
    var vector = new THREE.Vector3();
    vector.subVectors(this.v2, this.v1);
    vector.multiplyScalar(t);
    vector.add(this.v1);
    return vector;
  });
  THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(v0, v1, v2) {
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }, function(t) {
    var b2 = THREE.ShapeUtils.b2;
    return new THREE.Vector3(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y), b2(t, this.v0.z, this.v1.z, this.v2.z));
  });
  THREE.CubicBezierCurve3 = THREE.Curve.create(function(v0, v1, v2, v3) {
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }, function(t) {
    var b3 = THREE.ShapeUtils.b3;
    return new THREE.Vector3(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z));
  });
  THREE.SplineCurve3 = THREE.Curve.create(function(points) {
    console.warn('THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3');
    this.points = (points == undefined) ? [] : points;
  }, function(t) {
    var points = this.points;
    var point = (points.length - 1) * t;
    var intPoint = Math.floor(point);
    var weight = point - intPoint;
    var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
    var point1 = points[intPoint];
    var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    var interpolate = THREE.CurveUtils.interpolate;
    return new THREE.Vector3(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight), interpolate(point0.z, point1.z, point2.z, point3.z, weight));
  });
  THREE.CatmullRomCurve3 = (function() {
    var tmp = new THREE.Vector3(),
        px = new CubicPoly(),
        py = new CubicPoly(),
        pz = new CubicPoly();
    function CubicPoly() {}
    CubicPoly.prototype.init = function(x0, x1, t0, t1) {
      this.c0 = x0;
      this.c1 = t0;
      this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
      this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
    };
    CubicPoly.prototype.initNonuniformCatmullRom = function(x0, x1, x2, x3, dt0, dt1, dt2) {
      var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      this.init(x1, x2, t1, t2);
    };
    CubicPoly.prototype.initCatmullRom = function(x0, x1, x2, x3, tension) {
      this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    };
    CubicPoly.prototype.calc = function(t) {
      var t2 = t * t;
      var t3 = t2 * t;
      return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
    };
    return THREE.Curve.create(function(p) {
      this.points = p || [];
    }, function(t) {
      var points = this.points,
          point,
          intPoint,
          weight,
          l;
      l = points.length;
      if (l < 2)
        console.log('duh, you need at least 2 points');
      point = (l - 1) * t;
      intPoint = Math.floor(point);
      weight = point - intPoint;
      if (weight === 0 && intPoint === l - 1) {
        intPoint = l - 2;
        weight = 1;
      }
      var p0,
          p1,
          p2,
          p3;
      if (intPoint === 0) {
        tmp.subVectors(points[0], points[1]).add(points[0]);
        p0 = tmp;
      } else {
        p0 = points[intPoint - 1];
      }
      p1 = points[intPoint];
      p2 = points[intPoint + 1];
      if (intPoint + 2 < l) {
        p3 = points[intPoint + 2];
      } else {
        tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 2]);
        p3 = tmp;
      }
      if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {
        var pow = this.type === 'chordal' ? 0.5 : 0.25;
        var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
        var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
        var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
        if (dt1 < 1e-4)
          dt1 = 1.0;
        if (dt0 < 1e-4)
          dt0 = dt1;
        if (dt2 < 1e-4)
          dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
      } else if (this.type === 'catmullrom') {
        var tension = this.tension !== undefined ? this.tension : 0.5;
        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
      }
      var v = new THREE.Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
      return v;
    });
  })();
  THREE.ClosedSplineCurve3 = THREE.Curve.create(function(points) {
    this.points = (points == undefined) ? [] : points;
  }, function(t) {
    var points = this.points;
    var point = (points.length - 0) * t;
    var intPoint = Math.floor(point);
    var weight = point - intPoint;
    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
    var point0 = points[(intPoint - 1) % points.length];
    var point1 = points[(intPoint) % points.length];
    var point2 = points[(intPoint + 1) % points.length];
    var point3 = points[(intPoint + 2) % points.length];
    var interpolate = THREE.CurveUtils.interpolate;
    return new THREE.Vector3(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight), interpolate(point0.z, point1.z, point2.z, point3.z, weight));
  });
  THREE.BoxGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
    THREE.Geometry.call(this);
    this.type = 'BoxGeometry';
    this.parameters = {
      width: width,
      height: height,
      depth: depth,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      depthSegments: depthSegments
    };
    this.widthSegments = widthSegments || 1;
    this.heightSegments = heightSegments || 1;
    this.depthSegments = depthSegments || 1;
    var scope = this;
    var width_half = width / 2;
    var height_half = height / 2;
    var depth_half = depth / 2;
    buildPlane('z', 'y', -1, -1, depth, height, width_half, 0);
    buildPlane('z', 'y', 1, -1, depth, height, -width_half, 1);
    buildPlane('x', 'z', 1, 1, width, depth, height_half, 2);
    buildPlane('x', 'z', 1, -1, width, depth, -height_half, 3);
    buildPlane('x', 'y', 1, -1, width, height, depth_half, 4);
    buildPlane('x', 'y', -1, -1, width, height, -depth_half, 5);
    function buildPlane(u, v, udir, vdir, width, height, depth, materialIndex) {
      var w,
          ix,
          iy,
          gridX = scope.widthSegments,
          gridY = scope.heightSegments,
          width_half = width / 2,
          height_half = height / 2,
          offset = scope.vertices.length;
      if ((u === 'x' && v === 'y') || (u === 'y' && v === 'x')) {
        w = 'z';
      } else if ((u === 'x' && v === 'z') || (u === 'z' && v === 'x')) {
        w = 'y';
        gridY = scope.depthSegments;
      } else if ((u === 'z' && v === 'y') || (u === 'y' && v === 'z')) {
        w = 'x';
        gridX = scope.depthSegments;
      }
      var gridX1 = gridX + 1,
          gridY1 = gridY + 1,
          segment_width = width / gridX,
          segment_height = height / gridY,
          normal = new THREE.Vector3();
      normal[w] = depth > 0 ? 1 : -1;
      for (iy = 0; iy < gridY1; iy++) {
        for (ix = 0; ix < gridX1; ix++) {
          var vector = new THREE.Vector3();
          vector[u] = (ix * segment_width - width_half) * udir;
          vector[v] = (iy * segment_height - height_half) * vdir;
          vector[w] = depth;
          scope.vertices.push(vector);
        }
      }
      for (iy = 0; iy < gridY; iy++) {
        for (ix = 0; ix < gridX; ix++) {
          var a = ix + gridX1 * iy;
          var b = ix + gridX1 * (iy + 1);
          var c = (ix + 1) + gridX1 * (iy + 1);
          var d = (ix + 1) + gridX1 * iy;
          var uva = new THREE.Vector2(ix / gridX, 1 - iy / gridY);
          var uvb = new THREE.Vector2(ix / gridX, 1 - (iy + 1) / gridY);
          var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iy + 1) / gridY);
          var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iy / gridY);
          var face = new THREE.Face3(a + offset, b + offset, d + offset);
          face.normal.copy(normal);
          face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
          face.materialIndex = materialIndex;
          scope.faces.push(face);
          scope.faceVertexUvs[0].push([uva, uvb, uvd]);
          face = new THREE.Face3(b + offset, c + offset, d + offset);
          face.normal.copy(normal);
          face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
          face.materialIndex = materialIndex;
          scope.faces.push(face);
          scope.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
        }
      }
    }
    this.mergeVertices();
  };
  THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
  THREE.BoxGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.BoxGeometry(parameters.width, parameters.height, parameters.depth, parameters.widthSegments, parameters.heightSegments, parameters.depthSegments);
  };
  THREE.CubeGeometry = THREE.BoxGeometry;
  THREE.CircleGeometry = function(radius, segments, thetaStart, thetaLength) {
    THREE.Geometry.call(this);
    this.type = 'CircleGeometry';
    this.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    this.fromBufferGeometry(new THREE.CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
  };
  THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
  THREE.CircleGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.CircleGeometry(parameters.radius, parameters.segments, parameters.thetaStart, parameters.thetaLength);
  };
  THREE.CircleBufferGeometry = function(radius, segments, thetaStart, thetaLength) {
    THREE.BufferGeometry.call(this);
    this.type = 'CircleBufferGeometry';
    this.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    radius = radius || 50;
    segments = segments !== undefined ? Math.max(3, segments) : 8;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    var vertices = segments + 2;
    var positions = new Float32Array(vertices * 3);
    var normals = new Float32Array(vertices * 3);
    var uvs = new Float32Array(vertices * 2);
    normals[2] = 1.0;
    uvs[0] = 0.5;
    uvs[1] = 0.5;
    for (var s = 0,
        i = 3,
        ii = 2; s <= segments; s++, i += 3, ii += 2) {
      var segment = thetaStart + s / segments * thetaLength;
      positions[i] = radius * Math.cos(segment);
      positions[i + 1] = radius * Math.sin(segment);
      normals[i + 2] = 1;
      uvs[ii] = (positions[i] / radius + 1) / 2;
      uvs[ii + 1] = (positions[i + 1] / radius + 1) / 2;
    }
    var indices = [];
    for (var i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    }
    this.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));
    this.addAttribute('position', new THREE.BufferAttribute(positions, 3));
    this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
    this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
  };
  THREE.CircleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
  THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;
  THREE.CircleBufferGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.CircleBufferGeometry(parameters.radius, parameters.segments, parameters.thetaStart, parameters.thetaLength);
  };
  THREE.CylinderGeometry = function(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    THREE.Geometry.call(this);
    this.type = 'CylinderGeometry';
    this.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    radiusTop = radiusTop !== undefined ? radiusTop : 20;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
    height = height !== undefined ? height : 100;
    radialSegments = radialSegments || 8;
    heightSegments = heightSegments || 1;
    openEnded = openEnded !== undefined ? openEnded : false;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
    var heightHalf = height / 2;
    var x,
        y,
        vertices = [],
        uvs = [];
    for (y = 0; y <= heightSegments; y++) {
      var verticesRow = [];
      var uvsRow = [];
      var v = y / heightSegments;
      var radius = v * (radiusBottom - radiusTop) + radiusTop;
      for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        var vertex = new THREE.Vector3();
        vertex.x = radius * Math.sin(u * thetaLength + thetaStart);
        vertex.y = -v * height + heightHalf;
        vertex.z = radius * Math.cos(u * thetaLength + thetaStart);
        this.vertices.push(vertex);
        verticesRow.push(this.vertices.length - 1);
        uvsRow.push(new THREE.Vector2(u, 1 - v));
      }
      vertices.push(verticesRow);
      uvs.push(uvsRow);
    }
    var tanTheta = (radiusBottom - radiusTop) / height;
    var na,
        nb;
    for (x = 0; x < radialSegments; x++) {
      if (radiusTop !== 0) {
        na = this.vertices[vertices[0][x]].clone();
        nb = this.vertices[vertices[0][x + 1]].clone();
      } else {
        na = this.vertices[vertices[1][x]].clone();
        nb = this.vertices[vertices[1][x + 1]].clone();
      }
      na.setY(Math.sqrt(na.x * na.x + na.z * na.z) * tanTheta).normalize();
      nb.setY(Math.sqrt(nb.x * nb.x + nb.z * nb.z) * tanTheta).normalize();
      for (y = 0; y < heightSegments; y++) {
        var v1 = vertices[y][x];
        var v2 = vertices[y + 1][x];
        var v3 = vertices[y + 1][x + 1];
        var v4 = vertices[y][x + 1];
        var n1 = na.clone();
        var n2 = na.clone();
        var n3 = nb.clone();
        var n4 = nb.clone();
        var uv1 = uvs[y][x].clone();
        var uv2 = uvs[y + 1][x].clone();
        var uv3 = uvs[y + 1][x + 1].clone();
        var uv4 = uvs[y][x + 1].clone();
        this.faces.push(new THREE.Face3(v1, v2, v4, [n1, n2, n4]));
        this.faceVertexUvs[0].push([uv1, uv2, uv4]);
        this.faces.push(new THREE.Face3(v2, v3, v4, [n2.clone(), n3, n4.clone()]));
        this.faceVertexUvs[0].push([uv2.clone(), uv3, uv4.clone()]);
      }
    }
    if (openEnded === false && radiusTop > 0) {
      this.vertices.push(new THREE.Vector3(0, heightHalf, 0));
      for (x = 0; x < radialSegments; x++) {
        var v1 = vertices[0][x];
        var v2 = vertices[0][x + 1];
        var v3 = this.vertices.length - 1;
        var n1 = new THREE.Vector3(0, 1, 0);
        var n2 = new THREE.Vector3(0, 1, 0);
        var n3 = new THREE.Vector3(0, 1, 0);
        var uv1 = uvs[0][x].clone();
        var uv2 = uvs[0][x + 1].clone();
        var uv3 = new THREE.Vector2(uv2.x, 0);
        this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3], undefined, 1));
        this.faceVertexUvs[0].push([uv1, uv2, uv3]);
      }
    }
    if (openEnded === false && radiusBottom > 0) {
      this.vertices.push(new THREE.Vector3(0, -heightHalf, 0));
      for (x = 0; x < radialSegments; x++) {
        var v1 = vertices[heightSegments][x + 1];
        var v2 = vertices[heightSegments][x];
        var v3 = this.vertices.length - 1;
        var n1 = new THREE.Vector3(0, -1, 0);
        var n2 = new THREE.Vector3(0, -1, 0);
        var n3 = new THREE.Vector3(0, -1, 0);
        var uv1 = uvs[heightSegments][x + 1].clone();
        var uv2 = uvs[heightSegments][x].clone();
        var uv3 = new THREE.Vector2(uv2.x, 1);
        this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3], undefined, 2));
        this.faceVertexUvs[0].push([uv1, uv2, uv3]);
      }
    }
    this.computeFaceNormals();
  };
  THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
  THREE.CylinderGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.CylinderGeometry(parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded, parameters.thetaStart, parameters.thetaLength);
  };
  THREE.EdgesGeometry = function(geometry, thresholdAngle) {
    THREE.BufferGeometry.call(this);
    thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;
    var thresholdDot = Math.cos(THREE.Math.degToRad(thresholdAngle));
    var edge = [0, 0],
        hash = {};
    function sortFunction(a, b) {
      return a - b;
    }
    var keys = ['a', 'b', 'c'];
    var geometry2;
    if (geometry instanceof THREE.BufferGeometry) {
      geometry2 = new THREE.Geometry();
      geometry2.fromBufferGeometry(geometry);
    } else {
      geometry2 = geometry.clone();
    }
    geometry2.mergeVertices();
    geometry2.computeFaceNormals();
    var vertices = geometry2.vertices;
    var faces = geometry2.faces;
    for (var i = 0,
        l = faces.length; i < l; i++) {
      var face = faces[i];
      for (var j = 0; j < 3; j++) {
        edge[0] = face[keys[j]];
        edge[1] = face[keys[(j + 1) % 3]];
        edge.sort(sortFunction);
        var key = edge.toString();
        if (hash[key] === undefined) {
          hash[key] = {
            vert1: edge[0],
            vert2: edge[1],
            face1: i,
            face2: undefined
          };
        } else {
          hash[key].face2 = i;
        }
      }
    }
    var coords = [];
    for (var key in hash) {
      var h = hash[key];
      if (h.face2 === undefined || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
        var vertex = vertices[h.vert1];
        coords.push(vertex.x);
        coords.push(vertex.y);
        coords.push(vertex.z);
        vertex = vertices[h.vert2];
        coords.push(vertex.x);
        coords.push(vertex.y);
        coords.push(vertex.z);
      }
    }
    this.addAttribute('position', new THREE.BufferAttribute(new Float32Array(coords), 3));
  };
  THREE.EdgesGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
  THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;
  THREE.ExtrudeGeometry = function(shapes, options) {
    if (typeof(shapes) === "undefined") {
      shapes = [];
      return;
    }
    THREE.Geometry.call(this);
    this.type = 'ExtrudeGeometry';
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    this.addShapeList(shapes, options);
    this.computeFaceNormals();
  };
  THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
  THREE.ExtrudeGeometry.prototype.addShapeList = function(shapes, options) {
    var sl = shapes.length;
    for (var s = 0; s < sl; s++) {
      var shape = shapes[s];
      this.addShape(shape, options);
    }
  };
  THREE.ExtrudeGeometry.prototype.addShape = function(shape, options) {
    var amount = options.amount !== undefined ? options.amount : 100;
    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
    var steps = options.steps !== undefined ? options.steps : 1;
    var extrudePath = options.extrudePath;
    var extrudePts,
        extrudeByPath = false;
    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
    var splineTube,
        binormal,
        normal,
        position2;
    if (extrudePath) {
      extrudePts = extrudePath.getSpacedPoints(steps);
      extrudeByPath = true;
      bevelEnabled = false;
      splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);
      binormal = new THREE.Vector3();
      normal = new THREE.Vector3();
      position2 = new THREE.Vector3();
    }
    if (!bevelEnabled) {
      bevelSegments = 0;
      bevelThickness = 0;
      bevelSize = 0;
    }
    var ahole,
        h,
        hl;
    var scope = this;
    var shapesOffset = this.vertices.length;
    var shapePoints = shape.extractPoints(curveSegments);
    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;
    var reverse = !THREE.ShapeUtils.isClockWise(vertices);
    if (reverse) {
      vertices = vertices.reverse();
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        if (THREE.ShapeUtils.isClockWise(ahole)) {
          holes[h] = ahole.reverse();
        }
      }
      reverse = false;
    }
    var faces = THREE.ShapeUtils.triangulateShape(vertices, holes);
    var contour = vertices;
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      vertices = vertices.concat(ahole);
    }
    function scalePt2(pt, vec, size) {
      if (!vec)
        console.error("THREE.ExtrudeGeometry: vec does not exist");
      return vec.clone().multiplyScalar(size).add(pt);
    }
    var b,
        bs,
        t,
        z,
        vert,
        vlen = vertices.length,
        face,
        flen = faces.length;
    function getBevelVec(inPt, inPrev, inNext) {
      var v_trans_x,
          v_trans_y,
          shrink_by = 1;
      var v_prev_x = inPt.x - inPrev.x,
          v_prev_y = inPt.y - inPrev.y;
      var v_next_x = inNext.x - inPt.x,
          v_next_y = inNext.y - inPt.y;
      var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
      var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
      if (Math.abs(collinear0) > Number.EPSILON) {
        var v_prev_len = Math.sqrt(v_prev_lensq);
        var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
        var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
        var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
        var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
        var ptNextShift_y = (inNext.y + v_next_x / v_next_len);
        var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
        v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
        v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
        var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
        if (v_trans_lensq <= 2) {
          return new THREE.Vector2(v_trans_x, v_trans_y);
        } else {
          shrink_by = Math.sqrt(v_trans_lensq / 2);
        }
      } else {
        var direction_eq = false;
        if (v_prev_x > Number.EPSILON) {
          if (v_next_x > Number.EPSILON) {
            direction_eq = true;
          }
        } else {
          if (v_prev_x < -Number.EPSILON) {
            if (v_next_x < -Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
              direction_eq = true;
            }
          }
        }
        if (direction_eq) {
          v_trans_x = -v_prev_y;
          v_trans_y = v_prev_x;
          shrink_by = Math.sqrt(v_prev_lensq);
        } else {
          v_trans_x = v_prev_x;
          v_trans_y = v_prev_y;
          shrink_by = Math.sqrt(v_prev_lensq / 2);
        }
      }
      return new THREE.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
    }
    var contourMovements = [];
    for (var i = 0,
        il = contour.length,
        j = il - 1,
        k = i + 1; i < il; i++, j++, k++) {
      if (j === il)
        j = 0;
      if (k === il)
        k = 0;
      contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
    }
    var holesMovements = [],
        oneHoleMovements,
        verticesMovements = contourMovements.concat();
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      oneHoleMovements = [];
      for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il)
          j = 0;
        if (k === il)
          k = 0;
        oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
      }
      holesMovements.push(oneHoleMovements);
      verticesMovements = verticesMovements.concat(oneHoleMovements);
    }
    for (b = 0; b < bevelSegments; b++) {
      t = b / bevelSegments;
      z = bevelThickness * (1 - t);
      bs = bevelSize * (Math.sin(t * Math.PI / 2));
      for (i = 0, il = contour.length; i < il; i++) {
        vert = scalePt2(contour[i], contourMovements[i], bs);
        v(vert.x, vert.y, -z);
      }
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = holesMovements[h];
        for (i = 0, il = ahole.length; i < il; i++) {
          vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
          v(vert.x, vert.y, -z);
        }
      }
    }
    bs = bevelSize;
    for (i = 0; i < vlen; i++) {
      vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
      if (!extrudeByPath) {
        v(vert.x, vert.y, 0);
      } else {
        normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
        position2.copy(extrudePts[0]).add(normal).add(binormal);
        v(position2.x, position2.y, position2.z);
      }
    }
    var s;
    for (s = 1; s <= steps; s++) {
      for (i = 0; i < vlen; i++) {
        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, amount / steps * s);
        } else {
          normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
          position2.copy(extrudePts[s]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
    }
    for (b = bevelSegments - 1; b >= 0; b--) {
      t = b / bevelSegments;
      z = bevelThickness * (1 - t);
      bs = bevelSize * Math.sin(t * Math.PI / 2);
      for (i = 0, il = contour.length; i < il; i++) {
        vert = scalePt2(contour[i], contourMovements[i], bs);
        v(vert.x, vert.y, amount + z);
      }
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = holesMovements[h];
        for (i = 0, il = ahole.length; i < il; i++) {
          vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
          if (!extrudeByPath) {
            v(vert.x, vert.y, amount + z);
          } else {
            v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
          }
        }
      }
    }
    buildLidFaces();
    buildSideFaces();
    function buildLidFaces() {
      if (bevelEnabled) {
        var layer = 0;
        var offset = vlen * layer;
        for (i = 0; i < flen; i++) {
          face = faces[i];
          f3(face[2] + offset, face[1] + offset, face[0] + offset);
        }
        layer = steps + bevelSegments * 2;
        offset = vlen * layer;
        for (i = 0; i < flen; i++) {
          face = faces[i];
          f3(face[0] + offset, face[1] + offset, face[2] + offset);
        }
      } else {
        for (i = 0; i < flen; i++) {
          face = faces[i];
          f3(face[2], face[1], face[0]);
        }
        for (i = 0; i < flen; i++) {
          face = faces[i];
          f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
        }
      }
    }
    function buildSideFaces() {
      var layeroffset = 0;
      sidewalls(contour, layeroffset);
      layeroffset += contour.length;
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        sidewalls(ahole, layeroffset);
        layeroffset += ahole.length;
      }
    }
    function sidewalls(contour, layeroffset) {
      var j,
          k;
      i = contour.length;
      while (--i >= 0) {
        j = i;
        k = i - 1;
        if (k < 0)
          k = contour.length - 1;
        var s = 0,
            sl = steps + bevelSegments * 2;
        for (s = 0; s < sl; s++) {
          var slen1 = vlen * s;
          var slen2 = vlen * (s + 1);
          var a = layeroffset + j + slen1,
              b = layeroffset + k + slen1,
              c = layeroffset + k + slen2,
              d = layeroffset + j + slen2;
          f4(a, b, c, d, contour, s, sl, j, k);
        }
      }
    }
    function v(x, y, z) {
      scope.vertices.push(new THREE.Vector3(x, y, z));
    }
    function f3(a, b, c) {
      a += shapesOffset;
      b += shapesOffset;
      c += shapesOffset;
      scope.faces.push(new THREE.Face3(a, b, c, null, null, 0));
      var uvs = uvgen.generateTopUV(scope, a, b, c);
      scope.faceVertexUvs[0].push(uvs);
    }
    function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
      a += shapesOffset;
      b += shapesOffset;
      c += shapesOffset;
      d += shapesOffset;
      scope.faces.push(new THREE.Face3(a, b, d, null, null, 1));
      scope.faces.push(new THREE.Face3(b, c, d, null, null, 1));
      var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
      scope.faceVertexUvs[0].push([uvs[0], uvs[1], uvs[3]]);
      scope.faceVertexUvs[0].push([uvs[1], uvs[2], uvs[3]]);
    }
  };
  THREE.ExtrudeGeometry.WorldUVGenerator = {
    generateTopUV: function(geometry, indexA, indexB, indexC) {
      var vertices = geometry.vertices;
      var a = vertices[indexA];
      var b = vertices[indexB];
      var c = vertices[indexC];
      return [new THREE.Vector2(a.x, a.y), new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y)];
    },
    generateSideWallUV: function(geometry, indexA, indexB, indexC, indexD) {
      var vertices = geometry.vertices;
      var a = vertices[indexA];
      var b = vertices[indexB];
      var c = vertices[indexC];
      var d = vertices[indexD];
      if (Math.abs(a.y - b.y) < 0.01) {
        return [new THREE.Vector2(a.x, 1 - a.z), new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z)];
      } else {
        return [new THREE.Vector2(a.y, 1 - a.z), new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y, 1 - d.z)];
      }
    }
  };
  THREE.ShapeGeometry = function(shapes, options) {
    THREE.Geometry.call(this);
    this.type = 'ShapeGeometry';
    if (Array.isArray(shapes) === false)
      shapes = [shapes];
    this.addShapeList(shapes, options);
    this.computeFaceNormals();
  };
  THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
  THREE.ShapeGeometry.prototype.addShapeList = function(shapes, options) {
    for (var i = 0,
        l = shapes.length; i < l; i++) {
      this.addShape(shapes[i], options);
    }
    return this;
  };
  THREE.ShapeGeometry.prototype.addShape = function(shape, options) {
    if (options === undefined)
      options = {};
    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
    var material = options.material;
    var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
    var i,
        l,
        hole;
    var shapesOffset = this.vertices.length;
    var shapePoints = shape.extractPoints(curveSegments);
    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;
    var reverse = !THREE.ShapeUtils.isClockWise(vertices);
    if (reverse) {
      vertices = vertices.reverse();
      for (i = 0, l = holes.length; i < l; i++) {
        hole = holes[i];
        if (THREE.ShapeUtils.isClockWise(hole)) {
          holes[i] = hole.reverse();
        }
      }
      reverse = false;
    }
    var faces = THREE.ShapeUtils.triangulateShape(vertices, holes);
    for (i = 0, l = holes.length; i < l; i++) {
      hole = holes[i];
      vertices = vertices.concat(hole);
    }
    var vert,
        vlen = vertices.length;
    var face,
        flen = faces.length;
    for (i = 0; i < vlen; i++) {
      vert = vertices[i];
      this.vertices.push(new THREE.Vector3(vert.x, vert.y, 0));
    }
    for (i = 0; i < flen; i++) {
      face = faces[i];
      var a = face[0] + shapesOffset;
      var b = face[1] + shapesOffset;
      var c = face[2] + shapesOffset;
      this.faces.push(new THREE.Face3(a, b, c, null, null, material));
      this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
    }
  };
  THREE.LatheGeometry = function(points, segments, phiStart, phiLength) {
    THREE.Geometry.call(this);
    this.type = 'LatheGeometry';
    this.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };
    segments = segments || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || 2 * Math.PI;
    var inversePointLength = 1.0 / (points.length - 1);
    var inverseSegments = 1.0 / segments;
    for (var i = 0,
        il = segments; i <= il; i++) {
      var phi = phiStart + i * inverseSegments * phiLength;
      var c = Math.cos(phi),
          s = Math.sin(phi);
      for (var j = 0,
          jl = points.length; j < jl; j++) {
        var pt = points[j];
        var vertex = new THREE.Vector3();
        vertex.x = c * pt.x - s * pt.y;
        vertex.y = s * pt.x + c * pt.y;
        vertex.z = pt.z;
        this.vertices.push(vertex);
      }
    }
    var np = points.length;
    for (var i = 0,
        il = segments; i < il; i++) {
      for (var j = 0,
          jl = points.length - 1; j < jl; j++) {
        var base = j + np * i;
        var a = base;
        var b = base + np;
        var c = base + 1 + np;
        var d = base + 1;
        var u0 = i * inverseSegments;
        var v0 = j * inversePointLength;
        var u1 = u0 + inverseSegments;
        var v1 = v0 + inversePointLength;
        this.faces.push(new THREE.Face3(a, b, d));
        this.faceVertexUvs[0].push([new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1)]);
        this.faces.push(new THREE.Face3(b, c, d));
        this.faceVertexUvs[0].push([new THREE.Vector2(u1, v0), new THREE.Vector2(u1, v1), new THREE.Vector2(u0, v1)]);
      }
    }
    this.mergeVertices();
    this.computeFaceNormals();
    this.computeVertexNormals();
  };
  THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
  THREE.PlaneGeometry = function(width, height, widthSegments, heightSegments) {
    THREE.Geometry.call(this);
    this.type = 'PlaneGeometry';
    this.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };
    this.fromBufferGeometry(new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments));
  };
  THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
  THREE.PlaneGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.PlaneGeometry(parameters.width, parameters.height, parameters.widthSegments, parameters.heightSegments);
  };
  THREE.PlaneBufferGeometry = function(width, height, widthSegments, heightSegments) {
    THREE.BufferGeometry.call(this);
    this.type = 'PlaneBufferGeometry';
    this.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };
    var width_half = width / 2;
    var height_half = height / 2;
    var gridX = Math.floor(widthSegments) || 1;
    var gridY = Math.floor(heightSegments) || 1;
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var segment_width = width / gridX;
    var segment_height = height / gridY;
    var vertices = new Float32Array(gridX1 * gridY1 * 3);
    var normals = new Float32Array(gridX1 * gridY1 * 3);
    var uvs = new Float32Array(gridX1 * gridY1 * 2);
    var offset = 0;
    var offset2 = 0;
    for (var iy = 0; iy < gridY1; iy++) {
      var y = iy * segment_height - height_half;
      for (var ix = 0; ix < gridX1; ix++) {
        var x = ix * segment_width - width_half;
        vertices[offset] = x;
        vertices[offset + 1] = -y;
        normals[offset + 2] = 1;
        uvs[offset2] = ix / gridX;
        uvs[offset2 + 1] = 1 - (iy / gridY);
        offset += 3;
        offset2 += 2;
      }
    }
    offset = 0;
    var indices = new ((vertices.length / 3) > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);
    for (var iy = 0; iy < gridY; iy++) {
      for (var ix = 0; ix < gridX; ix++) {
        var a = ix + gridX1 * iy;
        var b = ix + gridX1 * (iy + 1);
        var c = (ix + 1) + gridX1 * (iy + 1);
        var d = (ix + 1) + gridX1 * iy;
        indices[offset] = a;
        indices[offset + 1] = b;
        indices[offset + 2] = d;
        indices[offset + 3] = b;
        indices[offset + 4] = c;
        indices[offset + 5] = d;
        offset += 6;
      }
    }
    this.setIndex(new THREE.BufferAttribute(indices, 1));
    this.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
    this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
    this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
  };
  THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
  THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
  THREE.PlaneBufferGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.PlaneBufferGeometry(parameters.width, parameters.height, parameters.widthSegments, parameters.heightSegments);
  };
  THREE.RingGeometry = function(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    THREE.Geometry.call(this);
    this.type = 'RingGeometry';
    this.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    innerRadius = innerRadius || 0;
    outerRadius = outerRadius || 50;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
    phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 8;
    var i,
        o,
        uvs = [],
        radius = innerRadius,
        radiusStep = ((outerRadius - innerRadius) / phiSegments);
    for (i = 0; i < phiSegments + 1; i++) {
      for (o = 0; o < thetaSegments + 1; o++) {
        var vertex = new THREE.Vector3();
        var segment = thetaStart + o / thetaSegments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        this.vertices.push(vertex);
        uvs.push(new THREE.Vector2((vertex.x / outerRadius + 1) / 2, (vertex.y / outerRadius + 1) / 2));
      }
      radius += radiusStep;
    }
    var n = new THREE.Vector3(0, 0, 1);
    for (i = 0; i < phiSegments; i++) {
      var thetaSegment = i * (thetaSegments + 1);
      for (o = 0; o < thetaSegments; o++) {
        var segment = o + thetaSegment;
        var v1 = segment;
        var v2 = segment + thetaSegments + 1;
        var v3 = segment + thetaSegments + 2;
        this.faces.push(new THREE.Face3(v1, v2, v3, [n.clone(), n.clone(), n.clone()]));
        this.faceVertexUvs[0].push([uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone()]);
        v1 = segment;
        v2 = segment + thetaSegments + 2;
        v3 = segment + 1;
        this.faces.push(new THREE.Face3(v1, v2, v3, [n.clone(), n.clone(), n.clone()]));
        this.faceVertexUvs[0].push([uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone()]);
      }
    }
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
  };
  THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
  THREE.RingGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.RingGeometry(parameters.innerRadius, parameters.outerRadius, parameters.thetaSegments, parameters.phiSegments, parameters.thetaStart, parameters.thetaLength);
  };
  THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    THREE.Geometry.call(this);
    this.type = 'SphereGeometry';
    this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    this.fromBufferGeometry(new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
  };
  THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
  THREE.SphereGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.SphereGeometry(parameters.radius, parameters.widthSegments, parameters.heightSegments, parameters.phiStart, parameters.phiLength, parameters.thetaStart, parameters.thetaLength);
  };
  THREE.SphereBufferGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    THREE.BufferGeometry.call(this);
    this.type = 'SphereBufferGeometry';
    this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    radius = radius || 50;
    widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
    heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
    var thetaEnd = thetaStart + thetaLength;
    var vertexCount = ((widthSegments + 1) * (heightSegments + 1));
    var positions = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
    var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
    var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);
    var index = 0,
        vertices = [],
        normal = new THREE.Vector3();
    for (var y = 0; y <= heightSegments; y++) {
      var verticesRow = [];
      var v = y / heightSegments;
      for (var x = 0; x <= widthSegments; x++) {
        var u = x / widthSegments;
        var px = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        var py = radius * Math.cos(thetaStart + v * thetaLength);
        var pz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        normal.set(px, py, pz).normalize();
        positions.setXYZ(index, px, py, pz);
        normals.setXYZ(index, normal.x, normal.y, normal.z);
        uvs.setXY(index, u, 1 - v);
        verticesRow.push(index);
        index++;
      }
      vertices.push(verticesRow);
    }
    var indices = [];
    for (var y = 0; y < heightSegments; y++) {
      for (var x = 0; x < widthSegments; x++) {
        var v1 = vertices[y][x + 1];
        var v2 = vertices[y][x];
        var v3 = vertices[y + 1][x];
        var v4 = vertices[y + 1][x + 1];
        if (y !== 0 || thetaStart > 0)
          indices.push(v1, v2, v4);
        if (y !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(v2, v3, v4);
      }
    }
    this.setIndex(new (positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute)(indices, 1));
    this.addAttribute('position', positions);
    this.addAttribute('normal', normals);
    this.addAttribute('uv', uvs);
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
  };
  THREE.SphereBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
  THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;
  THREE.SphereBufferGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.SphereBufferGeometry(parameters.radius, parameters.widthSegments, parameters.heightSegments, parameters.phiStart, parameters.phiLength, parameters.thetaStart, parameters.thetaLength);
  };
  THREE.TorusGeometry = function(radius, tube, radialSegments, tubularSegments, arc) {
    THREE.Geometry.call(this);
    this.type = 'TorusGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };
    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 8;
    tubularSegments = tubularSegments || 6;
    arc = arc || Math.PI * 2;
    var center = new THREE.Vector3(),
        uvs = [],
        normals = [];
    for (var j = 0; j <= radialSegments; j++) {
      for (var i = 0; i <= tubularSegments; i++) {
        var u = i / tubularSegments * arc;
        var v = j / radialSegments * Math.PI * 2;
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        var vertex = new THREE.Vector3();
        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        this.vertices.push(vertex);
        uvs.push(new THREE.Vector2(i / tubularSegments, j / radialSegments));
        normals.push(vertex.clone().sub(center).normalize());
      }
    }
    for (var j = 1; j <= radialSegments; j++) {
      for (var i = 1; i <= tubularSegments; i++) {
        var a = (tubularSegments + 1) * j + i - 1;
        var b = (tubularSegments + 1) * (j - 1) + i - 1;
        var c = (tubularSegments + 1) * (j - 1) + i;
        var d = (tubularSegments + 1) * j + i;
        var face = new THREE.Face3(a, b, d, [normals[a].clone(), normals[b].clone(), normals[d].clone()]);
        this.faces.push(face);
        this.faceVertexUvs[0].push([uvs[a].clone(), uvs[b].clone(), uvs[d].clone()]);
        face = new THREE.Face3(b, c, d, [normals[b].clone(), normals[c].clone(), normals[d].clone()]);
        this.faces.push(face);
        this.faceVertexUvs[0].push([uvs[b].clone(), uvs[c].clone(), uvs[d].clone()]);
      }
    }
    this.computeFaceNormals();
  };
  THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
  THREE.TorusGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.TorusGeometry(parameters.radius, parameters.tube, parameters.radialSegments, parameters.tubularSegments, parameters.arc);
  };
  THREE.TorusKnotGeometry = function(radius, tube, radialSegments, tubularSegments, p, q, heightScale) {
    THREE.Geometry.call(this);
    this.type = 'TorusKnotGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      p: p,
      q: q,
      heightScale: heightScale
    };
    radius = radius || 100;
    tube = tube || 40;
    radialSegments = radialSegments || 64;
    tubularSegments = tubularSegments || 8;
    p = p || 2;
    q = q || 3;
    heightScale = heightScale || 1;
    var grid = new Array(radialSegments);
    var tang = new THREE.Vector3();
    var n = new THREE.Vector3();
    var bitan = new THREE.Vector3();
    for (var i = 0; i < radialSegments; ++i) {
      grid[i] = new Array(tubularSegments);
      var u = i / radialSegments * 2 * p * Math.PI;
      var p1 = getPos(u, q, p, radius, heightScale);
      var p2 = getPos(u + 0.01, q, p, radius, heightScale);
      tang.subVectors(p2, p1);
      n.addVectors(p2, p1);
      bitan.crossVectors(tang, n);
      n.crossVectors(bitan, tang);
      bitan.normalize();
      n.normalize();
      for (var j = 0; j < tubularSegments; ++j) {
        var v = j / tubularSegments * 2 * Math.PI;
        var cx = -tube * Math.cos(v);
        var cy = tube * Math.sin(v);
        var pos = new THREE.Vector3();
        pos.x = p1.x + cx * n.x + cy * bitan.x;
        pos.y = p1.y + cx * n.y + cy * bitan.y;
        pos.z = p1.z + cx * n.z + cy * bitan.z;
        grid[i][j] = this.vertices.push(pos) - 1;
      }
    }
    for (var i = 0; i < radialSegments; ++i) {
      for (var j = 0; j < tubularSegments; ++j) {
        var ip = (i + 1) % radialSegments;
        var jp = (j + 1) % tubularSegments;
        var a = grid[i][j];
        var b = grid[ip][j];
        var c = grid[ip][jp];
        var d = grid[i][jp];
        var uva = new THREE.Vector2(i / radialSegments, j / tubularSegments);
        var uvb = new THREE.Vector2((i + 1) / radialSegments, j / tubularSegments);
        var uvc = new THREE.Vector2((i + 1) / radialSegments, (j + 1) / tubularSegments);
        var uvd = new THREE.Vector2(i / radialSegments, (j + 1) / tubularSegments);
        this.faces.push(new THREE.Face3(a, b, d));
        this.faceVertexUvs[0].push([uva, uvb, uvd]);
        this.faces.push(new THREE.Face3(b, c, d));
        this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
      }
    }
    this.computeFaceNormals();
    this.computeVertexNormals();
    function getPos(u, in_q, in_p, radius, heightScale) {
      var cu = Math.cos(u);
      var su = Math.sin(u);
      var quOverP = in_q / in_p * u;
      var cs = Math.cos(quOverP);
      var tx = radius * (2 + cs) * 0.5 * cu;
      var ty = radius * (2 + cs) * su * 0.5;
      var tz = heightScale * radius * Math.sin(quOverP) * 0.5;
      return new THREE.Vector3(tx, ty, tz);
    }
  };
  THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
  THREE.TorusKnotGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.TorusKnotGeometry(parameters.radius, parameters.tube, parameters.radialSegments, parameters.tubularSegments, parameters.p, parameters.q, parameters.heightScale);
  };
  THREE.TubeGeometry = function(path, segments, radius, radialSegments, closed, taper) {
    THREE.Geometry.call(this);
    this.type = 'TubeGeometry';
    this.parameters = {
      path: path,
      segments: segments,
      radius: radius,
      radialSegments: radialSegments,
      closed: closed,
      taper: taper
    };
    segments = segments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;
    taper = taper || THREE.TubeGeometry.NoTaper;
    var grid = [];
    var scope = this,
        tangent,
        normal,
        binormal,
        numpoints = segments + 1,
        u,
        v,
        r,
        cx,
        cy,
        pos,
        pos2 = new THREE.Vector3(),
        i,
        j,
        ip,
        jp,
        a,
        b,
        c,
        d,
        uva,
        uvb,
        uvc,
        uvd;
    var frames = new THREE.TubeGeometry.FrenetFrames(path, segments, closed),
        tangents = frames.tangents,
        normals = frames.normals,
        binormals = frames.binormals;
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;
    function vert(x, y, z) {
      return scope.vertices.push(new THREE.Vector3(x, y, z)) - 1;
    }
    for (i = 0; i < numpoints; i++) {
      grid[i] = [];
      u = i / (numpoints - 1);
      pos = path.getPointAt(u);
      tangent = tangents[i];
      normal = normals[i];
      binormal = binormals[i];
      r = radius * taper(u);
      for (j = 0; j < radialSegments; j++) {
        v = j / radialSegments * 2 * Math.PI;
        cx = -r * Math.cos(v);
        cy = r * Math.sin(v);
        pos2.copy(pos);
        pos2.x += cx * normal.x + cy * binormal.x;
        pos2.y += cx * normal.y + cy * binormal.y;
        pos2.z += cx * normal.z + cy * binormal.z;
        grid[i][j] = vert(pos2.x, pos2.y, pos2.z);
      }
    }
    for (i = 0; i < segments; i++) {
      for (j = 0; j < radialSegments; j++) {
        ip = (closed) ? (i + 1) % segments : i + 1;
        jp = (j + 1) % radialSegments;
        a = grid[i][j];
        b = grid[ip][j];
        c = grid[ip][jp];
        d = grid[i][jp];
        uva = new THREE.Vector2(i / segments, j / radialSegments);
        uvb = new THREE.Vector2((i + 1) / segments, j / radialSegments);
        uvc = new THREE.Vector2((i + 1) / segments, (j + 1) / radialSegments);
        uvd = new THREE.Vector2(i / segments, (j + 1) / radialSegments);
        this.faces.push(new THREE.Face3(a, b, d));
        this.faceVertexUvs[0].push([uva, uvb, uvd]);
        this.faces.push(new THREE.Face3(b, c, d));
        this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
      }
    }
    this.computeFaceNormals();
    this.computeVertexNormals();
  };
  THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
  THREE.TubeGeometry.prototype.clone = function() {
    return new this.constructor(this.parameters.path, this.parameters.segments, this.parameters.radius, this.parameters.radialSegments, this.parameters.closed, this.parameters.taper);
  };
  THREE.TubeGeometry.NoTaper = function(u) {
    return 1;
  };
  THREE.TubeGeometry.SinusoidalTaper = function(u) {
    return Math.sin(Math.PI * u);
  };
  THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {
    var normal = new THREE.Vector3(),
        tangents = [],
        normals = [],
        binormals = [],
        vec = new THREE.Vector3(),
        mat = new THREE.Matrix4(),
        numpoints = segments + 1,
        theta,
        smallest,
        tx,
        ty,
        tz,
        i,
        u;
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;
    for (i = 0; i < numpoints; i++) {
      u = i / (numpoints - 1);
      tangents[i] = path.getTangentAt(u);
      tangents[i].normalize();
    }
    initialNormal3();
    function initialNormal3() {
      normals[0] = new THREE.Vector3();
      binormals[0] = new THREE.Vector3();
      smallest = Number.MAX_VALUE;
      tx = Math.abs(tangents[0].x);
      ty = Math.abs(tangents[0].y);
      tz = Math.abs(tangents[0].z);
      if (tx <= smallest) {
        smallest = tx;
        normal.set(1, 0, 0);
      }
      if (ty <= smallest) {
        smallest = ty;
        normal.set(0, 1, 0);
      }
      if (tz <= smallest) {
        normal.set(0, 0, 1);
      }
      vec.crossVectors(tangents[0], normal).normalize();
      normals[0].crossVectors(tangents[0], vec);
      binormals[0].crossVectors(tangents[0], normals[0]);
    }
    for (i = 1; i < numpoints; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        theta = Math.acos(THREE.Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed) {
      theta = Math.acos(THREE.Math.clamp(normals[0].dot(normals[numpoints - 1]), -1, 1));
      theta /= (numpoints - 1);
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) {
        theta = -theta;
      }
      for (i = 1; i < numpoints; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
  };
  THREE.PolyhedronGeometry = function(vertices, indices, radius, detail) {
    THREE.Geometry.call(this);
    this.type = 'PolyhedronGeometry';
    this.parameters = {
      vertices: vertices,
      indices: indices,
      radius: radius,
      detail: detail
    };
    radius = radius || 1;
    detail = detail || 0;
    var that = this;
    for (var i = 0,
        l = vertices.length; i < l; i += 3) {
      prepare(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
    }
    var p = this.vertices;
    var faces = [];
    for (var i = 0,
        j = 0,
        l = indices.length; i < l; i += 3, j++) {
      var v1 = p[indices[i]];
      var v2 = p[indices[i + 1]];
      var v3 = p[indices[i + 2]];
      faces[j] = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()], undefined, j);
    }
    var centroid = new THREE.Vector3();
    for (var i = 0,
        l = faces.length; i < l; i++) {
      subdivide(faces[i], detail);
    }
    for (var i = 0,
        l = this.faceVertexUvs[0].length; i < l; i++) {
      var uvs = this.faceVertexUvs[0][i];
      var x0 = uvs[0].x;
      var x1 = uvs[1].x;
      var x2 = uvs[2].x;
      var max = Math.max(x0, x1, x2);
      var min = Math.min(x0, x1, x2);
      if (max > 0.9 && min < 0.1) {
        if (x0 < 0.2)
          uvs[0].x += 1;
        if (x1 < 0.2)
          uvs[1].x += 1;
        if (x2 < 0.2)
          uvs[2].x += 1;
      }
    }
    for (var i = 0,
        l = this.vertices.length; i < l; i++) {
      this.vertices[i].multiplyScalar(radius);
    }
    this.mergeVertices();
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    function prepare(vector) {
      var vertex = vector.normalize().clone();
      vertex.index = that.vertices.push(vertex) - 1;
      var u = azimuth(vector) / 2 / Math.PI + 0.5;
      var v = inclination(vector) / Math.PI + 0.5;
      vertex.uv = new THREE.Vector2(u, 1 - v);
      return vertex;
    }
    function make(v1, v2, v3, materialIndex) {
      var face = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()], undefined, materialIndex);
      that.faces.push(face);
      centroid.copy(v1).add(v2).add(v3).divideScalar(3);
      var azi = azimuth(centroid);
      that.faceVertexUvs[0].push([correctUV(v1.uv, v1, azi), correctUV(v2.uv, v2, azi), correctUV(v3.uv, v3, azi)]);
    }
    function subdivide(face, detail) {
      var cols = Math.pow(2, detail);
      var a = prepare(that.vertices[face.a]);
      var b = prepare(that.vertices[face.b]);
      var c = prepare(that.vertices[face.c]);
      var v = [];
      var materialIndex = face.materialIndex;
      for (var i = 0; i <= cols; i++) {
        v[i] = [];
        var aj = prepare(a.clone().lerp(c, i / cols));
        var bj = prepare(b.clone().lerp(c, i / cols));
        var rows = cols - i;
        for (var j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = prepare(aj.clone().lerp(bj, j / rows));
          }
        }
      }
      for (var i = 0; i < cols; i++) {
        for (var j = 0; j < 2 * (cols - i) - 1; j++) {
          var k = Math.floor(j / 2);
          if (j % 2 === 0) {
            make(v[i][k + 1], v[i + 1][k], v[i][k], materialIndex);
          } else {
            make(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k], materialIndex);
          }
        }
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
    }
    function correctUV(uv, vector, azimuth) {
      if ((azimuth < 0) && (uv.x === 1))
        uv = new THREE.Vector2(uv.x - 1, uv.y);
      if ((vector.x === 0) && (vector.z === 0))
        uv = new THREE.Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);
      return uv.clone();
    }
  };
  THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
  THREE.PolyhedronGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.PolyhedronGeometry(parameters.vertices, parameters.indices, parameters.radius, parameters.detail);
  };
  THREE.DodecahedronGeometry = function(radius, detail) {
    var t = (1 + Math.sqrt(5)) / 2;
    var r = 1 / t;
    var vertices = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
    var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
    THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'DodecahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  };
  THREE.DodecahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
  THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
  THREE.DodecahedronGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.DodecahedronGeometry(parameters.radius, parameters.detail);
  };
  THREE.IcosahedronGeometry = function(radius, detail) {
    var t = (1 + Math.sqrt(5)) / 2;
    var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
    var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
    THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'IcosahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  };
  THREE.IcosahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
  THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
  THREE.IcosahedronGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.IcosahedronGeometry(parameters.radius, parameters.detail);
  };
  THREE.OctahedronGeometry = function(radius, detail) {
    var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
    var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'OctahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  };
  THREE.OctahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
  THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
  THREE.OctahedronGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.OctahedronGeometry(parameters.radius, parameters.detail);
  };
  THREE.TetrahedronGeometry = function(radius, detail) {
    var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
    var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'TetrahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  };
  THREE.TetrahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
  THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
  THREE.TetrahedronGeometry.prototype.clone = function() {
    var parameters = this.parameters;
    return new THREE.TetrahedronGeometry(parameters.radius, parameters.detail);
  };
  THREE.ParametricGeometry = function(func, slices, stacks) {
    THREE.Geometry.call(this);
    this.type = 'ParametricGeometry';
    this.parameters = {
      func: func,
      slices: slices,
      stacks: stacks
    };
    var verts = this.vertices;
    var faces = this.faces;
    var uvs = this.faceVertexUvs[0];
    var i,
        j,
        p;
    var u,
        v;
    var sliceCount = slices + 1;
    for (i = 0; i <= stacks; i++) {
      v = i / stacks;
      for (j = 0; j <= slices; j++) {
        u = j / slices;
        p = func(u, v);
        verts.push(p);
      }
    }
    var a,
        b,
        c,
        d;
    var uva,
        uvb,
        uvc,
        uvd;
    for (i = 0; i < stacks; i++) {
      for (j = 0; j < slices; j++) {
        a = i * sliceCount + j;
        b = i * sliceCount + j + 1;
        c = (i + 1) * sliceCount + j + 1;
        d = (i + 1) * sliceCount + j;
        uva = new THREE.Vector2(j / slices, i / stacks);
        uvb = new THREE.Vector2((j + 1) / slices, i / stacks);
        uvc = new THREE.Vector2((j + 1) / slices, (i + 1) / stacks);
        uvd = new THREE.Vector2(j / slices, (i + 1) / stacks);
        faces.push(new THREE.Face3(a, b, d));
        uvs.push([uva, uvb, uvd]);
        faces.push(new THREE.Face3(b, c, d));
        uvs.push([uvb.clone(), uvc, uvd.clone()]);
      }
    }
    this.computeFaceNormals();
    this.computeVertexNormals();
  };
  THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
  THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
  THREE.WireframeGeometry = function(geometry) {
    THREE.BufferGeometry.call(this);
    var edge = [0, 0],
        hash = {};
    function sortFunction(a, b) {
      return a - b;
    }
    var keys = ['a', 'b', 'c'];
    if (geometry instanceof THREE.Geometry) {
      var vertices = geometry.vertices;
      var faces = geometry.faces;
      var numEdges = 0;
      var edges = new Uint32Array(6 * faces.length);
      for (var i = 0,
          l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0; j < 3; j++) {
          edge[0] = face[keys[j]];
          edge[1] = face[keys[(j + 1) % 3]];
          edge.sort(sortFunction);
          var key = edge.toString();
          if (hash[key] === undefined) {
            edges[2 * numEdges] = edge[0];
            edges[2 * numEdges + 1] = edge[1];
            hash[key] = true;
            numEdges++;
          }
        }
      }
      var coords = new Float32Array(numEdges * 2 * 3);
      for (var i = 0,
          l = numEdges; i < l; i++) {
        for (var j = 0; j < 2; j++) {
          var vertex = vertices[edges[2 * i + j]];
          var index = 6 * i + 3 * j;
          coords[index + 0] = vertex.x;
          coords[index + 1] = vertex.y;
          coords[index + 2] = vertex.z;
        }
      }
      this.addAttribute('position', new THREE.BufferAttribute(coords, 3));
    } else if (geometry instanceof THREE.BufferGeometry) {
      if (geometry.index !== null) {
        var indices = geometry.index.array;
        var vertices = geometry.attributes.position;
        var drawcalls = geometry.drawcalls;
        var numEdges = 0;
        if (drawcalls.length === 0) {
          geometry.addGroup(0, indices.length);
        }
        var edges = new Uint32Array(2 * indices.length);
        for (var o = 0,
            ol = drawcalls.length; o < ol; ++o) {
          var drawcall = drawcalls[o];
          var start = drawcall.start;
          var count = drawcall.count;
          for (var i = start,
              il = start + count; i < il; i += 3) {
            for (var j = 0; j < 3; j++) {
              edge[0] = indices[i + j];
              edge[1] = indices[i + (j + 1) % 3];
              edge.sort(sortFunction);
              var key = edge.toString();
              if (hash[key] === undefined) {
                edges[2 * numEdges] = edge[0];
                edges[2 * numEdges + 1] = edge[1];
                hash[key] = true;
                numEdges++;
              }
            }
          }
        }
        var coords = new Float32Array(numEdges * 2 * 3);
        for (var i = 0,
            l = numEdges; i < l; i++) {
          for (var j = 0; j < 2; j++) {
            var index = 6 * i + 3 * j;
            var index2 = edges[2 * i + j];
            coords[index + 0] = vertices.getX(index2);
            coords[index + 1] = vertices.getY(index2);
            coords[index + 2] = vertices.getZ(index2);
          }
        }
        this.addAttribute('position', new THREE.BufferAttribute(coords, 3));
      } else {
        var vertices = geometry.attributes.position.array;
        var numEdges = vertices.length / 3;
        var numTris = numEdges / 3;
        var coords = new Float32Array(numEdges * 2 * 3);
        for (var i = 0,
            l = numTris; i < l; i++) {
          for (var j = 0; j < 3; j++) {
            var index = 18 * i + 6 * j;
            var index1 = 9 * i + 3 * j;
            coords[index + 0] = vertices[index1];
            coords[index + 1] = vertices[index1 + 1];
            coords[index + 2] = vertices[index1 + 2];
            var index2 = 9 * i + 3 * ((j + 1) % 3);
            coords[index + 3] = vertices[index2];
            coords[index + 4] = vertices[index2 + 1];
            coords[index + 5] = vertices[index2 + 2];
          }
        }
        this.addAttribute('position', new THREE.BufferAttribute(coords, 3));
      }
    }
  };
  THREE.WireframeGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
  THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;
  THREE.AxisHelper = function(size) {
    size = size || 1;
    var vertices = new Float32Array([0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size]);
    var colors = new Float32Array([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1]);
    var geometry = new THREE.BufferGeometry();
    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
    var material = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
    THREE.LineSegments.call(this, geometry, material);
  };
  THREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype);
  THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
  THREE.ArrowHelper = (function() {
    var lineGeometry = new THREE.Geometry();
    lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
    var coneGeometry = new THREE.CylinderGeometry(0, 0.5, 1, 5, 1);
    coneGeometry.translate(0, -0.5, 0);
    return function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
      THREE.Object3D.call(this);
      if (color === undefined)
        color = 0xffff00;
      if (length === undefined)
        length = 1;
      if (headLength === undefined)
        headLength = 0.2 * length;
      if (headWidth === undefined)
        headWidth = 0.2 * headLength;
      this.position.copy(origin);
      if (headLength < length) {
        this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({color: color}));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
      }
      this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({color: color}));
      this.cone.matrixAutoUpdate = false;
      this.add(this.cone);
      this.setDirection(dir);
      this.setLength(length, headLength, headWidth);
    };
  }());
  THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
  THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
  THREE.ArrowHelper.prototype.setDirection = (function() {
    var axis = new THREE.Vector3();
    var radians;
    return function setDirection(dir) {
      if (dir.y > 0.99999) {
        this.quaternion.set(0, 0, 0, 1);
      } else if (dir.y < -0.99999) {
        this.quaternion.set(1, 0, 0, 0);
      } else {
        axis.set(dir.z, 0, -dir.x).normalize();
        radians = Math.acos(dir.y);
        this.quaternion.setFromAxisAngle(axis, radians);
      }
    };
  }());
  THREE.ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
    if (headLength === undefined)
      headLength = 0.2 * length;
    if (headWidth === undefined)
      headWidth = 0.2 * headLength;
    if (headLength < length) {
      this.line.scale.set(1, length - headLength, 1);
      this.line.updateMatrix();
    }
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
  };
  THREE.ArrowHelper.prototype.setColor = function(color) {
    if (this.line !== undefined)
      this.line.material.color.set(color);
    this.cone.material.color.set(color);
  };
  THREE.BoxHelper = function(object) {
    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var positions = new Float32Array(8 * 3);
    var geometry = new THREE.BufferGeometry();
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
    THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({color: 0xffff00}));
    if (object !== undefined) {
      this.update(object);
    }
  };
  THREE.BoxHelper.prototype = Object.create(THREE.LineSegments.prototype);
  THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
  THREE.BoxHelper.prototype.update = (function() {
    var box = new THREE.Box3();
    return function(object) {
      box.setFromObject(object);
      if (box.empty())
        return;
      var min = box.min;
      var max = box.max;
      var position = this.geometry.attributes.position;
      var array = position.array;
      array[0] = max.x;
      array[1] = max.y;
      array[2] = max.z;
      array[3] = min.x;
      array[4] = max.y;
      array[5] = max.z;
      array[6] = min.x;
      array[7] = min.y;
      array[8] = max.z;
      array[9] = max.x;
      array[10] = min.y;
      array[11] = max.z;
      array[12] = max.x;
      array[13] = max.y;
      array[14] = min.z;
      array[15] = min.x;
      array[16] = max.y;
      array[17] = min.z;
      array[18] = min.x;
      array[19] = min.y;
      array[20] = min.z;
      array[21] = max.x;
      array[22] = min.y;
      array[23] = min.z;
      position.needsUpdate = true;
      this.geometry.computeBoundingSphere();
    };
  })();
  THREE.BoundingBoxHelper = function(object, hex) {
    var color = (hex !== undefined) ? hex : 0x888888;
    this.object = object;
    this.box = new THREE.Box3();
    THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
      color: color,
      wireframe: true
    }));
  };
  THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
  THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
  THREE.BoundingBoxHelper.prototype.update = function() {
    this.box.setFromObject(this.object);
    this.box.size(this.scale);
    this.box.center(this.position);
  };
  THREE.CameraHelper = function(camera) {
    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial({
      color: 0xffffff,
      vertexColors: THREE.FaceColors
    });
    var pointMap = {};
    var hexFrustum = 0xffaa00;
    var hexCone = 0xff0000;
    var hexUp = 0x00aaff;
    var hexTarget = 0xffffff;
    var hexCross = 0x333333;
    addLine("n1", "n2", hexFrustum);
    addLine("n2", "n4", hexFrustum);
    addLine("n4", "n3", hexFrustum);
    addLine("n3", "n1", hexFrustum);
    addLine("f1", "f2", hexFrustum);
    addLine("f2", "f4", hexFrustum);
    addLine("f4", "f3", hexFrustum);
    addLine("f3", "f1", hexFrustum);
    addLine("n1", "f1", hexFrustum);
    addLine("n2", "f2", hexFrustum);
    addLine("n3", "f3", hexFrustum);
    addLine("n4", "f4", hexFrustum);
    addLine("p", "n1", hexCone);
    addLine("p", "n2", hexCone);
    addLine("p", "n3", hexCone);
    addLine("p", "n4", hexCone);
    addLine("u1", "u2", hexUp);
    addLine("u2", "u3", hexUp);
    addLine("u3", "u1", hexUp);
    addLine("c", "t", hexTarget);
    addLine("p", "c", hexCross);
    addLine("cn1", "cn2", hexCross);
    addLine("cn3", "cn4", hexCross);
    addLine("cf1", "cf2", hexCross);
    addLine("cf3", "cf4", hexCross);
    function addLine(a, b, hex) {
      addPoint(a, hex);
      addPoint(b, hex);
    }
    function addPoint(id, hex) {
      geometry.vertices.push(new THREE.Vector3());
      geometry.colors.push(new THREE.Color(hex));
      if (pointMap[id] === undefined) {
        pointMap[id] = [];
      }
      pointMap[id].push(geometry.vertices.length - 1);
    }
    THREE.LineSegments.call(this, geometry, material);
    this.camera = camera;
    this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
  };
  THREE.CameraHelper.prototype = Object.create(THREE.LineSegments.prototype);
  THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
  THREE.CameraHelper.prototype.update = function() {
    var geometry,
        pointMap;
    var vector = new THREE.Vector3();
    var camera = new THREE.Camera();
    function setPoint(point, x, y, z) {
      vector.set(x, y, z).unproject(camera);
      var points = pointMap[point];
      if (points !== undefined) {
        for (var i = 0,
            il = points.length; i < il; i++) {
          geometry.vertices[points[i]].copy(vector);
        }
      }
    }
    return function() {
      geometry = this.geometry;
      pointMap = this.pointMap;
      var w = 1,
          h = 1;
      camera.projectionMatrix.copy(this.camera.projectionMatrix);
      setPoint("c", 0, 0, -1);
      setPoint("t", 0, 0, 1);
      setPoint("n1", -w, -h, -1);
      setPoint("n2", w, -h, -1);
      setPoint("n3", -w, h, -1);
      setPoint("n4", w, h, -1);
      setPoint("f1", -w, -h, 1);
      setPoint("f2", w, -h, 1);
      setPoint("f3", -w, h, 1);
      setPoint("f4", w, h, 1);
      setPoint("u1", w * 0.7, h * 1.1, -1);
      setPoint("u2", -w * 0.7, h * 1.1, -1);
      setPoint("u3", 0, h * 2, -1);
      setPoint("cf1", -w, 0, 1);
      setPoint("cf2", w, 0, 1);
      setPoint("cf3", 0, -h, 1);
      setPoint("cf4", 0, h, 1);
      setPoint("cn1", -w, 0, -1);
      setPoint("cn2", w, 0, -1);
      setPoint("cn3", 0, -h, -1);
      setPoint("cn4", 0, h, -1);
      geometry.verticesNeedUpdate = true;
    };
  }();
  THREE.DirectionalLightHelper = function(light, size) {
    THREE.Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    size = size || 1;
    var geometry = new THREE.Geometry();
    geometry.vertices.push(new THREE.Vector3(-size, size, 0), new THREE.Vector3(size, size, 0), new THREE.Vector3(size, -size, 0), new THREE.Vector3(-size, -size, 0), new THREE.Vector3(-size, size, 0));
    var material = new THREE.LineBasicMaterial({fog: false});
    material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.lightPlane = new THREE.Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new THREE.Geometry();
    geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3());
    material = new THREE.LineBasicMaterial({fog: false});
    material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.targetLine = new THREE.Line(geometry, material);
    this.add(this.targetLine);
    this.update();
  };
  THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
  THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
  THREE.DirectionalLightHelper.prototype.dispose = function() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  };
  THREE.DirectionalLightHelper.prototype.update = function() {
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var v3 = new THREE.Vector3();
    return function() {
      v1.setFromMatrixPosition(this.light.matrixWorld);
      v2.setFromMatrixPosition(this.light.target.matrixWorld);
      v3.subVectors(v2, v1);
      this.lightPlane.lookAt(v3);
      this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      this.targetLine.geometry.vertices[1].copy(v3);
      this.targetLine.geometry.verticesNeedUpdate = true;
      this.targetLine.material.color.copy(this.lightPlane.material.color);
    };
  }();
  THREE.EdgesHelper = function(object, hex, thresholdAngle) {
    var color = (hex !== undefined) ? hex : 0xffffff;
    THREE.LineSegments.call(this, new THREE.EdgesGeometry(object.geometry, thresholdAngle), new THREE.LineBasicMaterial({color: color}));
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  };
  THREE.EdgesHelper.prototype = Object.create(THREE.LineSegments.prototype);
  THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
  THREE.FaceNormalsHelper = function(object, size, hex, linewidth) {
    this.object = object;
    this.size = (size !== undefined) ? size : 1;
    var color = (hex !== undefined) ? hex : 0xffff00;
    var width = (linewidth !== undefined) ? linewidth : 1;
    var nNormals = 0;
    var objGeometry = this.object.geometry;
    if (objGeometry instanceof THREE.Geometry) {
      nNormals = objGeometry.faces.length;
    } else {
      console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
    }
    var geometry = new THREE.BufferGeometry();
    var positions = new THREE.Float32Attribute(nNormals * 2 * 3, 3);
    geometry.addAttribute('position', positions);
    THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({
      color: color,
      linewidth: width
    }));
    this.matrixAutoUpdate = false;
    this.update();
  };
  THREE.FaceNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);
  THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
  THREE.FaceNormalsHelper.prototype.update = (function() {
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var normalMatrix = new THREE.Matrix3();
    return function update() {
      this.object.updateMatrixWorld(true);
      normalMatrix.getNormalMatrix(this.object.matrixWorld);
      var matrixWorld = this.object.matrixWorld;
      var position = this.geometry.attributes.position;
      var objGeometry = this.object.geometry;
      var vertices = objGeometry.vertices;
      var faces = objGeometry.faces;
      var idx = 0;
      for (var i = 0,
          l = faces.length; i < l; i++) {
        var face = faces[i];
        var normal = face.normal;
        v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
        v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
        position.setXYZ(idx, v1.x, v1.y, v1.z);
        idx = idx + 1;
        position.setXYZ(idx, v2.x, v2.y, v2.z);
        idx = idx + 1;
      }
      position.needsUpdate = true;
      return this;
    };
  }());
  THREE.GridHelper = function(size, step) {
    var geometry = new THREE.Geometry();
    var material = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
    this.color1 = new THREE.Color(0x444444);
    this.color2 = new THREE.Color(0x888888);
    for (var i = -size; i <= size; i += step) {
      geometry.vertices.push(new THREE.Vector3(-size, 0, i), new THREE.Vector3(size, 0, i), new THREE.Vector3(i, 0, -size), new THREE.Vector3(i, 0, size));
      var color = i === 0 ? this.color1 : this.color2;
      geometry.colors.push(color, color, color, color);
    }
    THREE.LineSegments.call(this, geometry, material);
  };
  THREE.GridHelper.prototype = Object.create(THREE.LineSegments.prototype);
  THREE.GridHelper.prototype.constructor = THREE.GridHelper;
  THREE.GridHelper.prototype.setColors = function(colorCenterLine, colorGrid) {
    this.color1.set(colorCenterLine);
    this.color2.set(colorGrid);
    this.geometry.colorsNeedUpdate = true;
  };
  THREE.HemisphereLightHelper = function(light, sphereSize) {
    THREE.Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.colors = [new THREE.Color(), new THREE.Color()];
    var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
    geometry.rotateX(-Math.PI / 2);
    for (var i = 0,
        il = 8; i < il; i++) {
      geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
    }
    var material = new THREE.MeshBasicMaterial({
      vertexColors: THREE.FaceColors,
      wireframe: true
    });
    this.lightSphere = new THREE.Mesh(geometry, material);
    this.add(this.lightSphere);
    this.update();
  };
  THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
  THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
  THREE.HemisphereLightHelper.prototype.dispose = function() {
    this.lightSphere.geometry.dispose();
    this.lightSphere.material.dispose();
  };
  THREE.HemisphereLightHelper.prototype.update = function() {
    var vector = new THREE.Vector3();
    return function() {
      this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
      this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
      this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
      this.lightSphere.geometry.colorsNeedUpdate = true;
    };
  }();
  THREE.PointLightHelper = function(light, sphereSize) {
    this.light = light;
    this.light.updateMatrixWorld();
    var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
    var material = new THREE.MeshBasicMaterial({
      wireframe: true,
      fog: false
    });
    material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    THREE.Mesh.call(this, geometry, material);
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
  };
  THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
  THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
  THREE.PointLightHelper.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
  };
  THREE.PointLightHelper.prototype.update = function() {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  };
  THREE.SkeletonHelper = function(object) {
    this.bones = this.getBoneList(object);
    var geometry = new THREE.Geometry();
    for (var i = 0; i < this.bones.length; i++) {
      var bone = this.bones[i];
      if (bone.parent instanceof THREE.Bone) {
        geometry.vertices.push(new THREE.Vector3());
        geometry.vertices.push(new THREE.Vector3());
        geometry.colors.push(new THREE.Color(0, 0, 1));
        geometry.colors.push(new THREE.Color(0, 1, 0));
      }
    }
    geometry.dynamic = true;
    var material = new THREE.LineBasicMaterial({
      vertexColors: THREE.VertexColors,
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    THREE.LineSegments.call(this, geometry, material);
    this.root = object;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
  };
  THREE.SkeletonHelper.prototype = Object.create(THREE.LineSegments.prototype);
  THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
  THREE.SkeletonHelper.prototype.getBoneList = function(object) {
    var boneList = [];
    if (object instanceof THREE.Bone) {
      boneList.push(object);
    }
    for (var i = 0; i < object.children.length; i++) {
      boneList.push.apply(boneList, this.getBoneList(object.children[i]));
    }
    return boneList;
  };
  THREE.SkeletonHelper.prototype.update = function() {
    var geometry = this.geometry;
    var matrixWorldInv = new THREE.Matrix4().getInverse(this.root.matrixWorld);
    var boneMatrix = new THREE.Matrix4();
    var j = 0;
    for (var i = 0; i < this.bones.length; i++) {
      var bone = this.bones[i];
      if (bone.parent instanceof THREE.Bone) {
        boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
        geometry.vertices[j].setFromMatrixPosition(boneMatrix);
        boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
        geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);
        j += 2;
      }
    }
    geometry.verticesNeedUpdate = true;
    geometry.computeBoundingSphere();
  };
  THREE.SpotLightHelper = function(light) {
    THREE.Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    var geometry = new THREE.CylinderGeometry(0, 1, 1, 8, 1, true);
    geometry.translate(0, -0.5, 0);
    geometry.rotateX(-Math.PI / 2);
    var material = new THREE.MeshBasicMaterial({
      wireframe: true,
      fog: false
    });
    this.cone = new THREE.Mesh(geometry, material);
    this.add(this.cone);
    this.update();
  };
  THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
  THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
  THREE.SpotLightHelper.prototype.dispose = function() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  };
  THREE.SpotLightHelper.prototype.update = function() {
    var vector = new THREE.Vector3();
    var vector2 = new THREE.Vector3();
    return function() {
      var coneLength = this.light.distance ? this.light.distance : 10000;
      var coneWidth = coneLength * Math.tan(this.light.angle);
      this.cone.scale.set(coneWidth, coneWidth, coneLength);
      vector.setFromMatrixPosition(this.light.matrixWorld);
      vector2.setFromMatrixPosition(this.light.target.matrixWorld);
      this.cone.lookAt(vector2.sub(vector));
      this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
  }();
  THREE.VertexNormalsHelper = function(object, size, hex, linewidth) {
    this.object = object;
    this.size = (size !== undefined) ? size : 1;
    var color = (hex !== undefined) ? hex : 0xff0000;
    var width = (linewidth !== undefined) ? linewidth : 1;
    var nNormals = 0;
    var objGeometry = this.object.geometry;
    if (objGeometry instanceof THREE.Geometry) {
      nNormals = objGeometry.faces.length * 3;
    } else if (objGeometry instanceof THREE.BufferGeometry) {
      nNormals = objGeometry.attributes.normal.count;
    }
    var geometry = new THREE.BufferGeometry();
    var positions = new THREE.Float32Attribute(nNormals * 2 * 3, 3);
    geometry.addAttribute('position', positions);
    THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({
      color: color,
      linewidth: width
    }));
    this.matrixAutoUpdate = false;
    this.update();
  };
  THREE.VertexNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);
  THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
  THREE.VertexNormalsHelper.prototype.update = (function() {
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var normalMatrix = new THREE.Matrix3();
    return function update() {
      var keys = ['a', 'b', 'c'];
      this.object.updateMatrixWorld(true);
      normalMatrix.getNormalMatrix(this.object.matrixWorld);
      var matrixWorld = this.object.matrixWorld;
      var position = this.geometry.attributes.position;
      var objGeometry = this.object.geometry;
      if (objGeometry instanceof THREE.Geometry) {
        var vertices = objGeometry.vertices;
        var faces = objGeometry.faces;
        var idx = 0;
        for (var i = 0,
            l = faces.length; i < l; i++) {
          var face = faces[i];
          for (var j = 0,
              jl = face.vertexNormals.length; j < jl; j++) {
            var vertex = vertices[face[keys[j]]];
            var normal = face.vertexNormals[j];
            v1.copy(vertex).applyMatrix4(matrixWorld);
            v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
            position.setXYZ(idx, v1.x, v1.y, v1.z);
            idx = idx + 1;
            position.setXYZ(idx, v2.x, v2.y, v2.z);
            idx = idx + 1;
          }
        }
      } else if (objGeometry instanceof THREE.BufferGeometry) {
        var objPos = objGeometry.attributes.position;
        var objNorm = objGeometry.attributes.normal;
        var idx = 0;
        for (var j = 0,
            jl = objPos.count; j < jl; j++) {
          v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
          v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
          v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
          position.setXYZ(idx, v1.x, v1.y, v1.z);
          idx = idx + 1;
          position.setXYZ(idx, v2.x, v2.y, v2.z);
          idx = idx + 1;
        }
      }
      position.needsUpdate = true;
      return this;
    };
  }());
  THREE.WireframeHelper = function(object, hex) {
    var color = (hex !== undefined) ? hex : 0xffffff;
    THREE.LineSegments.call(this, new THREE.WireframeGeometry(object.geometry), new THREE.LineBasicMaterial({color: color}));
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  };
  THREE.WireframeHelper.prototype = Object.create(THREE.LineSegments.prototype);
  THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
  THREE.ImmediateRenderObject = function(material) {
    THREE.Object3D.call(this);
    this.material = material;
    this.render = function(renderCallback) {};
  };
  THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
  THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
  THREE.MorphBlendMesh = function(geometry, material) {
    THREE.Mesh.call(this, geometry, material);
    this.animationsMap = {};
    this.animationsList = [];
    var numFrames = this.geometry.morphTargets.length;
    var name = "__default";
    var startFrame = 0;
    var endFrame = numFrames - 1;
    var fps = numFrames / 1;
    this.createAnimation(name, startFrame, endFrame, fps);
    this.setAnimationWeight(name, 1);
  };
  THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
  THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
  THREE.MorphBlendMesh.prototype.createAnimation = function(name, start, end, fps) {
    var animation = {
      start: start,
      end: end,
      length: end - start + 1,
      fps: fps,
      duration: (end - start) / fps,
      lastFrame: 0,
      currentFrame: 0,
      active: false,
      time: 0,
      direction: 1,
      weight: 1,
      directionBackwards: false,
      mirroredLoop: false
    };
    this.animationsMap[name] = animation;
    this.animationsList.push(animation);
  };
  THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(fps) {
    var pattern = /([a-z]+)_?(\d+)/;
    var firstAnimation,
        frameRanges = {};
    var geometry = this.geometry;
    for (var i = 0,
        il = geometry.morphTargets.length; i < il; i++) {
      var morph = geometry.morphTargets[i];
      var chunks = morph.name.match(pattern);
      if (chunks && chunks.length > 1) {
        var name = chunks[1];
        if (!frameRanges[name])
          frameRanges[name] = {
            start: Infinity,
            end: -Infinity
          };
        var range = frameRanges[name];
        if (i < range.start)
          range.start = i;
        if (i > range.end)
          range.end = i;
        if (!firstAnimation)
          firstAnimation = name;
      }
    }
    for (var name in frameRanges) {
      var range = frameRanges[name];
      this.createAnimation(name, range.start, range.end, fps);
    }
    this.firstAnimation = firstAnimation;
  };
  THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.direction = 1;
      animation.directionBackwards = false;
    }
  };
  THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.direction = -1;
      animation.directionBackwards = true;
    }
  };
  THREE.MorphBlendMesh.prototype.setAnimationFPS = function(name, fps) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.fps = fps;
      animation.duration = (animation.end - animation.start) / animation.fps;
    }
  };
  THREE.MorphBlendMesh.prototype.setAnimationDuration = function(name, duration) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.duration = duration;
      animation.fps = (animation.end - animation.start) / animation.duration;
    }
  };
  THREE.MorphBlendMesh.prototype.setAnimationWeight = function(name, weight) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.weight = weight;
    }
  };
  THREE.MorphBlendMesh.prototype.setAnimationTime = function(name, time) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.time = time;
    }
  };
  THREE.MorphBlendMesh.prototype.getAnimationTime = function(name) {
    var time = 0;
    var animation = this.animationsMap[name];
    if (animation) {
      time = animation.time;
    }
    return time;
  };
  THREE.MorphBlendMesh.prototype.getAnimationDuration = function(name) {
    var duration = -1;
    var animation = this.animationsMap[name];
    if (animation) {
      duration = animation.duration;
    }
    return duration;
  };
  THREE.MorphBlendMesh.prototype.playAnimation = function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.time = 0;
      animation.active = true;
    } else {
      console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
    }
  };
  THREE.MorphBlendMesh.prototype.stopAnimation = function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.active = false;
    }
  };
  THREE.MorphBlendMesh.prototype.update = function(delta) {
    for (var i = 0,
        il = this.animationsList.length; i < il; i++) {
      var animation = this.animationsList[i];
      if (!animation.active)
        continue;
      var frameTime = animation.duration / animation.length;
      animation.time += animation.direction * delta;
      if (animation.mirroredLoop) {
        if (animation.time > animation.duration || animation.time < 0) {
          animation.direction *= -1;
          if (animation.time > animation.duration) {
            animation.time = animation.duration;
            animation.directionBackwards = true;
          }
          if (animation.time < 0) {
            animation.time = 0;
            animation.directionBackwards = false;
          }
        }
      } else {
        animation.time = animation.time % animation.duration;
        if (animation.time < 0)
          animation.time += animation.duration;
      }
      var keyframe = animation.start + THREE.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
      var weight = animation.weight;
      if (keyframe !== animation.currentFrame) {
        this.morphTargetInfluences[animation.lastFrame] = 0;
        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
        this.morphTargetInfluences[keyframe] = 0;
        animation.lastFrame = animation.currentFrame;
        animation.currentFrame = keyframe;
      }
      var mix = (animation.time % frameTime) / frameTime;
      if (animation.directionBackwards)
        mix = 1 - mix;
      if (animation.currentFrame !== animation.lastFrame) {
        this.morphTargetInfluences[animation.currentFrame] = mix * weight;
        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
      } else {
        this.morphTargetInfluences[animation.currentFrame] = weight;
      }
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3", ["c3"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('c3');
  global.define = __define;
  return module.exports;
});

$__System.register('1e', ['3'], function (_export) {
  /**
  * @author Lianna Eeftinck / https://github.com/Leeft
  */

  'use strict';

  var THREE, WebGLRenderer, Color, Vector2, Vector3, Matrix4, Euler, Scene, PerspectiveCamera, Object3D, Mesh, MeshBasicMaterial;
  return {
    setters: [function (_) {
      THREE = _['default'];
    }],
    execute: function () {
      WebGLRenderer = THREE.WebGLRenderer;
      Color = THREE.Color;
      Vector2 = THREE.Vector2;
      Vector3 = THREE.Vector3;
      Matrix4 = THREE.Matrix4;
      Euler = THREE.Euler;
      Scene = THREE.Scene;
      PerspectiveCamera = THREE.PerspectiveCamera;
      Object3D = THREE.Object3D;
      Mesh = THREE.Mesh;
      MeshBasicMaterial = THREE.MeshBasicMaterial;

      _export('WebGLRenderer', WebGLRenderer);

      _export('Color', Color);

      _export('Vector2', Vector2);

      _export('Vector3', Vector3);

      _export('Matrix4', Matrix4);

      _export('Euler', Euler);

      _export('Scene', Scene);

      _export('PerspectiveCamera', PerspectiveCamera);

      _export('Object3D', Object3D);

      _export('Mesh', Mesh);

      _export('MeshBasicMaterial', MeshBasicMaterial);
    }
  };
});
$__System.register('6a', ['1', '6', '8', '9', '34', '1e'], function (_export) {
  var SCMAP, StarSystem, _createClass, _classCallCheck, _Object$assign, Color, DEFAULTS, Faction;

  return {
    setters: [function (_4) {
      SCMAP = _4['default'];
    }, function (_5) {
      StarSystem = _5['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_3) {
      _Object$assign = _3['default'];
    }, function (_e) {
      Color = _e.Color;
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      'use strict';

      DEFAULTS = {
        id: undefined,
        name: 'Unclaimed',
        isRealFaction: false,
        color: new Color(0xFFFFFF),
        parentFaction: null
      };

      Faction = (function () {
        function Faction(data) {
          _classCallCheck(this, Faction);

          _Object$assign(this, DEFAULTS, data);

          // Internals
          this._claimed = {
            systems: {}
          };
        }

        _createClass(Faction, [{
          key: 'claim',
          value: function claim(system) {
            if (!system instanceof StarSystem) {
              throw new Error('A faction can only claim ownership over a system');
            }
            this._claimed.systems[system.uuid] = true;
            return this;
          }
        }, {
          key: 'claimed',
          value: function claimed(system) {
            if (!system instanceof StarSystem) {
              throw new Error('A faction can only test ownership over a system');
            }
            return this._claimed.systems[system.uuid];
          }
        }, {
          key: 'isHostileTo',
          value: function isHostileTo(comparedTo) {
            if (!(comparedTo instanceof Faction)) {
              throw new Error('Can only compare to other factions');
            }
            // FIXME: more data in database, more logic here
            // rather than lots of hardcoding
            if (comparedTo.name === 'Vanduul') {
              return this.name !== 'Vanduul';
            } else {
              return this.name === 'Vanduul';
            }
          }
        }, {
          key: 'planeColor',
          get: function get() {
            return this.color.clone().offsetHSL(0, 0.5, 0).multiplyScalar(0.20);
          }
        }, {
          key: 'lineColor',
          get: function get() {
            return this.color.clone().offsetHSL(0, 0.05, -0.05);
          }
        }]);

        return Faction;
      })();

      _export('default', Faction);
    }
  };
});
$__System.register('69', ['9', '34'], function (_export) {
  var _classCallCheck, _Object$assign, DEFAULTS, Goods;

  return {
    setters: [function (_) {
      _classCallCheck = _['default'];
    }, function (_2) {
      _Object$assign = _2['default'];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      'use strict';

      DEFAULTS = {
        id: undefined,
        name: 'Unknown',
        blackMarket: false
      };

      Goods = function Goods(data) {
        _classCallCheck(this, Goods);

        _Object$assign(this, DEFAULTS, data);

        // Internals
        this._trade = {
          importing: [],
          exporting: [],
          blackMarket: []
        };
      };

      _export('default', Goods);
    }
  };
});
$__System.registerDynamic("9", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("56", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("53", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("50", ["53"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = $__require('53');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("45", ["56", "23", "50"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('56'),
      core = $__require('23'),
      ctx = $__require('50'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? (function(C) {
        var F = function(param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("40", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3b", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c4", ["3b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var defined = $__require('3b');
  module.exports = function(it) {
    return Object(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4e", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6d", ["4e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('4e');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5e", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c5", ["40", "c4", "6d", "5e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('40'),
      toObject = $__require('c4'),
      IObject = $__require('6d');
  module.exports = $__require('5e')(function() {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j)
        if (isEnum.call(S, key = keys[j++]))
          T[key] = S[key];
    }
    return T;
  } : Object.assign;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c6", ["45", "c5"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('45');
  $export($export.S + $export.F, 'Object', {assign: $__require('c5')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("23", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c7", ["c6", "23"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('c6');
  module.exports = $__require('23').Object.assign;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("34", ["c7"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('c7'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.register('b', ['9', '34'], function (_export) {
  var _classCallCheck, _Object$assign, DEFAULTS, Config;

  return {
    setters: [function (_) {
      _classCallCheck = _['default'];
    }, function (_2) {
      _Object$assign = _2['default'];
    }],
    execute: function () {
      /**
      * @author Lianna Eeftinck / https://github.com/Leeft
      */

      // These are deliberately strings: code using these numbers must be able
      // to cope with strings as they may come from HTML data attributes.
      'use strict';

      DEFAULTS = {
        systemsJson: 'data/systems.min.json',
        goodsJson: 'data/goods.json',
        crimeLevelsJson: 'data/crime-levels.json',
        factionsJson: 'data/factions.json',
        strategicValuesJson: 'data/uee-strategic-values.json',

        glowImage: 'images/glow.png',

        rotateSpeed: '0.1',
        zoomSpeed: '1.0',
        panSpeed: '0.6',

        minSystemScale: '0.5',
        defaultSystemScale: '1.0',
        maxSystemScale: '1.50',
        systemScale: 0.5, // system geometry is multiplied by this for the actual scene

        // These should've been named *LabelUserScale
        minLabelScale: '0.4',
        defaultLabelScale: '1.0',
        maxLabelScale: '2.0',
        labelScale: 2.5, // sprite labels are multiplied by this for the actual scene

        minLabelOffset: '-6.5',
        defaultLabelOffset: '4.0',
        maxLabelOffset: '7.5',

        debug: false,
        quality: 'high',

        renderScale: 0.5, // to grow or shrink

        // takes 8m 19s at 1c, but autopilot speed is only 0.2c
        // FIXME: this value is probably going to be WAY, WAY off.
        approximateTraveltimePerAU: (8 * 60 + 19) * 5
      };

      Config = function Config() {
        _classCallCheck(this, Config);

        var element = document.getElementById('sc-map-configuration');
        if (element && typeof element.dataset === 'object') {
          _Object$assign(this, DEFAULTS, element.dataset);
        } else {
          _Object$assign(this, DEFAULTS);
        }
      };

      _export('default', new Config());
    }
  };
});
$__System.register('5', ['b'], function (_export) {
  'use strict';

  var config;

  function hasLocalStorage() {
    try {
      return 'localStorage' in window && window.localStorage !== null;
    } catch (e) {
      return false;
    }
  }

  function hasSessionStorage() {
    try {
      return 'sessionStorage' in window && window.sessionStorage !== null;
    } catch (e) {
      return false;
    }
  }

  function humanSort(a, b) {
    var aa = a.name.split(/(\d+)/);
    var bb = b.name.split(/(\d+)/);

    for (var x = 0; x < Math.max(aa.length, bb.length); x++) {
      if (aa[x] != bb[x]) {
        var cmp1 = isNaN(parseInt(aa[x], 10)) ? aa[x] : parseInt(aa[x], 10);
        var cmp2 = isNaN(parseInt(bb[x], 10)) ? bb[x] : parseInt(bb[x], 10);

        if (cmp1 === undefined || cmp2 === undefined) {
          return aa.length - bb.length;
        } else {
          return cmp1 < cmp2 ? -1 : 1;
        }
      }
    }

    return 0;
  }

  function travelTimeForAU(distanceAU) {
    return config.approximateTraveltimePerAU * distanceAU;
  }

  return {
    setters: [function (_b) {
      config = _b['default'];
    }],
    execute: function () {
      _export('hasLocalStorage', hasLocalStorage);

      _export('hasSessionStorage', hasSessionStorage);

      _export('humanSort', humanSort);

      _export('travelTimeForAU', travelTimeForAU);
    }
  };
});
$__System.register('1', ['5', '6', '8', '9', '69', '1e', '6a'], function (_export) {
  var humanSort, StarSystem, _createClass, _classCallCheck, Goods, Color, Faction, MAPREVISION, LYtoAU, SCMAP;

  return {
    setters: [function (_5) {
      humanSort = _5.humanSort;
    }, function (_3) {
      StarSystem = _3['default'];
    }, function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_4) {
      Goods = _4['default'];
    }, function (_e) {
      Color = _e.Color;
    }, function (_a) {
      Faction = _a['default'];
    }],
    execute: function () {
      /**
        * @author Lianna Eeftinck / https://github.com/Leeft
        **/

      'use strict';

      MAPREVISION = 5;
      LYtoAU = 63241.077;
      // Not used atm, but keeping around for convenience

      SCMAP = (function () {
        function SCMAP() {
          _classCallCheck(this, SCMAP);

          this.data = {
            systems: {},
            systemsById: {},
            factions: {},
            crimeLevels: {},
            ueeStrategicValues: {},
            commodities: {},
            allSystems: []
          };
        }

        _createClass(SCMAP, [{
          key: 'importStarSystems',
          value: function importStarSystems(json) {
            var systems = [];

            // First build basic objects to make them all known
            // (this will also initialise any jumppoints it can)
            for (var systemName in json) {
              var system = StarSystem.fromJSON(json[systemName]);
              this.data.systems[system.name] = system;
              this.data.systemsById[system.id] = system;
              this.data.systemsById[system.uuid] = system;
              systems.push(system);
            }

            // Now go through the built objects again, fixing any leftover jumppoint data
            systems.forEach(function (system) {
              system._fixJumpPoints(true);
            });

            // And provide them in a "human friendly" sort order
            this.data.allSystems = SCMAP.SortSystemList(systems);
          }
        }, {
          key: 'getStarSystemByName',
          value: function getStarSystemByName(name) {
            return this.data.systems[name];
          }
        }, {
          key: 'getStarSystemById',
          value: function getStarSystemById(id) {
            return this.data.systemsById[id];
          }
        }, {
          key: 'importFactions',
          value: function importFactions(json) {
            var _this = this;

            var factions = [];

            for (var factionId in json) {
              var data = json[factionId];
              var faction = new Faction({
                id: data.id,
                name: data.name,
                color: new Color(data.color),
                isRealFaction: data.isActualFaction,
                parentFaction: data.parentFaction
              });
              this.data.factions[data.id] = faction;
              factions.push(faction);
            }

            factions.forEach(function (faction) {
              if (faction.parentFaction) {
                faction.parentFaction = _this.data.factions[faction.parentFaction];
              }
            });
          }
        }, {
          key: 'getFactionById',
          value: function getFactionById(id) {
            var faction = this.data.factions[id];
            if (!(faction instanceof Faction)) {
              faction = this.data.factions.UCLM;
            }
            return faction;
          }
        }, {
          key: 'importCommodities',
          value: function importCommodities(json) {
            for (var commodityId in json) {
              var data = json[commodityId];
              this.data.commodities[data.id] = new Goods({
                id: data.id,
                name: data.name,
                blackMarket: data.blackMarket
              });
            }
          }
        }, {
          key: 'getCommodityById',
          value: function getCommodityById(id) {
            return this.data.commodities[id];
          }
        }, {
          key: 'importUEEStrategicValues',
          value: function importUEEStrategicValues(json) {
            this.data.ueeStrategicValues = json;
          }
        }, {
          key: 'getUEEStrategicValueById',
          value: function getUEEStrategicValueById(id) {
            return this.data.ueeStrategicValues[id];
          }
        }, {
          key: 'importCrimeLevels',
          value: function importCrimeLevels(json) {
            this.data.crimeLevels = json;
          }
        }, {
          key: 'getCrimeLevelById',
          value: function getCrimeLevelById(id) {
            return this.data.crimeLevels[id];
          }
        }, {
          key: 'REVISION',
          get: function get() {
            return MAPREVISION;
          }
        }, {
          key: 'allSystems',
          get: function get() {
            return this.data.allSystems;
          }
        }], [{
          key: 'SortSystemList',
          value: function SortSystemList(systems) {
            var array = [];
            var i = systems.length;
            while (i--) {
              array[i] = systems[i];
            }
            return array.sort(humanSort);
          }
        }]);

        return SCMAP;
      })();

      _export('default', new SCMAP());
    }
  };
});
})
(function(factory) {
  factory();
});
//# sourceMappingURL=starcitizen-webgl-map.js.map